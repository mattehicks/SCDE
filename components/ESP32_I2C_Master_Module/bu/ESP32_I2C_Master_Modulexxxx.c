/* #################################################################################################
 *
 *      Name: ESP32_I2C_Master Module
 *  Function: This is used to set up GPIOs as a switch with the goal to control switching hardware
 *            (relay, ...). The GPIO switching is Hardware PWM driven (for ESP32 SOC only). 
 *            Module for use with SCDE (Smart Connected Device Engine) only !
 *
 *  ESP 8266EX & ESP32 SoC Activities ...
 *  HoME CoNTROL & Smart Connected Device Engine Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 *
 *
 */
//http://www.elektronik-magazin.de/page/der-i2c-bus-was-ist-das-21


#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>

#include <SCDE_s.h>

#include "ESP32_I2C_Master_Module.h"

#include "SCDE_Main.h"

#include "driver/gpio.h"




// -------------------------------------------------------------------------------------------------

// ammount of debug information 0 = off 5 max?
#ifndef ESP32_I2C_Master_DBG
#define ESP32_I2C_Master_DBG 0
#endif

// -------------------------------------------------------------------------------------------------

// make data root locally available
static SCDERoot_t* SCDERoot;

// make locally available from data-root: the SCDEFn (Functions / callbacks) for operation
static SCDEFn_t* SCDEFn;

// -------------------------------------------------------------------------------------------------

#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------



/*
 * Implemented Values for Keys
 */

// ESP32_I2C_Master_SET_SIG_OUT_EN -> 'SIG_OUT_EN' -> Disabled|Enabled
SelectAData ESP32_I2C_Master_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// ESP32_I2C_Master_SET_IDLE_LV -> 'IDLE_LV' -> Low|High
SelectAData ESP32_I2C_Master_LoHi[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Low"},
  {1,"High"}, 
  {0, NULL}
  };

// ESP32_I2C_Master_SET_BLOCK -> 'PWM_BLOCK'-> High_Speed|Low_Speed
SelectAData ESP32_I2C_Master_PWM_BLOCK[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"High_Speed"},
  {1,"Low_Speed"},
  {0, NULL}
  };

// ESP32_I2C_Master_SET_TICK_SOURCE -> 'TICK_SOURCE'-> REF|APB_SLOW
SelectAData ESP32_I2C_Master_TICK_SOURCE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"REF"},
  {1,"APB_SLOW"}, 
  {0, NULL}
  };



/**
 * For Type: ESP32_I2C_Master
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in ESP32_I2C_Master_parsedKVInput_t
 */
enum ESP32_I2C_Master_SET_IK {				// Bit #XX for debugging

  // S0 calculation configuration
    ESP32_I2C_Master_SET_ON		= 0			// Bit #00 'ON'  -> 
  , ESP32_I2C_Master_SET_OFF				// Bit #01 'OFF'  -> 

  , ESP32_I2C_Master_SET_MAX				// Bit #02 'MAX'  -> 
  , ESP32_I2C_Master_SET_MIN				// Bit #03 'MIN'  -> 

  , ESP32_I2C_Master_SET_VAL				// Bit #04 'VAL'  -> 
  , ESP32_I2C_Master_SET_DIM				// Bit #05 'DIM'  -> 

  , ESP32_I2C_Master_SET_NAME				// Bit #06 'NAME'  -> 
  , ESP32_I2C_Master_SET_CAPS				// Bit #07 'CAPS'  -> 

  // Block #01 PWM configuration
  , ESP32_I2C_Master_SET_GPIO				// Bit #08 'GPIO' -> 
  , ESP32_I2C_Master_SET_BLOCK				// Bit #09 'BLOCK' -> 
  , ESP32_I2C_Master_SET_CHANNEL				// Bit #10 'CHANNEL' -> 
  , ESP32_I2C_Master_SET_TIMER				// Bit #11 'TIMER' -> 

  , ESP32_I2C_Master_SET_DUTY				// Bit #12 'DUTY' ->
  , ESP32_I2C_Master_SET_HPOINT				// Bit #13 'HPOINT' ->
  , ESP32_I2C_Master_SET_SIG_OUT_EN				// Bit #14 'SIG_OUT_EN' ->
  , ESP32_I2C_Master_SET_IDLE_LV				// Bit #15 'IDLE_LV' ->

  , ESP32_I2C_Master_SET_RESOLUTION			// Bit #16 'RESOLUTION' -> 
  , ESP32_I2C_Master_SET_TICK_SOURCE			// Bit #17 'TICK_SOURCE' ->
  , ESP32_I2C_Master_SET_FREQ_HZ				// Bit #18 'FREQ_HZ' ->

  , ESP32_I2C_Master_SET_THR_L_LIM_EN			// Bit #19 'THR_L_LIM_EN' -> DIS/ENA
  , ESP32_I2C_Master_SET_THR_H_LIM_EN			// Bit #20 'THR_H_LIM_EN' -> DIS/ENA
  , ESP32_I2C_Master_SET_THR_ZERO_EN			// Bit #21 'THR_ZERO_EN' -> DIS/ENA
  , ESP32_I2C_Master_SET_FILTER_EN				// Bit #22 'FILTER_EN' -> DIS/ENA
  , ESP32_I2C_Master_SET_FILTER_THRES			// Bit #23 'FILTER_THRES' -> decval 10 bit zahl
  , ESP32_I2C_Master_SET_CNT_THRES1				// Bit #24 'CNT_THRES1' -> decval 16 bit zahl
  , ESP32_I2C_Master_SET_CNT_THRES0				// Bit #25 'CNT_THRES0' -> decval 16 bit zahl
  , ESP32_I2C_Master_SET_CNT_L_LIM				// Bit #26 'CNT_L_LIM' -> decval 10 bit zahl
  , ESP32_I2C_Master_SET_CNT_H_LIM				// Bit #27 'CNT_H_LIM' -> decval 10 bit zahl

// end marker
  , ESP32_I2C_Master_SET_IK_Number_of_keys			// Bit #27 MAX 64 IMPLEMENTED !

};

 

/**
 * For Type: ESP32_I2C_Master
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum ESP32_I2C_Master_Readings {			// Bit #XX for debugging

   ESP32_I2C_Master_R_DUTY		= (1<<0)	// Bit #00 'Duty'  -> 

  ,ESP32_I2C_Master_R_RESOLUTION	= (1<<1)	// Bit #01 'Resolution' -> 

  ,ESP32_I2C_Master_R_NAME		= (1<<2)	// Bit #02 'name' + caps + ufid -> 

};



/**
 * For Type: ESP32_I2C_Master
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()

 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t ESP32_I2C_Master_Set_ImplementedKeys[] = {
// |                                                          affected readings										              	|  CMD

// for usage 
   { ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "ON" }		// #00
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "OFF" }		// #01
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "MAX" }		// #02
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "MIN" }		// #03
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "VAL" }		// #04
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION															, "DIM" }		// #05

  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION | ESP32_I2C_Master_R_NAME												, "NAME" }		// #06
  ,{ ESP32_I2C_Master_R_DUTY | ESP32_I2C_Master_R_RESOLUTION | ESP32_I2C_Master_R_NAME												, "CAPS" }		// #07

// for configuration
  ,{ 0																					, "GPIO" }		// #08
  ,{ 0																					, "BLOCK" }		// #09
  ,{ 0																					, "CHANNEL" }		// #10
  ,{ 0																					, "TIMER" }		// #11
  ,{ 0																					, "DUTY" }		// #12
  ,{ 0																					, "HPOINT" }		// #13
  ,{ 0																					, "SIG_OUT_EN" }	// #14
  ,{ 0																					, "IDLE_LV" }		// #15

  ,{ 0																					, "RESOLUTION" }		// #16
  ,{ 0																					, "TICK_SOURCE" }	// #17
  ,{ 0																					, "FREQ_HZ" }		// #18

  ,{ 0																					, "THR_L_LIM_EN" }	// #19
  ,{ 0																					, "THR_H_LIM_EN" }	// #20
  ,{ 0																					, "THR_ZERO_EN" }	// #21
  ,{ 0																					, "FILTER_EN" }		// #22
  ,{ 0																					, "FILTER_THRES" }	// #23
  ,{ 0																					, "CNT_THRES1" }	// #24
  ,{ 0																					, "CNT_THRES0" }	// #25
  ,{ 0																					, "CNT_L_LIM" }		// #26
  ,{ 0																					, "CNT_H_LIM" }		// #27

}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t ESP32_I2C_Master_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t ESP32_I2C_Master_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_Module
 *  Desc: Data 'Provided By Module' for the ESP32_I2C_Master module (functions + infos this module provides
 *        to SCDE)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
ProvidedByModule_t ESP32_I2C_Master_ProvidedByModule = {
   // A-Z order

  "ESP32_I2C_Master"			// Type-Name of module -> should be same name as libfilename.so !
  ,16					// size of Type-Name

  ,NULL					// Add

  ,ESP32_I2C_Master_Attribute		// Attribute

  ,ESP32_I2C_Master_Define		// Define

  ,NULL					// Delete

  ,NULL					// Except

  ,NULL					// Get

  ,ESP32_I2C_Master_IdleCb		// IdleCb

  ,ESP32_I2C_Master_Initialize		// Initialize

  ,NULL					// Notify

  ,NULL					// Parse

  ,NULL					// Read

  ,NULL					// Ready

  ,NULL					// Rename

  ,ESP32_I2C_Master_Set			// Set

  ,ESP32_I2C_Master_Shutdown		// Shutdown

  ,NULL					// State

  ,NULL					// Sub

  ,ESP32_I2C_Master_Undefine		// Undefine

  ,NULL					// DirectRead

  ,NULL					// DirectWrite

//  ,NULL		 		// FnProvided

  ,sizeof(ESP32_I2C_Master_Definition_t)	// Size of modul specific definition structure (Common_Definition_t + X)

};








/* @brief test code to write esp-i2c-slave
 *
 * 1. set mode
 * _________________________________________________________________
 * | start | slave_addr + wr_bit + ack | write 1 byte + ack  | stop |
 * --------|---------------------------|---------------------|------|
 * 2. wait more than 24 ms
 * 3. read data
 * ______________________________________________________________________________________
 * | start | slave_addr + rd_bit + ack | read 1 byte + ack  | read 1 byte + nack | stop |
 * --------|---------------------------|--------------------|--------------------|------|
 */
/*
esp_err_t i2c_master_sensor_test(i2c_port_t i2c_num, uint8_t* data_h, uint8_t* data_l)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
    i2c_master_stop(cmd);


  // part in I.O. Device
    int ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ret;
    }


    vTaskDelay(30 / portTICK_RATE_MS);

    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd, data_h, ACK_VAL);
    i2c_master_read_byte(cmd, data_l, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ESP_FAIL;
    }
    return ESP_OK;
}
*/














/* -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Attribute
 *  Desc: Informs an Definition of this Type for attribute activities (set/del)
 *  Info: 'attrCmd' is the command text for the activity: set, del
 *        'attrName' is the attribute name text
 *        'attrVal' is the attribute value text
 *        THE attrVal CAN BE MANIPULATED / CORRECTED
 *  Para: Common_Definition_t *Common_Definition -> the belonging definition for the attribute-activitie
 *	  const uint8_t *attrCmdText -> ptr to attribute-command text "attrCmd"
 *	  const size_t attrCmdTextLen -> length of attribute-command text "attrCmd"
 *	  const uint8_t *attrNameText -> ptr to attribute-name text "attrName"
 *	  const size_t attrNameTextLen -> length of attribute-name text "attrName"
 *	  uint8_t **attrValTextPtr -> ptr to ptr holding attribute-value text "attrValue" - manipulation possible
 *	  size_t *attrValLenTextPtr -> ptr to length of attribute-value text "attrValue" - manipulation possible
 *  Rets: strTextMultiple_t* -> veto = error-text-string in allocated mem, or NULL = OK - no veto
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Attribute(Common_Definition_t *Common_Definition
		,const uint8_t *attrCmdText
		,const size_t attrCmdTextLen
		,const uint8_t *attrNameText
		,const size_t attrNameTextLen
		,uint8_t **attrValTextPtr
		,size_t *attrValTextLenPtr)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  uint8_t *attrValText = *attrValTextPtr;
  size_t attrValTextLen = *attrValTextLenPtr;

  printf("ESP32_I2C_Master_AttributeFN for defName:%.*s -> attrCmd:%.*s attrName:%.*s attrVal:%.*s\n"
	,Common_Definition->nameLen
	,Common_Definition->name
	,attrCmdTextLen
	,attrCmdText
  	,attrNameTextLen
	,attrNameText
	,(int) attrValTextLen
	,attrValText);



/*
  // set start of possible def-Name
  const uint8_t *defName = args;

  // set start of possible attr-Name
  const uint8_t *attrName = args;

  // a seek-counter

  int i = 0;

  // seek to next space !'\32'
  while( (i < argsLen) && (*attrName != ' ') ) {i++;attrName++;}

  // length of def-Name
  size_t defNameLen = i;

  // seek to start position of attr-Name '\32'
  while( (i < argsLen) && (*attrName == ' ') ) {i++;attrName++;}

  // set start of possible attr-Val
  const uint8_t *attrVal = attrName;

  // a 2nd seek-counter
  int j = 0;

  // seek to next space !'\32'
  while( (i < argsLen) && (*attrVal != ' ') ) {i++,j++;attrVal++;}

  // length of attr-Name
  size_t attrNameLen = j;

  // start position of attr-Val
  while( (i < argsLen) && (*attrVal == ' ') ) {i++;attrVal++;}


  // length of attr-Val
  size_t attrValLen = argsLen - i;

  // veryfy lengths > 0, definition 0 allowed
  if ( (defNameLen == 0) || (attrNameLen == 0) )

		{

		// response with error text
		asprintf(&retMsg
				,"Could not interpret command ''! Usage: Attr <defname> <attrname> [<attrval>]");

		return retMsg;

	//	}

// -------------------------------------------------------------------------------------------------
*/

  return retMsg;

}








#include "freertos/ringbuf.h"


#include "soc/i2c_struct.h"
#include "soc/i2c_reg.h"
#include "driver/periph_ctrl.h"

static const char* I2C_TAG = "i2c";

#define I2C_CHECK(a, str, ret)  if(!(a)) {                                             \
        ESP_LOGE(I2C_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);      \
        return (ret);                                                                   \
        }






static portMUX_TYPE i2c_spinlock[I2C_NUM_MAX] = {portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED};

/* DRAM_ATTR is required to avoid I2C array placed in flash, due to accessed from ISR */
static DRAM_ATTR i2c_dev_t* const I2C[I2C_NUM_MAX] = { &I2C0, &I2C1 };



#define I2C_ENTER_CRITICAL_ISR(mux)    portENTER_CRITICAL_ISR(mux)
#define I2C_EXIT_CRITICAL_ISR(mux)     portEXIT_CRITICAL_ISR(mux)
#define I2C_ENTER_CRITICAL(mux)    portENTER_CRITICAL(mux)
#define I2C_EXIT_CRITICAL(mux)     portEXIT_CRITICAL(mux)

#define I2C_DRIVER_ERR_STR             "i2c driver install error"
#define I2C_DRIVER_MALLOC_ERR_STR      "i2c driver malloc error"
#define I2C_NUM_ERROR_STR              "i2c number error"
#define I2C_ADDR_ERROR_STR             "i2c null address error"
#define I2C_DRIVER_NOT_INSTALL_ERR_STR "i2c driver not installed"
#define I2C_SLAVE_BUFFER_LEN_ERR_STR   "i2c buffer size too short for slave mode"
#define I2C_EVT_QUEUE_ERR_STR          "i2c evt queue error"
#define I2C_SEM_ERR_STR                "i2c semaphore error"
#define I2C_BUF_ERR_STR                "i2c ringbuffer error"
#define I2C_MASTER_MODE_ERR_STR        "Only allowed in master mode"
#define I2C_MODE_SLAVE_ERR_STR         "Only allowed in slave mode"
#define I2C_CMD_MALLOC_ERR_STR         "i2c command link malloc error"
#define I2C_TRANS_MODE_ERR_STR         "i2c trans mode error"
#define I2C_MODE_ERR_STR               "i2c mode error"
#define I2C_SDA_IO_ERR_STR              "sda gpio number error"
#define I2C_SCL_IO_ERR_STR              "scl gpio number error"
#define I2C_CMD_LINK_INIT_ERR_STR       "i2c command link error"
#define I2C_GPIO_PULLUP_ERR_STR         "this i2c pin do not support internal pull-up"

#define I2C_FIFO_FULL_THRESH_VAL   (28)
#define I2C_FIFO_EMPTY_THRESH_VAL  (5)
#define I2C_IO_INIT_LEVEL          (1)


static void i2c_isr_handler_default(void* arg);
static void IRAM_ATTR i2c_master_cmd_begin_static(i2c_obj_t* p_i2c);





























/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Define
 *  Desc: Finalizes the defines a new "device" of 'ESP32_S0' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR 
ESP32_I2C_Master_Define(Common_Definition_t *Common_Definition)
//	,uint8_t *defArgsText
//	,size_t defArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // for parsing input args
  parsedKVInputArgs_t *parsedKVInput = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) Common_Definition;

  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  #if ESP32_I2C_Master_DBG >= 5
  printf("\n|ESP32_I2C_Master_Def, Name:%.*s, got args:%.*s>"
    ,ESP32_I2C_Master_Definition->common.nameLen
    ,ESP32_I2C_Master_Definition->common.name
    ,defArgsTextLen
    ,defArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

    // alloc mem for retMsg
    retMsg = malloc(sizeof(strTextMultiple_t));

    // response with error text
    retMsg->strTextLen = asprintf(&retMsg->strText
      ,"Parsing Error! Expected Args!");

    goto err;

  }

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  ESP32_I2C_Master_Definition->common.fd = -1;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  ESP32_I2C_Master_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (ESP32_I2C_Master_Definition->WebIf_Provided.WebIf_FnProvided) {

	ESP32_I2C_Master_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &ESP32_I2C_Master_ActiveResourcesDataA_forWebIf;

	ESP32_I2C_Master_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &ESP32_I2C_Master_ActiveResourcesDataB_forWebIf;

	}

  else	{

	SCDEFn->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,ESP32_I2C_Master_Definition->common.nameLen
		,ESP32_I2C_Master_Definition->common.name
		,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeNameLen
		,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeName);
	}

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInput = 
    SCDEFn->ParseKVInputArgsFn(ESP32_I2C_Master_SET_IK_Number_of_keys	// Num Implementated KEYs MAX
    ,ESP32_I2C_Master_Set_ImplementedKeys				// Implementated Keys
    ,defArgsText							// our args text
    ,defArgsTextLen);							// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

    // alloc mem for retMsg
    retMsg = malloc(sizeof(strTextMultiple_t));

    // response with error text
    retMsg->strTextLen = asprintf(&retMsg->strText
      ,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
      ,defArgsTextLen
      ,defArgsText);

    goto err;
  }

// ------------------------------------------------------------------------------------------------









  #if ESP32_I2C_Master_DBG >= 5
  printf("|ESP32_I2C_Master_Define, installing i2c driver>");
  #endif

#define I2C_MASTER_NUM I2C_NUM_1   /*!< I2C port number for master dev */
#define I2C_MASTER_SDA_IO    18    /*!< gpio number for I2C master data  */
#define I2C_MASTER_SCL_IO    19    /*!< gpio number for I2C master clock */
#define I2C_MASTER_TX_BUF_DISABLE   0   /*!< I2C master do not need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0   /*!< I2C master do not need buffer */
#define I2C_MASTER_FREQ_HZ    100000     /*!< I2C master clock frequency */


//Temp fill of struct

    ESP32_I2C_Master_Definition->i2c_master_port =
	I2C_MASTER_NUM;
    ESP32_I2C_Master_Definition->i2c_config.mode =
	I2C_MODE_MASTER;
    ESP32_I2C_Master_Definition->i2c_config.sda_io_num =
	I2C_MASTER_SDA_IO;
    ESP32_I2C_Master_Definition->i2c_config.sda_pullup_en =
	GPIO_PULLUP_ENABLE;
    ESP32_I2C_Master_Definition->i2c_config.scl_io_num =
	I2C_MASTER_SCL_IO;
    ESP32_I2C_Master_Definition->i2c_config.scl_pullup_en =
	GPIO_PULLUP_ENABLE;
    ESP32_I2C_Master_Definition->i2c_config.master.clk_speed =
	I2C_MASTER_FREQ_HZ;


  // ??

  i2c_param_config(ESP32_I2C_Master_Definition->i2c_master_port
	,&ESP32_I2C_Master_Definition->i2c_config);


/*
  // install the I2C driver

  i2c_driver_install(ESP32_I2C_Master_Definition->i2c_master_port

	,ESP32_I2C_Master_Definition->i2c_config.mode

	,I2C_MASTER_RX_BUF_DISABLE

	,I2C_MASTER_TX_BUF_DISABLE

	,0);


*/














/*
    For i2c master mode, we don't need to use a buffer for the data, the APIs will execute the master commands
and return after all of the commands have been sent out or when error occurs. So when we send master commands,
we should free or modify the source data only after the i2c_master_cmd_begin function returns.
    For i2c slave mode, we need a data buffer to stash the sending and receiving data, because the hardware fifo
has only 32 bytes.
*/

/*
esp_err_t i2c_driver_install(i2c_port_t i2c_num, i2c_mode_t mode, size_t slv_rx_buf_len, size_t slv_tx_buf_len,
    int intr_alloc_flags)
{
    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(mode == I2C_MODE_MASTER || ( slv_rx_buf_len > 100 || slv_tx_buf_len > 100 ), I2C_SLAVE_BUFFER_LEN_ERR_STR,
        ESP_ERR_INVALID_ARG);
*/

//xxxxxxxxxxxxx entry

  // check:
  // mode			-> I2C_MODE_MASTER or I2C_MODE_SLAVE
  // i2c_num < I2C_NUM_MAX	-> 0-1
  // slv_rx_buf_len > 100	-> 0-100
  // slv_tx_buf_len > 100	-> 0-100



i2c_port_t i2c_num = I2C_NUM_1;//0;
i2c_mode_t mode = I2C_MODE_MASTER;
size_t slv_rx_buf_len = I2C_MASTER_RX_BUF_DISABLE;
size_t slv_tx_buf_len = I2C_MASTER_TX_BUF_DISABLE;
int intr_alloc_flags = 0;





  // do init 
  uint32_t intr_mask = 0;

  i2c_obj_t* p_i2c = &ESP32_I2C_Master_Definition->i2c_obj;

  p_i2c->i2c_num = i2c_num;
  p_i2c->mode = mode;
  p_i2c->cmd_idx = 0;
  p_i2c->rx_cnt = 0;
  p_i2c->status = I2C_STATUS_IDLE;

  p_i2c->rx_fifo_remain = I2C_FIFO_LEN;
  p_i2c->tx_fifo_remain = I2C_FIFO_LEN;

  // prepare the ringbuffer - we use ringbuffers only in slave mode
  if (mode == I2C_MODE_SLAVE) {

    // prepare the requested RX buf length, > 0
    if (slv_rx_buf_len > 0) {
 
      p_i2c->rx_ring_buf = xRingbufferCreate(slv_rx_buf_len, RINGBUF_TYPE_BYTEBUF);

      // we got the buffer?
      if (p_i2c->rx_ring_buf == NULL) {
        ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);
        goto err;
      }

      p_i2c->rx_buf_length = slv_rx_buf_len;

    }

    // prepare the requested RX buf length, its 0!
    else {

      p_i2c->rx_ring_buf = NULL;

      p_i2c->rx_buf_length = 0;

    }

    // prepare the requested TX buf length, > 0
    if (slv_tx_buf_len > 0) {

      p_i2c->tx_ring_buf = xRingbufferCreate(slv_tx_buf_len, RINGBUF_TYPE_BYTEBUF);

      // we got the buffer?
      if (p_i2c->tx_ring_buf == NULL) {
        ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);
        goto err;

      }

      p_i2c->tx_buf_length = slv_tx_buf_len;

    }

    // prepare the requested TX buf length, its 0!
    else {

      p_i2c->tx_ring_buf = NULL;

      p_i2c->tx_buf_length = 0;

    }

    p_i2c->slv_rx_mux = xSemaphoreCreateMutex();
    p_i2c->slv_tx_mux = xSemaphoreCreateMutex();

    // we got the semaphores?
    if (p_i2c->slv_rx_mux == NULL || p_i2c->slv_rx_mux == NULL) {
      ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);
      goto err;

    }

    intr_mask |= ( I2C_RXFIFO_FULL_INT_ENA_M | I2C_TRANS_COMPLETE_INT_ENA_M );
  }

  // else prepare for master mode..
  else {

    //semaphore to sync sending process, because we only have 32 bytes for hardware fifo.
    p_i2c->cmd_sem = xSemaphoreCreateBinary();
    p_i2c->cmd_mux = xSemaphoreCreateMutex();

    // we got the semaphores?
    if (p_i2c->cmd_sem == NULL || p_i2c->cmd_mux == NULL) {
      ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);
      goto err;
    }

    // init command link
    p_i2c->cmd_link.cur = NULL;
    p_i2c->cmd_link.head = NULL;
    p_i2c->cmd_link.free = NULL;

    p_i2c->tx_ring_buf = NULL;
    p_i2c->rx_buf_length = 0;
    p_i2c->tx_ring_buf = NULL;
    p_i2c->tx_buf_length = 0;

  }

//  else {
//    ESP_LOGE(I2C_TAG, I2C_DRIVER_ERR_STR);
//    return ESP_FAIL;
//  }

  // hook isr handler
  i2c_isr_register(i2c_num
    ,i2c_isr_handler_default
    ,p_i2c //ESP32_I2C_Master_Definition //p_i2c_obj[i2c_num]
    ,intr_alloc_flags
    ,&p_i2c->intr_handle); // &p_i2c_obj[i2c_num]->intr_handle); //ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition

  intr_mask |= ( I2C_TRANS_COMPLETE_INT_ENA_M |
                 I2C_TRANS_START_INT_ENA_M |
                 I2C_ARBITRATION_LOST_INT_ENA_M |
                 I2C_ACK_ERR_INT_ENA_M |
                 I2C_RXFIFO_OVF_INT_ENA_M |
                 I2C_SLAVE_TRAN_COMP_INT_ENA_M );

  SET_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

/*
  return ESP_OK;
*/






/*
esp_err_t i2c_driver_delete(i2c_port_t i2c_num)
{
    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(p_i2c_obj[i2c_num] != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);

    i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

    uint32_t intr_mask = I2C_MASTER_TRAN_COMP_INT_ENA_M |
                         I2C_TIME_OUT_INT_ENA_M |
                         I2C_TRANS_COMPLETE_INT_ENA_M |
                         I2C_TRANS_START_INT_ENA_M |
                         I2C_TX_SEND_EMPTY_INT_ENA_M |
                         I2C_ARBITRATION_LOST_INT_ENA_M |
                         I2C_ACK_ERR_INT_ENA_M |
                         I2C_RXFIFO_OVF_INT_ENA_M |
                         I2C_RX_REC_FULL_INT_ENA_M |
                         I2C_SLAVE_TRAN_COMP_INT_ENA_M;
    CLEAR_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);
    esp_intr_free(p_i2c->intr_handle);
    p_i2c->intr_handle = NULL;

    if (p_i2c->cmd_mux) {
        xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);
        vSemaphoreDelete(p_i2c->cmd_mux);
    }
    if (p_i2c->cmd_sem) {
        vSemaphoreDelete(p_i2c->cmd_sem);
    }
    if (p_i2c->slv_rx_mux) {
        vSemaphoreDelete(p_i2c->slv_rx_mux);
    }
    if (p_i2c->slv_tx_mux) {
        vSemaphoreDelete(p_i2c->slv_tx_mux);
    }

    if (p_i2c->rx_ring_buf) {
        vRingbufferDelete(p_i2c->rx_ring_buf);
        p_i2c->rx_ring_buf = NULL;
        p_i2c->rx_buf_length = 0;
    }
    if (p_i2c->tx_ring_buf) {
        vRingbufferDelete(p_i2c->tx_ring_buf);
        p_i2c->tx_ring_buf = NULL;
        p_i2c->tx_buf_length = 0;
    }

    free(p_i2c_obj[i2c_num]);
    p_i2c_obj[i2c_num] = NULL;
    return ESP_OK;
}

*/




































#define DATA_LENGTH          512  /*!<Data buffer length for test buffer*/
#define RW_TEST_LENGTH       129  /*!<Data length for r/w test, any value from 0-DATA_LENGTH*/
#define DELAY_TIME_BETWEEN_ITEMS_MS   1234 /*!< delay time between different test items */


#define BH1750_SENSOR_ADDR  0x23    /*!< slave address for BH1750 sensor */
#define BH1750_CMD_START    0x23    /*!< Command to set measure mode */
#define ESP_SLAVE_ADDR 0x28         /*!< ESP32 slave address, you can set any 7bit value */
#define WRITE_BIT  I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT   I2C_MASTER_READ  /*!< I2C master read */
#define ACK_CHECK_EN   0x1     /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS  0x0     /*!< I2C master will not check ack from slave */
#define ACK_VAL    0x0         /*!< I2C ack value */
#define NACK_VAL   0x1         /*!< I2C nack value */












  #if ESP32_I2C_Master_DBG >= 5
  printf("|ESP32_I2C_Master_Define, installed i2c driver>");
  #endif






    int i = 0;
    int ret;
 //   uint32_t task_idx = (uint32_t) arg;
    uint8_t* data = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t* data_wr = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t* data_rd = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t sensor_data_h = 0;
	uint8_t sensor_data_l = 0;

 //   while (1) {
//        ret = i2c_master_sensor_test( I2C_MASTER_NUM, &sensor_data_h, &sensor_data_l);

    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(&ESP32_I2C_Master_Definition->i2c_obj, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);

    if (ret == ESP_FAIL) {
       // return ret;
    }

    else {
    vTaskDelay(30 / portTICK_RATE_MS);

    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd, &sensor_data_h, ACK_VAL);
    i2c_master_read_byte(cmd, &sensor_data_l, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(&ESP32_I2C_Master_Definition->i2c_obj, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
     //   return ESP_FAIL;
    }
    else {
    ret = ESP_OK;
    }

}

   vTaskDelay(200 / portTICK_RATE_MS);

 //       xSemaphoreTake(print_mux, portMAX_DELAY);
        printf("*******************\n");
        printf("MASTER READ SENSOR( BH1750 )\n");
        printf("*******************\n");
        if (ret == ESP_OK) {
            printf("data_h: %02x\n", sensor_data_h);
            printf("data_l: %02x\n", sensor_data_l);
            printf("sensor val: %f\n", ( sensor_data_h << 8 | sensor_data_l ) / 1.2);
        } else {
            printf("No ack, sensor not connected...skip...\n");
        }






















// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_I2C_Master_SET_GPIO)
			        | (1 << ESP32_I2C_Master_SET_BLOCK)
			        | (1 << ESP32_I2C_Master_SET_CHANNEL)
			        | (1 << ESP32_I2C_Master_SET_TIMER)
			        | (1 << ESP32_I2C_Master_SET_DUTY)
			        | (1 << ESP32_I2C_Master_SET_HPOINT)
			        | (1 << ESP32_I2C_Master_SET_SIG_OUT_EN)
			        | (1 << ESP32_I2C_Master_SET_IDLE_LV)
			        | (1 << ESP32_I2C_Master_SET_RESOLUTION)
			        | (1 << ESP32_I2C_Master_SET_TICK_SOURCE)
			        | (1 << ESP32_I2C_Master_SET_FREQ_HZ) );

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition
	,parsedKVInput				// KVInput parsed
	,defArgsText				// our args text
	,defArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,defArgsTextLen
		,defArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition
	,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);


// ------------------------------------------------------------------------------------------------

  // set up 1st idle Callback
  ESP32_I2C_Master_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

// alternative end in case of errors - free/destroy all allocated things and return SCDE_FAIL.
  err:

  if (parsedKVInput) {

    free(parsedKVInput);

  }

  if (p_i2c->rx_ring_buf) {

    vRingbufferDelete(p_i2c->rx_ring_buf);
    p_i2c->rx_ring_buf = NULL;
    p_i2c->rx_buf_length = 0;

  }

  if (p_i2c->tx_ring_buf) {

    vRingbufferDelete(p_i2c->tx_ring_buf);
    p_i2c->tx_ring_buf = NULL;
    p_i2c->tx_buf_length = 0;

  }

  if (p_i2c->cmd_sem) {

    vSemaphoreDelete(p_i2c->cmd_sem);

  }

  if (p_i2c->cmd_mux) {

    vSemaphoreDelete(p_i2c->cmd_mux);

  }

  if (p_i2c->slv_rx_mux) {

    vSemaphoreDelete(p_i2c->slv_rx_mux);

  }

  if (p_i2c->slv_tx_mux) {

    vSemaphoreDelete(p_i2c->slv_tx_mux);
  }

  return retMsg;
}



/*
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int //feedModuleTask
ESP32_I2C_Master_IdleCb(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_DBG >= 5
  printf("\n|ESP32_I2C_Master_IdleCb, Def:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------


/*
  // build pointer to make the hardware counter accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_I2C_Master_Definition->Channel));

  // access low speed channels (instead of high speed channels)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);


  // build pointer to make the hardware timer accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_I2C_Master_Definition->Timer));

  // access low speed timers (instead of high speed timers)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
*/
/*
  printf("|STATUS: A:%u, B:%u>"
	,pPWM_Timer->LEDC_HSTIMER_CNT
	,pPWM_Channel->DUTY_CYCLEX);
*/

/*
  // build ptr to access hw-counter
  ESP32_I2C_Master_CNT_CNT_REG_t *pESP32_I2C_Master_CNT_CNT_REG =
	(ESP32_I2C_Master_CNT_CNT_REG_t*) 0x3FF57060;

  printf("|STATUS: Using ctr-unit:%u, old HW-Ctr:%d, new ATT:%u, gpio:%u>"
	,ESP32_I2C_Master_Definition->counterUnit
	,pESP32_I2C_Master_CNT_CNT_REG[ESP32_I2C_Master_Definition->counterUnit].CNT_PULS_CNT
	,ESP32_I2C_Master_Definition->ATTShiftBuf[0]
	,gpio_get_level(22) ); //=att ?


  ESP32_I2C_Master_CNT_CONF_REG_t *pESP32_I2C_Master_CNT_CONF_REG = (ESP32_I2C_Master_CNT_CONF_REG_t*) 0x3FF57000;

	SCDEFn->HexDumpOutFn ("verify:"
		,&pESP32_I2C_Master_CNT_CONF_REG[0]
		, 0x80);  //sizeof(0x80) ); //ESP32_I2C_Master_CNT_CONF_REG_t) );
*/
/*
 if (WebIf_Definition->reverse) {


  // get assigned HTTPD-Connection-Slot-Data
  WebIf_HTTPDConnSlotData_t *conn
	= WebIf_Definition->reverse;

  // execute disconnection (indicated by NEEDS_CLOSE flag) or send more data ...
  if (conn->ConnCtrlFlags & F_GENERATE_IDLE_CALLBACK)

	{

	// execute Idle Callback
	WebIf_IdleCb(WebIf_Definition);

	}

}
*/


  // set up next idle Callback
  ESP32_I2C_Master_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
ESP32_I2C_Master_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn = SCDERootptr->SCDEFn;

  SCDEFn->Log3Fn(ESP32_I2C_Master_ProvidedByModule.typeName
		  ,ESP32_I2C_Master_ProvidedByModule.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,ESP32_I2C_Master_ProvidedByModule.typeNameLen
		  ,ESP32_I2C_Master_ProvidedByModule.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_DBG >= 5
  printf("\n|ESP32_I2C_Master_Set, Name:%.*s, got args:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn->ParseKVInputArgsFn(ESP32_I2C_Master_SET_IK_Number_of_keys	// Num Implementated KEYs MAX for Set Fn
	,ESP32_I2C_Master_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
//  parsedKVInput->forbiddenKVBF = ( (1 << ESP32_I2C_Master_SET_CNT_UNIT) );
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine ESP32_I2C_Master_Definition.common.Name'
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if ESP32_I2C_Master_DBG >= 5
  printf("\n|ESP32_I2C_Master_Shutdown, Name:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_DBG >= 5
  printf("\n|ESP32_I2C_Master_Undefine, Name:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);

  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"ESP32_I2C_Master_Undefine, Name:%.*s"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);

  return retMsg;

}



/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * -------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition
	,parsedKVInputArgs_t *parsedKVInput
	,uint8_t *argsText
	,size_t argsTextLen)
{

// 1. Step: Prepare structures with current values from TYPE & SYSTEM 
//          (to allow an abort if values not complete or in case of processing errors)

  // block #1 get current assigned PWM-Block (low speed / high speed)
//  uint8_t newBlock = ESP32_I2C_Master_Definition->Block;

  // block #2 get current assigned PWM Channel
//  uint8_t newChannel = ESP32_I2C_Master_Definition->Channel;

  // block #3 get current assigned PWM Timer
//  uint8_t newTimer = ESP32_I2C_Master_Definition->Timer;

// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'Block' KEY in advance here, because we need this information early

  // Block=High_Speed|Low_Speed
  // -> Setzt den Hardware-PWM-Block des ESP32 (0=HighSpeed / 1= LowSpeed) der verwendet werden soll
  // -> Sets the hardware-PWM-Block of the ESP32 (0=HighSpeed / 1= LowSpeed) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_BLOCK) ) {

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_BLOCK].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_BLOCK].len, &newBlock, ESP32_I2C_Master_PWM_BLOCK)
		&& (newBlock <= 1) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
  /*
  // we need to process the 'CHANNEL' KEY in advance here, because we need this information early

  // CHANNEL=[0-7]
  // -> Setzt den Hardware-PWM-Kanal des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware-pwm-channel of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CHANNEL) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CHANNEL].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CHANNEL].len, &newChannel) 
		&& (newChannel <= 7) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'TIMER' KEY in advance here, because we need this information early

  // TIMER=[0-3]
  // -> Setzt den Hardware-Timer für den gewählten PWM-Kanal des ESP32 (0-3) der verwendet werden soll
  // -> Sets the hardware-timer for the choosen pwm-channel of the ESP32 (0-3) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_TIMER) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_TIMER].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_TIMER].len, &newTimer) 
		&& (newTimer <= 3) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*
  // block #4 get current assigned / connected GPIO
  uint8_t newGPIO = ESP32_I2C_Master_Definition->GPIO;

  // block #5 reserve for new ATT
  uint32_t newATTVal;

  // block #6 reserve for new AVU
  char newAverageUnit[3];	

  // block #7  get ESP32 PWM channel configuration from selected channel
  // this stores our temp values
  ESP32_PWM_Channel_t newPWM_Channel;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * newChannel));
  // access low speed channels (instead of high speed channels)?
  if (newBlock) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // move data to temp storage
  memcpy(&newPWM_Channel, pPWM_Channel, sizeof(ESP32_PWM_Channel_t));

  // block #8  get ESP32 PWM timer configuration from selected timer
  // this stores our temp values
  ESP32_PWM_Timer_t newPWM_Timer;
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * newTimer));
  // access low speed timers (instead of high speed timers)?
  if (newBlock) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
  // move data to temp storage
  memcpy(&newPWM_Timer, pPWM_Timer, sizeof(ESP32_PWM_Timer_t));


  // store choosen timer in choosen channel
  newPWM_Channel.TIMER_SEL = newTimer;
*/
// ------------------------------------------------------------------------------------------------

// 2. Step: Process the possible input keys













/*
//>Caps Bit 0---------------------------------------------------------------------------------------

  // on=[ ] -> Setze Kanal an (0-x)
  // on=[ ] -> Set channel on (0-x)

 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_on)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_on].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");

	}

//--------------------------------------------------------------------------------------------------

  // off=[ ] -> Setze Kanal aus (0-x)
  // off=[ ] -> Set channel off (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_off)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_off].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=off");

	}

//>Caps Bit 1---------------------------------------------------------------------------------------

  // max=[ ] -> Setze Kanal maximal (0-x)
  // max=[ ] -> Set channel maximum (0-x) 

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_max)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_max].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=max");

	}

//--------------------------------------------------------------------------------------------------

  // min=[ ] -> Setze Kanal minimal (0-x)
  // min=[ ] -> Set channel minimal (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_min)

	{

	// New Value = Min
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_min].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=min");

	}

//>Caps Bit 2---------------------------------------------------------------------------------------

  // val=[0-9] -> Setze Wert für Kanal (uint8) (0-x)
  // val=[0-9] -> Set value for channel (uint8) (0-x)

 else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_val)
	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_val].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_val].len, &NewVal))

		{

		// val input value clipping
		if (NewVal > SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax)

			{

			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax;

			}

		else if (NewVal < SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin)

			{

			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin;

			}

		// save mirror
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);

		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_val].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=val");

		}

	}

//>Caps Bit 3---------------------------------------------------------------------------------------

  // dim=[0-9] -> Setze dimmer für Kanal (uint8) (0-x)
  // dim=[0-9] -> Set dimming for channel (uint8) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_dim)
	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].len, &NewVal))
		
		{

		// dim input value clipping
		if (NewVal > 100) NewVal = 100;
		else if (NewVal < 0) NewVal = 0;

		// calculate val from dim
		NewVal = ( (NewVal *
			(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
			SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) /
			100 );

		// New Value = calculated from input
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);

		// save mirror
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=dim");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_name)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_name].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) )

		{	

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_name].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // caps=[ ] -> Fragt nach den Fähigkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)

 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_caps)

	{

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_caps].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");

	}

*/

/*
  // ATT=[0-9]
  // -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Zählerstand
  // -> Set alltime-total-tics meeting the currend meter-reading

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATT) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &newATTVal)) {





		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= newATTVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------

  // AVU=[a-zA-Z0-9_.]
  // -> Setze Einheit für den Durchschnitts-Verbrauchs-Wert (char[3])
  // -> Set unit for average-consumption-value (char[3])

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_AVU) ) {

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &newAverageUnit
		,sizeof (newAverageUnit) // -> case 3 = (Alpha+Num+"³") for Unit Name
		,3) ) {


		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 1---------------------------------------------------------------------------------------

  // AVF=[0-9.]
  // -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // -> Set average consumption calculation factor (float)

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_AVF) ) {

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal)) {

		// store the value to temp
		//befehl hier!;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");

		}

	// invalid input detected ?
	else return true;
  }

//--------------------------------------------------------------------------------------------------

  // ATU=[a-zA-Z0-9_.]
  // -> Setze Einheit für den Allzeit-Gesamt-Wert (char[3])
  // -> Set unit for alltime-total-value (char[3])

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATU) ) {

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"³") for Unit Name

		 {

		// store the value to temp
		//befehl hier!;



		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 2---------------------------------------------------------------------------------------

  // ATF=[0-9.]
  // -> Setze Umrechnungsfaktor für den Allzeit-Total-Wert (float)
  // -> Set factor for alltime total value (float)

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATF) ) {

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal)) {

		// store the value to temp
		//befehl hier!;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");

		}

	// invalid input detected ?
	else return true;
  }


*/














//> ------------------------------------------------------------------------------------------------
/*
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_LCTRL_MODE) ) {

	uint8_t newMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_I2C_Master_CTRL_MODE)
		&& (newMode <= 3) ) {

		// store the value to temp
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/





















/*

//>Caps Bit 3---------------------------------------------------------------------------------------

  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)

	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))

		{

		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");

		}

	}


//>Caps Bit n.a.------------------------------------------------------------------------------------

  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

		{	

		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // caps=[ ] -> Fragt nach den Fähigkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)


 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{

	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;

//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");

	}

*/








//> ------------------------------------------------------------------------------------------------
/*
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_LCTRL_MODE) ) {

	uint8_t newMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_I2C_Master_CTRL_MODE)
		&& (newMode <= 3) ) {

		// store the value to temp
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_HCTRL_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_HCTRL_MODE].len, &NewMode, ESP32_I2C_Master_CTRL_MODE) ) {

		// store ne value
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_POS_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_POS_MODE].len, &NewMode, ESP32_I2C_Master_CH_MODE) ) {

		// store ne value
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/









// ------------------------------------------------------------------------------------------------

// 3. Step: Check if the ammount of input elements meets our criteria

  // check if all required Key=Value components are included -> return with FALSE
  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|requiredKVBF, no match!>");	
  	#endif

	return true;
  }

  // check if forbidden Key=Value components are included -> return with FALSE
  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|forbiddenKVBF, match!>");	
  	#endif

	return true;
  }

// ------------------------------------------------------------------------------------------------

// 4. Step: Passed. Store the new values
/*
  // block #1 store assigned PWM-Block (low speed / high speed)
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_BLOCK) ) ) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif

	// store assigned PWM-Block
	ESP32_I2C_Master_Definition->Block = newBlock;
  }

  // block #2 store assigned PWM Channel
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_CHANNEL) ) ) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|W B#02 PWM_Channel=%d>"
		,newChannel);	
  	#endif

	// store assigned PWM Channel
	ESP32_I2C_Master_Definition->Channel = newChannel;
  }

  // block #3 store assigned PWM Timer
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_TIMER) ) ) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|W B#03 PWM_Timer=%d>"
		,newTimer);	
  	#endif

	// store assigned PWM Timer
	ESP32_I2C_Master_Definition->Timer = newTimer;
  }

  // block #4 store assigned / connected GPIO
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_GPIO) ) ) {

	#if ESP32_I2C_Master_DBG >= 5
	printf("|W B#04 PWM_GPIO=%d>"
		,newGPIO);	
  	#endif

	// store assigned GPIO
	ESP32_I2C_Master_Definition->GPIO = newGPIO;

	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newGPIO], PIN_FUNC_GPIO);

	// set GPIO as output
	gpio_set_direction(newGPIO, GPIO_MODE_OUTPUT);

	// configure for high-speed or low-speed ?
	if (newBlock) {

		// setup gpio matrix for low speed
	}

	else {

		// setup gpio matrix for high speed
		gpio_matrix_out(newGPIO, LEDC_HS_SIG_OUT0_IDX + newChannel, 0, 0);
		
	}
  }

  // block #5 store ESP32 pwm configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_I2C_Master_SET_TIMER)
				   | (1 << ESP32_I2C_Master_SET_SIG_OUT_EN)
				   | (1 << ESP32_I2C_Master_SET_IDLE_LV)
				   | (1 << ESP32_I2C_Master_SET_HPOINT)
				   | (1 << ESP32_I2C_Master_SET_DUTY) ) ) {





	// store ESP32 PWM configuration registers
	memcpy(pPWM_Channel, &newPWM_Channel, sizeof(ESP32_PWM_Channel_t));

	# if ESP32_I2C_Master_DBG >= 5
	printf("|ESP32_PWM_Channel_s addr=%p>"
		,pPWM_Channel);

	SCDEFn->HexDumpOutFn ("dump"
		,pPWM_Channel
		, sizeof(ESP32_PWM_Channel_t) );
	# endif
  }

  // block #6 store ESP32 pwm-timer configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_I2C_Master_SET_TIMER)
				   | (1 << ESP32_I2C_Master_SET_RESOLUTION )
				   | (1 << ESP32_I2C_Master_SET_TICK_SOURCE)
			   	   | (1 << ESP32_I2C_Master_SET_FREQ_HZ) ) ) {

	// reset? It seems that a reset is needed to start timer
	newPWM_Timer.RESET = 0;

	// low speed timer? -> needs 'LOW_SPEED_UPDATE' bit set to take settings
	if (!newBlock) newPWM_Timer.LOW_SPEED_UPDATE = 1;

	// store ESP32 timer configuration registers
	memcpy(pPWM_Timer, &newPWM_Timer, sizeof(ESP32_PWM_Timer_t));

	# if ESP32_I2C_Master_DBG >= 5
	printf("|ESP32_PWM_Timer_s addr=%p>"
		,pPWM_Timer);

	SCDEFn->HexDumpOutFn ("dump"
		,pPWM_Timer
		, sizeof(ESP32_PWM_Timer_t) );
	# endif
  }
*/
  return false;

}

















/*
//>Add Readings Bit 00 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_val)

	{

	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&val=%u",(uint) SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val);

	}

//>Add Readings Bit 01 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_dim)

	{

	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&dim=%u",(100 *
		(SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val -
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) / 
		(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) );

	}

//>Add Readings Bit 02 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_name)

	{

	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += SwITCH_UFID(RespArgsWPos, ADID);


	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=000F");						// 0b1111 <-16BIT-HEX

	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name);

	}

//>always add Reading - state ----------------------------------------------------------------------

	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");

	// always add state ! on / off
	if (SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val == 0)
		RespArgsWPos += os_sprintf(RespArgsWPos, "state=off");

	else  RespArgsWPos += os_sprintf(RespArgsWPos, "state=on");

//--------------------------------------------------------------------------------------------------

*/
















/**
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition
	,uint64_t affectedReadings)
{
/*
 affectedReadings = 0xfffffffffffffff;

  // do we have updates?
  if (affectedReadings) {

  SCDEFn->readingsBeginUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition);

  }

  // we have no updates
  else return false;

// -----------------------------------------------------------------------------------------------

  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;

  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_I2C_Master_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);

  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_I2C_Master_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);

//>Add Readings Bit 00 -----------------------------------------------------------------------------

  // add reading 'Duty'
  if (affectedReadings & ESP32_I2C_Master_R_DUTY) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Duty");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,pPWM_Channel->DUTY);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }

//>Add Readings Bit 01 -----------------------------------------------------------------------------

  // add reading 'Resolution'
  if (affectedReadings & ESP32_I2C_Master_R_RESOLUTION) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Resolution");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,(1 << pPWM_Timer->RESOLUTION) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_I2C_Master_R_AV01_AV05_AV15) {

	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...

	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );

		}

	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );

		}

	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	

		}

	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Factor' //avf'
  if (affectedReadings & ESP32_I2C_Master_R_AVF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) ESP32_I2C_Master_Definition->IB01_AverageFactor	
		,(int) ( (ESP32_I2C_Master_Definition->IB01_AverageFactor -
		(int) ESP32_I2C_Master_Definition->IB01_AverageFactor) * 10000) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Unit' //avu'
  if (affectedReadings & ESP32_I2C_Master_R_AVU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_I2C_Master_Definition->IB01_AverageUnit);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & ESP32_I2C_Master_R_ATF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor -
		(int) ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor) * 10000) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & ESP32_I2C_Master_R_ATU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_I2C_Master_Definition->IB01_AlltimeTotalUnit);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------
/*
  // add reading 'Debounce' //deb'
  if (affectedReadings & ESP32_I2C_Master_R_DEB) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_I2C_Master_Definition->IB01_Debounce);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_I2C_Master_R_name)
	{

	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);

	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX

	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);

	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");

	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
//  SCDEFn->readingsEndUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition);


  return true;
}














static void i2c_isr_handler_default(void* arg)
{
/*  // we got ptr to ESP32_I2C_Master_Definition_t
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) arg;

  // create ptr to i2c_obj_t
  i2c_obj_t* p_i2c = &ESP32_I2C_Master_Definition->i2c_obj;
*/

  i2c_obj_t* p_i2c = (i2c_obj_t*) arg;

  int i2c_num = p_i2c->i2c_num;
  uint32_t status = I2C[i2c_num]->int_status.val;
  int idx = 0;
  portBASE_TYPE HPTaskAwoken = pdFALSE;

  while (status != 0) {

    status = I2C[i2c_num]->int_status.val;

    if (status & I2C_TX_SEND_EMPTY_INT_ST_M) {

      I2C[i2c_num]->int_clr.tx_send_empty = 1;

    } else if (status & I2C_RX_REC_FULL_INT_ST_M) {

      I2C[i2c_num]->int_clr.rx_rec_full = 1;

    } else if (status & I2C_ACK_ERR_INT_ST_M) {

      I2C[i2c_num]->int_clr.ack_err = 1;

      if (p_i2c->mode == I2C_MODE_MASTER) {

        p_i2c->status = I2C_STATUS_ACK_ERROR;

        I2C[i2c_num]->int_clr.ack_err = 1;

        //get error ack value from slave device, stop the commands
        i2c_master_cmd_begin_static(p_i2c);

      }

    } else if (status & I2C_TRANS_START_INT_ST_M) {

      I2C[i2c_num]->int_clr.trans_start = 1;

    } else if (status & I2C_TIME_OUT_INT_ST_M) {

      I2C[i2c_num]->int_clr.time_out = 1;

    } else if (status & I2C_TRANS_COMPLETE_INT_ST_M) {

      I2C[i2c_num]->int_clr.trans_complete = 1;

      if (p_i2c->mode == I2C_MODE_SLAVE) {

        int rx_fifo_cnt = I2C[i2c_num]->status_reg.rx_fifo_cnt;

        for (idx = 0; idx < rx_fifo_cnt; idx++) {

          p_i2c->data_buf[idx] = I2C[i2c_num]->fifo_data.data;

        }

        xRingbufferSendFromISR(p_i2c->rx_ring_buf
          ,p_i2c->data_buf
          ,rx_fifo_cnt
          ,&HPTaskAwoken);

        if (HPTaskAwoken == pdTRUE) {

          portYIELD_FROM_ISR();

        }

        I2C[i2c_num]->int_clr.rx_fifo_full = 1;

      } else {

        if (p_i2c->status != I2C_STATUS_ACK_ERROR) {

          i2c_master_cmd_begin_static(p_i2c);

        }
      }

    } else if (status & I2C_MASTER_TRAN_COMP_INT_ST_M) {

      I2C[i2c_num]->int_clr.master_tran_comp = 1;

    } else if (status & I2C_ARBITRATION_LOST_INT_ST_M) {

      I2C[i2c_num]->int_clr.arbitration_lost = 1;

    } else if (status & I2C_SLAVE_TRAN_COMP_INT_ST_M) {

      I2C[i2c_num]->int_clr.slave_tran_comp = 1;

    } else if (status & I2C_END_DETECT_INT_ST_M) {

      I2C[i2c_num]->int_ena.end_detect = 0;

      I2C[i2c_num]->int_clr.end_detect = 1;

      i2c_master_cmd_begin_static(p_i2c);

    } else if (status & I2C_RXFIFO_OVF_INT_ST_M) {

      I2C[i2c_num]->int_clr.rx_fifo_ovf = 1;

    } else if (status & I2C_TXFIFO_EMPTY_INT_ST_M) {

      int tx_fifo_rem = I2C_FIFO_LEN - 
        I2C[i2c_num]->status_reg.tx_fifo_cnt;

      size_t size = 0;

      uint8_t *data = (uint8_t*) xRingbufferReceiveUpToFromISR(p_i2c->tx_ring_buf
        ,&size
        ,tx_fifo_rem);

      if (data) {

        for (idx = 0; idx < size; idx++) {

          WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), data[idx]);

        }

        vRingbufferReturnItemFromISR(p_i2c->tx_ring_buf, data, &HPTaskAwoken);

          if (HPTaskAwoken == pdTRUE) {
            portYIELD_FROM_ISR();
          }

        I2C[i2c_num]->int_ena.tx_fifo_empty = 1;

        I2C[i2c_num]->int_clr.tx_fifo_empty = 1;

        } else {

      I2C[i2c_num]->int_ena.tx_fifo_empty = 0;

      I2C[i2c_num]->int_clr.tx_fifo_empty = 1;

    }

  } else if (status & I2C_RXFIFO_FULL_INT_ST_M) {

    int rx_fifo_cnt = I2C[i2c_num]->status_reg.rx_fifo_cnt;

    for (idx = 0; idx < rx_fifo_cnt; idx++) {

      p_i2c->data_buf[idx] = I2C[i2c_num]->fifo_data.data;

    }

    xRingbufferSendFromISR(p_i2c->rx_ring_buf, p_i2c->data_buf, rx_fifo_cnt, &HPTaskAwoken);

    if (HPTaskAwoken == pdTRUE) {

      portYIELD_FROM_ISR();

    }

    I2C[i2c_num]->int_clr.rx_fifo_full = 1;

    } else {

      I2C[i2c_num]->int_clr.val = status;

    }
  }
}




/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_isr_register
 *  Desc: Registers the Interrupt for i2c  (2 available)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_isr_register(i2c_port_t i2c_num, void (*fn)(void*), void * arg, int intr_alloc_flags, intr_handle_t *handle)
{

  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(fn != NULL, I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);

  esp_err_t ret;

  switch (i2c_num) {

    case I2C_NUM_1:
      ret = esp_intr_alloc(ETS_I2C_EXT1_INTR_SOURCE, intr_alloc_flags, fn, arg, handle);
    break;

    case I2C_NUM_0:
    default:
      ret = esp_intr_alloc(ETS_I2C_EXT0_INTR_SOURCE, intr_alloc_flags, fn, arg, handle);
    break;
  }

  return ret;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_isr_free
 *  Desc: Unregisters the Interrupt for i2c
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_isr_free(intr_handle_t handle)
{

  return esp_intr_free(handle);

}





esp_err_t i2c_param_config(i2c_port_t i2c_num, const i2c_config_t* i2c_conf)
{
    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(i2c_conf != NULL, I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(i2c_conf->mode < I2C_MODE_MAX, I2C_MODE_ERR_STR, ESP_ERR_INVALID_ARG);

    esp_err_t ret = i2c_set_pin(i2c_num, i2c_conf->sda_io_num, i2c_conf->scl_io_num,
                                i2c_conf->sda_pullup_en, i2c_conf->scl_pullup_en, i2c_conf->mode);
    if (ret != ESP_OK) {
        return ret;
    }
    if (i2c_num == I2C_NUM_0) {
        periph_module_enable(PERIPH_I2C0_MODULE);
    } else if (i2c_num == I2C_NUM_1) {
        periph_module_enable(PERIPH_I2C1_MODULE);
    }

    I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);
    I2C[i2c_num]->ctr.rx_lsb_first = I2C_DATA_MODE_MSB_FIRST; //set rx data msb first
    I2C[i2c_num]->ctr.tx_lsb_first = I2C_DATA_MODE_MSB_FIRST; //set tx data msb first
    I2C[i2c_num]->ctr.ms_mode = i2c_conf->mode; //mode for master or slave
    I2C[i2c_num]->ctr.sda_force_out = 1; // set open-drain output mode
    I2C[i2c_num]->ctr.scl_force_out = 1; // set open-drain output mode
    I2C[i2c_num]->ctr.sample_scl_level = 0; //sample at high level of clock

    if (i2c_conf->mode == I2C_MODE_SLAVE) {  //slave mode
        I2C[i2c_num]->slave_addr.addr = i2c_conf->slave.slave_addr;
        I2C[i2c_num]->slave_addr.en_10bit = i2c_conf->slave.addr_10bit_en;
        I2C[i2c_num]->fifo_conf.nonfifo_en = 0;
        I2C[i2c_num]->fifo_conf.fifo_addr_cfg_en = 0;
        I2C[i2c_num]->fifo_conf.rx_fifo_full_thrhd = I2C_FIFO_FULL_THRESH_VAL;
        I2C[i2c_num]->fifo_conf.tx_fifo_empty_thrhd = I2C_FIFO_EMPTY_THRESH_VAL;
        I2C[i2c_num]->int_ena.rx_fifo_full = 1;
        I2C[i2c_num]->ctr.trans_start = 0;
    } else {
        I2C[i2c_num]->fifo_conf.nonfifo_en = 0;
    }
    //set frequency
    int half_cycle = ( I2C_APB_CLK_FREQ / i2c_conf->master.clk_speed ) / 2;
    I2C[i2c_num]->scl_low_period.period = half_cycle - 1;
    I2C[i2c_num]->scl_high_period.period = ( I2C_APB_CLK_FREQ / i2c_conf->master.clk_speed ) - half_cycle - 1;
    //set timing for start signal
    I2C[i2c_num]->scl_start_hold.time = half_cycle;
    I2C[i2c_num]->scl_rstart_setup.time = half_cycle;
    //set timing for stop signal
    I2C[i2c_num]->scl_stop_hold.time = half_cycle;
    I2C[i2c_num]->scl_stop_setup.time = half_cycle;
    //set timing for data
    I2C[i2c_num]->sda_hold.time = half_cycle / 2;
    I2C[i2c_num]->sda_sample.time = half_cycle / 2;
    //set timeout of receving data
    I2C[i2c_num]->timeout.tout = 200000;
    I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);
    return ESP_OK;
}





/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_reset_tx_fifo
 *  Desc: Resets the hardware tx fifo
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_reset_tx_fifo(i2c_port_t i2c_num)
{

  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->fifo_conf.tx_fifo_rst = 1;

  I2C[i2c_num]->fifo_conf.tx_fifo_rst = 0;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_reset_rx_fifo
 *  Desc: Resets the hardware rx fifo 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_reset_rx_fifo(i2c_port_t i2c_num)
{

  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->fifo_conf.rx_fifo_rst = 1;

  I2C[i2c_num]->fifo_conf.rx_fifo_rst = 0;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;

}













esp_err_t i2c_set_pin(i2c_port_t i2c_num, gpio_num_t sda_io_num, gpio_num_t scl_io_num, gpio_pullup_t sda_pullup_en, gpio_pullup_t scl_pullup_en, i2c_mode_t mode)
{
    I2C_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(((GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num))), I2C_SDA_IO_ERR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
              (GPIO_IS_VALID_GPIO(scl_io_num) && mode == I2C_MODE_SLAVE),
              I2C_SCL_IO_ERR_STR,
              ESP_ERR_INVALID_ARG);
    I2C_CHECK((sda_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num)) ||
               sda_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK((scl_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
               scl_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR, ESP_ERR_INVALID_ARG);

    int sda_in_sig, sda_out_sig, scl_in_sig, scl_out_sig;
    switch (i2c_num) {
        case I2C_NUM_1:
            sda_out_sig = I2CEXT1_SDA_OUT_IDX;
            sda_in_sig = I2CEXT1_SDA_IN_IDX;
            scl_out_sig = I2CEXT1_SCL_OUT_IDX;
            scl_in_sig = I2CEXT1_SCL_IN_IDX;
            break;
        case I2C_NUM_0:
            default:
            sda_out_sig = I2CEXT0_SDA_OUT_IDX;
            sda_in_sig = I2CEXT0_SDA_IN_IDX;
            scl_out_sig = I2CEXT0_SCL_OUT_IDX;
            scl_in_sig = I2CEXT0_SCL_IN_IDX;
            break;
    }
    if (sda_io_num >= 0) {
        gpio_set_level(sda_io_num, I2C_IO_INIT_LEVEL);
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[sda_io_num], PIN_FUNC_GPIO);
        gpio_set_direction(sda_io_num, GPIO_MODE_INPUT_OUTPUT_OD);
        if (sda_pullup_en == GPIO_PULLUP_ENABLE) {
            gpio_set_pull_mode(sda_io_num, GPIO_PULLUP_ONLY);
        } else {
            gpio_set_pull_mode(sda_io_num, GPIO_FLOATING);
        }
        gpio_matrix_out(sda_io_num, sda_out_sig, 0, 0);
        gpio_matrix_in(sda_io_num, sda_in_sig, 0);
    }

    if (scl_io_num >= 0) {
        gpio_set_level(scl_io_num, I2C_IO_INIT_LEVEL);
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[scl_io_num], PIN_FUNC_GPIO);
        if (mode == I2C_MODE_MASTER) {
            gpio_set_direction(scl_io_num, GPIO_MODE_INPUT_OUTPUT_OD);
            gpio_matrix_out(scl_io_num, scl_out_sig, 0, 0);
        } else {
            gpio_set_direction(scl_io_num, GPIO_MODE_INPUT);
        }
        if (scl_pullup_en == GPIO_PULLUP_ENABLE) {
            gpio_set_pull_mode(scl_io_num, GPIO_PULLUP_ONLY);
        } else {
            gpio_set_pull_mode(scl_io_num, GPIO_FLOATING);
        }
        gpio_matrix_in(scl_io_num, scl_in_sig, 0);
    }
    return ESP_OK;
}













/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_cmd_link_create
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
i2c_cmd_handle_t i2c_cmd_link_create()
{
  i2c_cmd_desc_t* cmd_desc = (i2c_cmd_desc_t*) calloc(1, sizeof(i2c_cmd_desc_t));
  return (i2c_cmd_handle_t) cmd_desc;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_cmd_link_delete
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
void i2c_cmd_link_delete(i2c_cmd_handle_t cmd_handle)
{

  if (cmd_handle == NULL) {

    return;

  }

  i2c_cmd_desc_t* cmd = (i2c_cmd_desc_t*) cmd_handle;

  while (cmd->free) {

    i2c_cmd_link_t* ptmp = cmd->free;

    cmd->free = cmd->free->next;

    free(ptmp);

  }

  cmd->cur = NULL;
  cmd->free = NULL;
  cmd->head = NULL;

  free(cmd_handle);

  return;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_cmd_link_append
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
static esp_err_t i2c_cmd_link_append(i2c_cmd_handle_t cmd_handle, i2c_cmd_t* cmd)
{
  i2c_cmd_desc_t* cmd_desc = (i2c_cmd_desc_t*) cmd_handle;

  if (cmd_desc->head == NULL) {

    cmd_desc->head = (i2c_cmd_link_t*) malloc(sizeof(i2c_cmd_link_t));

    if (cmd_desc->head == NULL) {

      ESP_LOGE(I2C_TAG, I2C_CMD_MALLOC_ERR_STR);

      goto err;

    }

    cmd_desc->cur = cmd_desc->head;
    cmd_desc->free = cmd_desc->head;

  } else {

    cmd_desc->cur->next = (i2c_cmd_link_t*) malloc(sizeof(i2c_cmd_link_t));

    if (cmd_desc->cur->next == NULL) {

      ESP_LOGE(I2C_TAG, I2C_CMD_MALLOC_ERR_STR);

      goto err;

    }

    cmd_desc->cur = cmd_desc->cur->next;

  }

  memcpy((uint8_t*) &cmd_desc->cur->cmd, (uint8_t*) cmd, sizeof(i2c_cmd_t));

  cmd_desc->cur->next = NULL;

  return ESP_OK;

  err:

  return ESP_FAIL;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_start
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_start(i2c_cmd_handle_t cmd_handle)
{

  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 0;
  cmd.data = NULL;
  cmd.op_code = I2C_CMD_RESTART;

  return i2c_cmd_link_append(cmd_handle, &cmd);

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_stop
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_stop(i2c_cmd_handle_t cmd_handle)
{

  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 0;
  cmd.data = NULL;
  cmd.op_code = I2C_CMD_STOP;

  return i2c_cmd_link_append(cmd_handle, &cmd);

}


/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_write
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_write(i2c_cmd_handle_t cmd_handle, uint8_t* data, size_t data_len, bool ack_en)
{

  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  uint8_t len_tmp;
  int data_offset = 0;

  esp_err_t ret;

  while (data_len > 0) {

    len_tmp = data_len > 0xff ? 0xff : data_len;
    data_len -= len_tmp;

    i2c_cmd_t cmd;

    cmd.ack_en = ack_en;
    cmd.ack_exp = 0;
    cmd.ack_val = 0;
    cmd.byte_num = len_tmp;
    cmd.op_code = I2C_CMD_WRITE;
    cmd.data = data + data_offset;

    ret = i2c_cmd_link_append(cmd_handle, &cmd);

    data_offset += len_tmp;

    if (ret != ESP_OK) {

      return ret;

    }
  }

  return ESP_OK;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_write_byte
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_write_byte(i2c_cmd_handle_t cmd_handle, uint8_t data, bool ack_en)
{

  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = ack_en;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 1;
  cmd.op_code = I2C_CMD_WRITE;
  cmd.data = NULL;
  cmd.byte_cmd = data;

  return i2c_cmd_link_append(cmd_handle, &cmd);

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_read
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_read(i2c_cmd_handle_t cmd_handle, uint8_t* data, size_t data_len, int ack)
{
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  int len_tmp;
  int data_offset = 0;
  esp_err_t ret;

  while (data_len > 0) {

    len_tmp = data_len > 0xff ? 0xff : data_len;
    data_len -= len_tmp;

    i2c_cmd_t cmd;

    cmd.ack_en = 0;
    cmd.ack_exp = 0;
    cmd.ack_val = ack & 0x1;
    cmd.byte_num = len_tmp;
    cmd.op_code = I2C_CMD_READ;
    cmd.data = data + data_offset;

    ret = i2c_cmd_link_append(cmd_handle, &cmd);

    data_offset += len_tmp;

    if (ret != ESP_OK) {

      return ret;

    }
  }

  return ESP_OK;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_read_byte
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t i2c_master_read_byte(i2c_cmd_handle_t cmd_handle, uint8_t* data, int ack)
{
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = ack & 0x1;
  cmd.byte_num = 1;
  cmd.op_code = I2C_CMD_READ;
  cmd.data = data;

  return i2c_cmd_link_append(cmd_handle, &cmd);

}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_cmd_begin_static
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
static void IRAM_ATTR i2c_master_cmd_begin_static(i2c_obj_t* p_i2c) //i2c_port_t i2c_num)
{

//  i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];
  int i2c_num = p_i2c->i2c_num;

  portBASE_TYPE HPTaskAwoken = pdFALSE;

  //This should never happen
  if (p_i2c->mode == I2C_MODE_SLAVE) {

        return;

  }

  if (p_i2c->status == I2C_STATUS_DONE) {

    return;

  } else if (p_i2c->status == I2C_STATUS_ACK_ERROR) {

    I2C[i2c_num]->int_ena.end_detect = 0;
    I2C[i2c_num]->int_clr.end_detect = 1;
    I2C[i2c_num]->int_ena.master_tran_comp = 0;
    xSemaphoreGiveFromISR(p_i2c->cmd_sem, &HPTaskAwoken);

    if (HPTaskAwoken == pdTRUE) {

      portYIELD_FROM_ISR();

    }

    return;

  } else if (p_i2c->status == I2C_STATUS_READ) {

    i2c_cmd_t *cmd = &p_i2c->cmd_link.head->cmd;

    while (p_i2c->rx_cnt-- > 0) {

      *cmd->data++ = READ_PERI_REG(I2C_DATA_APB_REG(i2c_num));

    }

    if (cmd->byte_num > 0) {

      p_i2c->rx_fifo_remain = I2C_FIFO_LEN;

      p_i2c->cmd_idx = 0;

    } else {

      p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;

    }

  }

  if (p_i2c->cmd_link.head == NULL) {

    p_i2c->cmd_link.cur = NULL;

    xSemaphoreGiveFromISR(p_i2c->cmd_sem, &HPTaskAwoken);

    if (HPTaskAwoken == pdTRUE) {

      portYIELD_FROM_ISR();

    }

    return;

  }

  while (p_i2c->cmd_link.head) {

    i2c_cmd_t *cmd = &p_i2c->cmd_link.head->cmd;

    I2C[i2c_num]->command[p_i2c->cmd_idx].val = 0;
    I2C[i2c_num]->command[p_i2c->cmd_idx].ack_en = cmd->ack_en;
    I2C[i2c_num]->command[p_i2c->cmd_idx].ack_exp = cmd->ack_exp;
    I2C[i2c_num]->command[p_i2c->cmd_idx].ack_val = cmd->ack_val;
    I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = cmd->byte_num;
    I2C[i2c_num]->command[p_i2c->cmd_idx].op_code = cmd->op_code;

    if (cmd->op_code == I2C_CMD_WRITE) {

      uint32_t wr_filled = 0;

      //TODO: to reduce interrupt number
      if (cmd->data) {

        while (p_i2c->tx_fifo_remain > 0 && cmd->byte_num > 0) {

          WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), *cmd->data++);
          p_i2c->tx_fifo_remain--;
          cmd->byte_num--;
          wr_filled++;

        }

      } else {

        WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), cmd->byte_cmd);
        p_i2c->tx_fifo_remain--;
        cmd->byte_num--;
        wr_filled ++;

      }

      // Workaround for register field operation.
      I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = wr_filled;
      I2C[i2c_num]->command[p_i2c->cmd_idx + 1].val = 0;
      I2C[i2c_num]->command[p_i2c->cmd_idx + 1].op_code = I2C_CMD_END;
      p_i2c->tx_fifo_remain = I2C_FIFO_LEN;
      p_i2c->cmd_idx = 0;

      if (cmd->byte_num > 0) {

      } else {

        p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;

      }

      p_i2c->status = I2C_STATUS_WRITE;

      break;

    } else if(cmd->op_code == I2C_CMD_READ) {

      //TODO: to reduce interrupt number
      p_i2c->rx_cnt = cmd->byte_num > p_i2c->rx_fifo_remain ? p_i2c->rx_fifo_remain : cmd->byte_num;

      cmd->byte_num -= p_i2c->rx_cnt;

      I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = p_i2c->rx_cnt;
      I2C[i2c_num]->command[p_i2c->cmd_idx].ack_val = cmd->ack_val;
      I2C[i2c_num]->command[p_i2c->cmd_idx + 1].val = 0;
      I2C[i2c_num]->command[p_i2c->cmd_idx + 1].op_code = I2C_CMD_END;

      p_i2c->status = I2C_STATUS_READ;

      break;

    } else {

    }

    p_i2c->cmd_idx++;
    p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;

    if (p_i2c->cmd_link.head == NULL || p_i2c->cmd_idx >= 15) {

      p_i2c->tx_fifo_remain = I2C_FIFO_LEN;
      p_i2c->cmd_idx = 0;
      p_i2c->status = I2C_STATUS_IDLE;

      break;

    }
  }

  I2C[i2c_num]->int_clr.end_detect = 1;
  I2C[i2c_num]->int_clr.master_tran_comp = 1;
  I2C[i2c_num]->int_ena.end_detect = 1;
  I2C[i2c_num]->int_ena.master_tran_comp = 1;
  I2C[i2c_num]->ctr.trans_start = 0;
  I2C[i2c_num]->ctr.trans_start = 1;

  return;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_master_cmd_begin
 *  Desc: 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
//esp_err_t i2c_master_cmd_begin(i2c_port_t i2c_num, i2c_cmd_handle_t cmd_handle, portBASE_TYPE ticks_to_wait)
esp_err_t i2c_master_cmd_begin(i2c_obj_t* p_i2c, i2c_cmd_handle_t cmd_handle, portBASE_TYPE ticks_to_wait)
{

  int i2c_num = p_i2c->i2c_num;

  I2C_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(p_i2c != NULL, I2C_DRIVER_NOT_INSTALL_ERR_STR, ESP_ERR_INVALID_STATE);
  I2C_CHECK(p_i2c->mode == I2C_MODE_MASTER, I2C_MASTER_MODE_ERR_STR, ESP_ERR_INVALID_STATE);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  esp_err_t ret;

 //   i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

  portTickType ticks_end = xTaskGetTickCount() + ticks_to_wait;
  portBASE_TYPE res = xSemaphoreTake(p_i2c->cmd_mux, ticks_to_wait);
  if (res == pdFALSE) {

    return ESP_ERR_TIMEOUT;
  }

    xSemaphoreTake(p_i2c->cmd_sem, 0);
    i2c_reset_tx_fifo(i2c_num);
    i2c_reset_rx_fifo(i2c_num);
    i2c_cmd_desc_t* cmd = (i2c_cmd_desc_t*) cmd_handle;
    p_i2c->cmd_link.free = cmd->free;
    p_i2c->cmd_link.cur = cmd->cur;
    p_i2c->cmd_link.head = cmd->head;
    p_i2c->status = I2C_STATUS_IDLE;
    p_i2c->cmd_idx = 0;
    p_i2c->rx_cnt = 0;
    p_i2c->tx_fifo_remain = I2C_FIFO_LEN;
    p_i2c->rx_fifo_remain = I2C_FIFO_LEN;
    i2c_reset_tx_fifo(i2c_num);
    i2c_reset_rx_fifo(i2c_num);

    //start send commands, at most 32 bytes one time, isr handler will process the remaining commands.
    i2c_master_cmd_begin_static(p_i2c);
    ticks_to_wait = ticks_end - xTaskGetTickCount();
    res = xSemaphoreTake(p_i2c->cmd_sem, ticks_to_wait);
    if (res == pdFALSE) {
        ret = ESP_ERR_TIMEOUT;
    } else if (p_i2c->status == I2C_STATUS_ACK_ERROR) {
        ret = ESP_FAIL;
    } else {
        ret = ESP_OK;
    }
    p_i2c->status = I2C_STATUS_DONE;
    xSemaphoreGive(p_i2c->cmd_mux);
    return ret;
}


