/* #################################################################################################
 *
 *      Name: ESP32_I2C_Master Module
 *  Function: This is used to set up GPIOs as a switch with the goal to control switching hardware
 *            (relay, ...). The GPIO switching is Hardware PWM driven (for ESP32 SOC only). 
 *            Module for use with SCDE (Smart Connected Device Engine) only !
 *
 *  ESP 8266EX & ESP32 SoC Activities ...
 *  HoME CoNTROL & Smart Connected Device Engine Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 *
 *
 */
//http://www.elektronik-magazin.de/page/der-i2c-bus-was-ist-das-21
//SSD1306 demo: https://github.com/yanbe/ssd1306-esp-idf-i2c/blob/master/main/main.c

//define I2CM ESP32_I2C_Master I2C_NUM=1&I2C_MODE=Master&SDA_IO=18&SDA_IO_PULLUP=Enabled&SCL_IO=19&SCL_IO_PULLUP=Enabled&MASTER_CLOCK=100000


#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>

#include <SCDE_s.h>

#include "ESP32_I2C_Master_Module_s.h"
#include "ESP32_I2C_Master_Module.h"

#include "SCDE_Main.h"

#include "driver/gpio.h"



// ptr zur Fehlermeldung in allokierter strTextMultiple_t WENN NOCH KEIN FEHLER WAR
#define SCDE_OK  NULL

/*
static const char* I2S_TAG = "I2S";
#define SCDE_CHECK(a, str, ret) if (!(a)) {                                              \
        ESP_LOGE(I2S_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);       \
        return (ret);                                                                   \
        }
//  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
*/



// SCDE_CHECK MAKRO: Prüft Bedingung und gibt Fehler in allokierter strTextMultiple_t zurück
#define SCDE_CHECK(a, str) if (!(a)) {							\
	retMsg = malloc(sizeof(strTextMultiple_t));					\
	retMsg->strTextLen = asprintf(&retMsg->strText					\
		,"Error! '%s'"								\
		,str);									\
	return retMsg;									\
	}






// -------------------------------------------------------------------------------------------------

// set default build verbose - if no external override
#ifndef ESP32_I2C_Master_Module_DBG  
#define ESP32_I2C_Master_Module_DBG  5	// 5 is default
#endif 

// -------------------------------------------------------------------------------------------------



// make data root locally available
static SCDERoot_t* SCDERoot;

// make locally available from data-root: the SCDEFn (Functions / callbacks) for operation
static SCDEFn_t* SCDEFn;

// -------------------------------------------------------------------------------------------------

#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------



/*
 * Implemented Values for Keys
 */

// ESP32_I2C_Master_SET_DISENA -> 'SDA_IO_PULLUP' -> Disabled|Enabled
//                             -> 'SCL_IO_PULLUP' -> Disabled|Enabled
SelectAData ESP32_I2C_Master_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// ESP32_I2C_Master_SET_I2C_MODE -> 'I2C_MODE' -> Master|Slave
SelectAData ESP32_I2C_Master_I2C_MODE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Master"},
  {1,"Slave"}, 
  {0, NULL}
  };

/*
// ESP32_I2C_Master_SET_IDLE_LV -> 'IDLE_LV' -> Low|High
SelectAData ESP32_I2C_Master_LoHi[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Low"},
  {1,"High"}, 
  {0, NULL}
  };
// ESP32_I2C_Master_SET_BLOCK -> 'PWM_BLOCK'-> High_Speed|Low_Speed
SelectAData ESP32_I2C_Master_PWM_BLOCK[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"High_Speed"},
  {1,"Low_Speed"},
  {0, NULL}
  };
// ESP32_I2C_Master_SET_TICK_SOURCE -> 'TICK_SOURCE'-> REF|APB_SLOW
SelectAData ESP32_I2C_Master_TICK_SOURCE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"REF"},
  {1,"APB_SLOW"}, 
  {0, NULL}
  };
*/



/**
 * For Type: ESP32_I2C_Master
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in ESP32_I2C_Master_parsedKVInput_t
 */
enum ESP32_I2C_Master_SET_IK {				// Bit #XX for debugging

  // Block #1 I2C Block to use
    ESP32_I2C_Master_SET_I2C_NUM			// Bit #01 'I2C_NUM' -> 

  // Block #2 I2C Master/Slave ?
  , ESP32_I2C_Master_SET_I2C_MODE			// Bit #02 'I2C_MODE' -> 

  // Block #3 I2C Pin connections
  , ESP32_I2C_Master_SET_SDA_IO				// Bit #03 'SDA_IO' -> 
  , ESP32_I2C_Master_SET_SDA_IO_PULLUP			// Bit #04 'SDA_IO_PULLUP' -> 
  , ESP32_I2C_Master_SET_SCL_IO				// Bit #05 'SCL_IO' ->
  , ESP32_I2C_Master_SET_SCL_IO_PULLUP			// Bit #06 'SCL_IO_PULLUP' ->

  // Block #4 I2C Pin connections
  , ESP32_I2C_Master_SET_MASTER_CLOCK			// Bit #07 'MASTER_CLOCK' ->

  // Block #5 I2C Pin connections
  , ESP32_I2C_Master_SET_SLAVE_10BIT_ENA		// Bit #08 'SLAVE_10BIT_ENA' ->

  // Block #6 I2C Pin connections
  , ESP32_I2C_Master_SET_SLAVE_ADRESS			// Bit #09 'SLAVE_ADRESS' ->

// end marker
  , ESP32_I2C_Master_SET_NUMBER_OF_IK			// Bit #10 MAX 64 IMPLEMENTED !

};

 

/**
 * For Type: ESP32_I2C_Master
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum ESP32_I2C_Master_Readings {			// Bit #XX for debugging

   ESP32_I2C_Master_R_DUTY		= (1<<0)	// Bit #00 'Duty'  -> 

  ,ESP32_I2C_Master_R_RESOLUTION	= (1<<1)	// Bit #01 'Resolution' -> 

  ,ESP32_I2C_Master_R_NAME		= (1<<2)	// Bit #02 'name' + caps + ufid -> 

};



/**
 * For Type: ESP32_I2C_Master
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()
 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t ESP32_I2C_Master_Set_ImplementedKeys[] = {
// |                     affectedreadings						       	|  CMD

// for usage

// for configuration
   { 0												,"I2C_NUM" }		// #01
  ,{ 0												,"I2C_MODE" }		// #02
  ,{ 0												,"SDA_IO" }		// #03
  ,{ 0												,"SDA_IO_PULLUP" }	// #04
  ,{ 0												,"SCL_IO" }		// #05
  ,{ 0												,"SCL_IO_PULLUP" }	// #06
  ,{ 0												,"MASTER_CLOCK" }	// #07
  ,{ 0												,"SLAVE_10BIT_ENA" }	// #08
  ,{ 0												,"SLAVE_ADRESS" }	// #09
 
}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t ESP32_I2C_Master_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t ESP32_I2C_Master_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



// -------------------------------------------------------------------------------------------------



/*
 * DName: ESP32_I2C_Master_Fn (SCDE Functions)
 * Desc: Stores function callbacks provided & made accessible for client modules using this module,
 *       for operation and helpers
 * Data: 
 */
ESP32_I2C_Master_Fn_t ESP32_I2C_Master_Fn = {
   i2c_cmd_link_create
  ,i2c_cmd_link_delete
  ,i2c_cmd_link_append
  ,i2c_master_start
  ,i2c_master_stop
  ,i2c_master_write
  ,i2c_master_write_byte
  ,i2c_master_read_byte
  ,i2c_master_read
  ,i2c_master_cmd_begin
};



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_I2C_Master_Module
 *  Desc: Data 'Provided By Module' for the ESP32_I2C_Master module (functions + infos this module provides
 *        to SCDE)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
ProvidedByModule_t ESP32_I2C_Master_ProvidedByModule = {
   // A-Z order
  "ESP32_I2C_Master"			// Type-Name of module -> should be same name as libfilename.so !
  ,16					// size of Type-Name

  ,NULL					// Add
  ,ESP32_I2C_Master_Attribute		// Attribute
  ,ESP32_I2C_Master_Define		// Define
  ,NULL					// Delete
  ,NULL					// Except
  ,NULL					// Get
  ,ESP32_I2C_Master_IdleCb		// IdleCb
  ,ESP32_I2C_Master_Initialize		// Initialize
  ,NULL					// Notify
  ,NULL					// Parse
  ,NULL					// Read
  ,NULL					// Ready
  ,NULL					// Rename
  ,ESP32_I2C_Master_Set			// Set
  ,ESP32_I2C_Master_Shutdown		// Shutdown
  ,NULL					// State
  ,NULL					// Sub
  ,ESP32_I2C_Master_Undefine		// Undefine
  ,NULL					// DirectRead
  ,NULL					// DirectWrite
//  ,NULL		 		// FnProvided
  ,sizeof(ESP32_I2C_Master_Definition_t) // Size of modul specific definition structure (Common_Definition_t + X)
};



/* -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Attribute
 *  Desc: Informs an Definition of this Type for attribute activities (set/del)
 *  Info: 'attrCmd' is the command text for the activity: set, del
 *        'attrName' is the attribute name text
 *        'attrVal' is the attribute value text
 *        THE attrVal CAN BE MANIPULATED / CORRECTED
 *  Para: Common_Definition_t *Common_Definition -> the belonging definition for the attribute-activitie
 *	  const uint8_t *attrCmdText -> ptr to attribute-command text "attrCmd"
 *	  const size_t attrCmdTextLen -> length of attribute-command text "attrCmd"
 *	  const uint8_t *attrNameText -> ptr to attribute-name text "attrName"
 *	  const size_t attrNameTextLen -> length of attribute-name text "attrName"
 *	  uint8_t **attrValTextPtr -> ptr to ptr holding attribute-value text "attrValue" - manipulation possible
 *	  size_t *attrValLenTextPtr -> ptr to length of attribute-value text "attrValue" - manipulation possible
 *  Rets: strTextMultiple_t* -> veto = error-text-string in allocated mem, or NULL = OK - no veto
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Attribute(Common_Definition_t *Common_Definition
		,const uint8_t *attrCmdText
		,const size_t attrCmdTextLen
		,const uint8_t *attrNameText
		,const size_t attrNameTextLen
		,uint8_t **attrValTextPtr
		,size_t *attrValTextLenPtr)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  uint8_t *attrValText = *attrValTextPtr;
  size_t attrValTextLen = *attrValTextLenPtr;

  printf("ESP32_I2C_Master_AttributeFN for defName:%.*s -> attrCmd:%.*s attrName:%.*s attrVal:%.*s\n"
	,Common_Definition->nameLen
	,Common_Definition->name
	,attrCmdTextLen
	,attrCmdText
  	,attrNameTextLen
	,attrNameText
	,(int) attrValTextLen
	,attrValText);



/*
  // set start of possible def-Name
  const uint8_t *defName = args;
  // set start of possible attr-Name
  const uint8_t *attrName = args;
  // a seek-counter
  int i = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrName != ' ') ) {i++;attrName++;}
  // length of def-Name
  size_t defNameLen = i;
  // seek to start position of attr-Name '\32'
  while( (i < argsLen) && (*attrName == ' ') ) {i++;attrName++;}
  // set start of possible attr-Val
  const uint8_t *attrVal = attrName;
  // a 2nd seek-counter
  int j = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrVal != ' ') ) {i++,j++;attrVal++;}
  // length of attr-Name
  size_t attrNameLen = j;
  // start position of attr-Val
  while( (i < argsLen) && (*attrVal == ' ') ) {i++;attrVal++;}
  // length of attr-Val
  size_t attrValLen = argsLen - i;
  // veryfy lengths > 0, definition 0 allowed
  if ( (defNameLen == 0) || (attrNameLen == 0) )
		{
		// response with error text
		asprintf(&retMsg
				,"Could not interpret command ''! Usage: Attr <defname> <attrname> [<attrval>]");
		return retMsg;
	//	}
// -------------------------------------------------------------------------------------------------
*/

  return retMsg;
}








#include "freertos/ringbuf.h"


#include "soc/i2c_struct.h"
#include "soc/i2c_reg.h"
#include "driver/periph_ctrl.h"

static const char* I2C_TAG = "i2c";

#define I2C_CHECK(a, str, ret)  if(!(a)) {                                             \
        ESP_LOGE(I2C_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);      \
        return (ret);                                                                   \
        }






static portMUX_TYPE i2c_spinlock[I2C_NUM_MAX] = 
	{portMUX_INITIALIZER_UNLOCKED, portMUX_INITIALIZER_UNLOCKED};

// I2C Hardware adressing array (1,2), ACCESSED FROM IRQ - keep in RAM!
static DRAM_ATTR i2c_dev_t* const I2C[I2C_NUM_MAX] = { &I2C0, &I2C1 };

// i2c processing IRQ handler (ACCESSED FROM IRQ - keep in RAM!)
static void i2c_isr_handler_default(void* arg);

// Fn to start i2c cmd linked list processing  (ACCESSED FROM IRQ - keep in RAM!)
static void IRAM_ATTR i2c_master_cmd_begin_static(i2c_obj_t* p_i2c);

// Fn to reset (ACCESSED FROM IRQ - keep in RAM!)
static esp_err_t IRAM_ATTR i2c_hw_fsm_reset(i2c_port_t i2c_num);



#define I2C_ENTER_CRITICAL_ISR(mux)    portENTER_CRITICAL_ISR(mux)
#define I2C_EXIT_CRITICAL_ISR(mux)     portEXIT_CRITICAL_ISR(mux)
#define I2C_ENTER_CRITICAL(mux)        portENTER_CRITICAL(mux)
#define I2C_EXIT_CRITICAL(mux)         portEXIT_CRITICAL(mux)

#define I2C_DRIVER_ERR_STR             "i2c driver install error"
#define I2C_DRIVER_MALLOC_ERR_STR      "i2c driver malloc error"
#define I2C_NUM_ERROR_STR              "i2c number error"
#define I2C_TIMEING_VAL_ERR_STR        "i2c timing value error"
#define I2C_ADDR_ERROR_STR             "i2c null address error"
#define I2C_DRIVER_NOT_INSTALL_ERR_STR "i2c driver not installed"
#define I2C_SLAVE_BUFFER_LEN_ERR_STR   "i2c buffer size too small for slave mode"
#define I2C_EVT_QUEUE_ERR_STR          "i2c evt queue error"
#define I2C_SEM_ERR_STR                "i2c semaphore error"
#define I2C_BUF_ERR_STR                "i2c ringbuffer error"
#define I2C_MASTER_MODE_ERR_STR        "Only allowed in master mode"
#define I2C_MODE_SLAVE_ERR_STR         "Only allowed in slave mode"
#define I2C_CMD_MALLOC_ERR_STR         "i2c command link malloc error"
#define I2C_TRANS_MODE_ERR_STR         "i2c trans mode error"
#define I2C_MODE_ERR_STR               "i2c mode error"
#define I2C_SDA_IO_ERR_STR             "sda gpio number error"
#define I2C_SCL_IO_ERR_STR             "scl gpio number error"
#define I2C_CMD_LINK_INIT_ERR_STR      "i2c command link error"
#define I2C_GPIO_PULLUP_ERR_STR        "this i2c pin does not support internal pull-up"
#define I2C_ACK_TYPE_ERR_STR           "i2c ack type error"
#define I2C_DATA_LEN_ERR_STR           "i2c data read length error"
#define I2C_PSRAM_BUFFER_WARN_STR      "Using buffer allocated from psram"
#define I2C_FIFO_FULL_THRESH_VAL       (28)
#define I2C_FIFO_EMPTY_THRESH_VAL      (5)
#define I2C_IO_INIT_LEVEL              (1)
#define I2C_CMD_ALIVE_INTERVAL_TICK    (1000 / portTICK_PERIOD_MS)
#define I2C_CMD_EVT_ALIVE              (0)
#define I2C_CMD_EVT_DONE               (1)
#define I2C_EVT_QUEUE_LEN              (1)
#define I2C_SLAVE_TIMEOUT_DEFAULT      (32000)     /* I2C slave timeout value, APB clock cycle number */
#define I2C_SLAVE_SDA_SAMPLE_DEFAULT   (10)        /* I2C slave sample time after scl positive edge default value */
#define I2C_SLAVE_SDA_HOLD_DEFAULT     (10)        /* I2C slave hold time after scl negative edge default value */
#define I2C_MASTER_TOUT_CNUM_DEFAULT   (8)         /* I2C master timeout cycle number of I2C clock, after which the timeout interrupt will be triggered */
#define I2C_ACKERR_CNT_MAX             (10)
#define I2C_FILTER_CYC_NUM_DEF         (7)         /* The number of apb cycles filtered by default*/
#define I2C_CLR_BUS_SCL_NUM            (9)
#define I2C_CLR_BUS_HALF_PERIOD_US     (5)





























/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Define
 *  Desc: Finalizes the defines a new "device" of 'ESP32_S0' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_I2C_Master_Define(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) Common_Definition;

  // for Fn response msg
  strTextMultiple_t *retMsg = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if ESP32_I2C_Master_Module_DBG >= 5
  SCDEFn->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,5
	,"DefineFn of Module '%.*s' is called to continue creation of Definition '%.*s' with args '%.*s'."
	,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeNameLen
	,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeName
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name
	,ESP32_I2C_Master_Definition->common.definitionLen
	,ESP32_I2C_Master_Definition->common.definition);
  #endif

// ------------------------------------------------------------------------------------------------

  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Expected Args!");

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

//  xSemaphoreTake(ESP32_I2C_Master_Definition->def_mux
//    ,portMAX_DELAY);

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  ESP32_I2C_Master_Definition->common.fd = -1;

  // store table of function callbacks provided & made accessible for client modules
  ESP32_I2C_Master_Definition->ESP32_I2C_Master_Fn = &ESP32_I2C_Master_Fn;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  ESP32_I2C_Master_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (ESP32_I2C_Master_Definition->WebIf_Provided.WebIf_FnProvided) {

	ESP32_I2C_Master_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &ESP32_I2C_Master_ActiveResourcesDataA_forWebIf;

	ESP32_I2C_Master_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &ESP32_I2C_Master_ActiveResourcesDataB_forWebIf;
  }

  else	{

	SCDEFn->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,ESP32_I2C_Master_Definition->common.nameLen
		,ESP32_I2C_Master_Definition->common.name
		,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeNameLen
		,ESP32_I2C_Master_Definition->common.module->ProvidedByModule->typeName);
  }

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn->ParseKVInputArgsFn(ESP32_I2C_Master_SET_NUMBER_OF_IK		// Num Implementated KEYs MAX
	,ESP32_I2C_Master_Set_ImplementedKeys					// Implementated Keys
	,defArgsText								// our args text
	,defArgsTextLen);							// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,defArgsTextLen
		,defArgsText);

	if (parsedKVInput) {

		free(parsedKVInput);
	}

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // try 1 - arguments for configuration as i2c master ?

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 	( (1 << ESP32_I2C_Master_SET_I2C_NUM)
					| (1 << ESP32_I2C_Master_SET_I2C_MODE)
					| (1 << ESP32_I2C_Master_SET_SDA_IO)
					| (1 << ESP32_I2C_Master_SET_SDA_IO_PULLUP)
					| (1 << ESP32_I2C_Master_SET_SCL_IO)
					| (1 << ESP32_I2C_Master_SET_SCL_IO_PULLUP)
					| (1 << ESP32_I2C_Master_SET_MASTER_CLOCK)
					);

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 	( (1 << ESP32_I2C_Master_SET_SLAVE_10BIT_ENA)
					| (1 << ESP32_I2C_Master_SET_SLAVE_ADRESS)
 					);
/*
  // process the set-args (key=value@) protocol
  retMsg = ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition,
		parsedKVInput,		// KVInput parsed
		defArgsText,		// our args text
		defArgsTextLen);	// our args text len*/

  // processing reports an problem. Args not taken. Return with MSG
  if (retMsg != SCDE_OK) {

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

















  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("|ESP32_I2C_Master_Define, installing i2c driver>");
  #endif




//Temp fill of struct

#define I2C_MASTER_NUM I2C_NUM_1   //!< I2C port number for master dev 
#define I2C_MASTER_SDA_IO    18    //!< gpio number for I2C master data  
#define I2C_MASTER_SCL_IO    19    //!< gpio number for I2C master clock 
#define I2C_MASTER_FREQ_HZ    100000     //!< I2C master clock frequency 



    ESP32_I2C_Master_Definition->i2c_num =
	I2C_MASTER_NUM;
    ESP32_I2C_Master_Definition->i2c_config.mode =
	I2C_MODE_MASTER;
    ESP32_I2C_Master_Definition->i2c_config.sda_io_num =
	I2C_MASTER_SDA_IO;
    ESP32_I2C_Master_Definition->i2c_config.sda_pullup_en =
	GPIO_PULLUP_ENABLE;
    ESP32_I2C_Master_Definition->i2c_config.scl_io_num =
	I2C_MASTER_SCL_IO;
    ESP32_I2C_Master_Definition->i2c_config.scl_pullup_en =
	GPIO_PULLUP_ENABLE;
    ESP32_I2C_Master_Definition->i2c_config.master.clk_speed =
	I2C_MASTER_FREQ_HZ;


// ------------------------------------------------------------------------------------------------

  // setup GPIOS, activate i2c, ...
  retMsg = i2c_param_config(ESP32_I2C_Master_Definition->i2c_num,
	&ESP32_I2C_Master_Definition->i2c_config);

 // error during config ? return with MSG
  if (retMsg != SCDE_OK) {

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

//zero struct?
 ESP32_I2C_Master_Definition->i2c_obj = NULL;

#define I2C_MASTER_TX_BUF_DISABLE   0   /*!< I2C master do not need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0   /*!< I2C master do not need buffer */
 printf("|2ESP32_I2C_Master_Define, installing i2c driver2>");
  // install the I2C driver
  i2c_driver_install(ESP32_I2C_Master_Definition->i2c_num,
	&ESP32_I2C_Master_Definition->i2c_obj,
	ESP32_I2C_Master_Definition->i2c_config.mode,
	I2C_MASTER_RX_BUF_DISABLE,
	I2C_MASTER_TX_BUF_DISABLE,
	0);















/*
    For i2c master mode, we don't need to use a buffer for the data, the APIs will execute the master commands
and return after all of the commands have been sent out or when error occurs. So when we send master commands,
we should free or modify the source data only after the i2c_master_cmd_begin function returns.
    For i2c slave mode, we need a data buffer to stash the sending and receiving data, because the hardware fifo
has only 32 bytes.
*/









//xxxxxxxxxxxxx entry
















/*
esp_err_t i2c_driver_install(i2c_port_t i2c_num, i2c_mode_t mode, size_t slv_rx_buf_len, size_t slv_tx_buf_len,
    int intr_alloc_flags)
{
    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(mode == I2C_MODE_MASTER || ( slv_rx_buf_len > 100 || slv_tx_buf_len > 100 ), I2C_SLAVE_BUFFER_LEN_ERR_STR,
        ESP_ERR_INVALID_ARG);
*/



  // check:
  // mode			-> I2C_MODE_MASTER or I2C_MODE_SLAVE
  // i2c_num < I2C_NUM_MAX	-> 0-1
  // slv_rx_buf_len > 100	-> 0-100
  // slv_tx_buf_len > 100	-> 0-100



/*
i2c_port_t i2c_num = I2C_NUM_1;//0;
i2c_mode_t mode = I2C_MODE_MASTER;
size_t slv_rx_buf_len = I2C_MASTER_RX_BUF_DISABLE;
size_t slv_tx_buf_len = I2C_MASTER_TX_BUF_DISABLE;
int intr_alloc_flags = 0;





  // init i2c  
  uint32_t intr_mask = 0;

  i2c_obj_t *p_i2c = &ESP32_I2C_Master_Definition->i2c_obj;

  // init i2c obj
  p_i2c->i2c_num = i2c_num;
  p_i2c->mode = mode;
  p_i2c->cmd_idx = 0;
  p_i2c->rx_cnt = 0;
  p_i2c->status = I2C_STATUS_IDLE;
  p_i2c->rx_fifo_remain = I2C_FIFO_LEN;
  p_i2c->tx_fifo_remain = I2C_FIFO_LEN;

  // prepare for slave mode ? -> we use ringbuffers only in slave mode
  if (mode == I2C_MODE_SLAVE) {

    // prepare the requested RX buf length, > 0
    if (slv_rx_buf_len > 0) {
 
      p_i2c->rx_ring_buf = xRingbufferCreate(slv_rx_buf_len, RINGBUF_TYPE_BYTEBUF);

      // we got the buffer?
      if (p_i2c->rx_ring_buf == NULL) {
        ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);
        goto err;
      }

      p_i2c->rx_buf_length = slv_rx_buf_len;

    }

    // prepare the requested RX buf length, its 0!
    else {

      p_i2c->rx_ring_buf = NULL;

      p_i2c->rx_buf_length = 0;

    }

    // prepare the requested TX buf length, > 0
    if (slv_tx_buf_len > 0) {

      p_i2c->tx_ring_buf = xRingbufferCreate(slv_tx_buf_len, RINGBUF_TYPE_BYTEBUF);

      // we got the buffer?
      if (p_i2c->tx_ring_buf == NULL) {
        ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);
        goto err;

      }

      p_i2c->tx_buf_length = slv_tx_buf_len;

    }

    // prepare the requested TX buf length, its 0!
    else {

      p_i2c->tx_ring_buf = NULL;

      p_i2c->tx_buf_length = 0;

    }

    p_i2c->slv_rx_mux = xSemaphoreCreateMutex();
    p_i2c->slv_tx_mux = xSemaphoreCreateMutex();

    // we got the semaphores?
    if (p_i2c->slv_rx_mux == NULL || p_i2c->slv_rx_mux == NULL) {
      ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);
      goto err;

    }

    intr_mask |= ( I2C_RXFIFO_FULL_INT_ENA_M | I2C_TRANS_COMPLETE_INT_ENA_M );
  }

  // else prepare for master mode..
  else {

    // semaphore to sync sending process, because we only have 32 bytes for hardware fifo.
    p_i2c->cmd_sem = xSemaphoreCreateBinary();
    p_i2c->cmd_mux = xSemaphoreCreateMutex();

    // we got the semaphores?
    if (p_i2c->cmd_sem == NULL || p_i2c->cmd_mux == NULL) {
      ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);
      goto err;
    }

    // init command link
    p_i2c->cmd_link.cur = NULL;
    p_i2c->cmd_link.head = NULL;
    p_i2c->cmd_link.free = NULL;

    p_i2c->tx_ring_buf = NULL;
    p_i2c->rx_buf_length = 0;
    p_i2c->tx_ring_buf = NULL;
    p_i2c->tx_buf_length = 0;

  }

  // hook isr handler
  i2c_isr_register(i2c_num,
	i2c_isr_handler_default,
	p_i2c, //ESP32_I2C_Master_Definition
	intr_alloc_flags,
	&p_i2c->intr_handle); // an irq handle is stored here 

  intr_mask |= ( I2C_TRANS_COMPLETE_INT_ENA_M |
                 I2C_TRANS_START_INT_ENA_M |
                 I2C_ARBITRATION_LOST_INT_ENA_M |
                 I2C_ACK_ERR_INT_ENA_M |
                 I2C_RXFIFO_OVF_INT_ENA_M |
                 I2C_SLAVE_TRAN_COMP_INT_ENA_M );

  SET_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("|ESP32_I2C_Master_Define, i2c ready to use ..>");
  #endif
*/





/*
esp_err_t i2c_driver_delete(i2c_port_t i2c_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(p_i2c_obj[i2c_num] != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);
  i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

  uint32_t intr_mask = I2C_MASTER_TRAN_COMP_INT_ENA_M |
                       I2C_TIME_OUT_INT_ENA_M |
                       I2C_TRANS_COMPLETE_INT_ENA_M |
                       I2C_TRANS_START_INT_ENA_M |
                       I2C_TX_SEND_EMPTY_INT_ENA_M |
                       I2C_ARBITRATION_LOST_INT_ENA_M |
                       I2C_ACK_ERR_INT_ENA_M |
                       I2C_RXFIFO_OVF_INT_ENA_M |
                       I2C_RX_REC_FULL_INT_ENA_M |
                       I2C_SLAVE_TRAN_COMP_INT_ENA_M;

  CLEAR_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

  esp_intr_free(p_i2c->intr_handle);

  p_i2c->intr_handle = NULL;

  if (p_i2c->cmd_mux) {

	xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);
	vSemaphoreDelete(p_i2c->cmd_mux);
  }

  if (p_i2c->cmd_sem) {

	vSemaphoreDelete(p_i2c->cmd_sem);
  }

  if (p_i2c->slv_rx_mux) {

	vSemaphoreDelete(p_i2c->slv_rx_mux);
  }

  if (p_i2c->slv_tx_mux) {

	vSemaphoreDelete(p_i2c->slv_tx_mux);
  }

  if (p_i2c->rx_ring_buf) {

	vRingbufferDelete(p_i2c->rx_ring_buf);

	p_i2c->rx_ring_buf = NULL;
	p_i2c->rx_buf_length = 0;
  }

  if (p_i2c->tx_ring_buf) {

	vRingbufferDelete(p_i2c->tx_ring_buf);

	p_i2c->tx_ring_buf = NULL;
	p_i2c->tx_buf_length = 0;
  }

  free(p_i2c_obj[i2c_num]);
  p_i2c_obj[i2c_num] = NULL;

  return ESP_OK;
}
*/




































#define DATA_LENGTH          512  /*!<Data buffer length for test buffer*/
#define RW_TEST_LENGTH       129  /*!<Data length for r/w test, any value from 0-DATA_LENGTH*/
#define DELAY_TIME_BETWEEN_ITEMS_MS   1234 /*!< delay time between different test items */


#define BH1750_SENSOR_ADDR  0x23    /*!< slave address for BH1750 sensor */
#define BH1750_CMD_START    0x23    /*!< Command to set measure mode */
#define ESP_SLAVE_ADDR 0x28         /*!< ESP32 slave address, you can set any 7bit value */
#define WRITE_BIT  I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT   I2C_MASTER_READ  /*!< I2C master read */
#define ACK_CHECK_EN   0x1     /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS  0x0     /*!< I2C master will not check ack from slave */
#define ACK_VAL    0x0         /*!< I2C ack value */
#define NACK_VAL   0x1         /*!< I2C nack value */












  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("|ESP32_I2C_Master_Define, installed i2c driver>");
  #endif






    int i = 0;
    int ret;
 //   uint32_t task_idx = (uint32_t) arg;
    uint8_t* data = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t* data_wr = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t* data_rd = (uint8_t*) malloc(DATA_LENGTH);
    uint8_t sensor_data_h = 0;
    uint8_t sensor_data_l = 0;

 //   while (1) {
//        ret = i2c_master_sensor_test( I2C_MASTER_NUM, &sensor_data_h, &sensor_data_l);

    // I2C ...

    // create linked list head for i2c commands 
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    // append to linked list: initial master start cmd with cmd.op_code = I2C_CMD_RESTART
    i2c_master_start(cmd);
    // append to linked list: write master cmd with cmd.op_code = I2C_CMD_WRITE and the byte
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
    // append to linked list: write master cmd with cmd.op_code = I2C_CMD_WRITE and the byte
    i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
    // append to linked list: final stop cmd with cmd.op_code = I2C_CMD_STOP 
    i2c_master_stop(cmd);
    // exec linked list!
    ret = i2c_master_cmd_begin(ESP32_I2C_Master_Definition->i2c_obj, cmd, 1000 / portTICK_RATE_MS);
    // loops through the linked list cmd elements, frees them + finally frees the linked list head too
    i2c_cmd_link_delete(cmd);

    if (ret == ESP_FAIL) {
       // return ret;
    }

    else {
    vTaskDelay(30 / portTICK_RATE_MS);

    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd, &sensor_data_h, ACK_VAL);
    i2c_master_read_byte(cmd, &sensor_data_l, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(ESP32_I2C_Master_Definition->i2c_obj, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
     //   return ESP_FAIL;
    }
    else {
    ret = ESP_OK;
    }

}

   vTaskDelay(200 / portTICK_RATE_MS);

 //       xSemaphoreTake(print_mux, portMAX_DELAY);
        printf("*******************\n");
        printf("MASTER READ SENSOR( BH1750 )\n");
        printf("*******************\n");
        if (ret == ESP_OK) {
            printf("data_h: %02x\n", sensor_data_h);
            printf("data_l: %02x\n", sensor_data_l);
            printf("sensor val: %f\n", ( sensor_data_h << 8 | sensor_data_l ) / 1.2);
        } else {
            printf("No ack, sensor not connected...skip...\n");
        }



//https://github.com/BoschSensortec/BMP180_driver











// Following definitions are bollowed from 
// http://robotcantalk.blogspot.com/2015/03/interfacing-arduino-with-ssd1306-driven.html

// SLA (0x3C) + WRITE_MODE (0x00) =  0x78 (0b01111000)
#define OLED_I2C_ADDRESS   0x3C

// Control byte
#define OLED_CONTROL_BYTE_CMD_SINGLE    0x80
#define OLED_CONTROL_BYTE_CMD_STREAM    0x00
#define OLED_CONTROL_BYTE_DATA_STREAM   0x40

// Fundamental commands (pg.28)
#define OLED_CMD_SET_CONTRAST           0x81    // follow with 0x7F
#define OLED_CMD_DISPLAY_RAM            0xA4
#define OLED_CMD_DISPLAY_ALLON          0xA5
#define OLED_CMD_DISPLAY_NORMAL         0xA6
#define OLED_CMD_DISPLAY_INVERTED       0xA7
#define OLED_CMD_DISPLAY_OFF            0xAE
#define OLED_CMD_DISPLAY_ON             0xAF

// Addressing Command Table (pg.30)
#define OLED_CMD_SET_MEMORY_ADDR_MODE   0x20    // follow with 0x00 = HORZ mode = Behave like a KS108 graphic LCD
#define OLED_CMD_SET_COLUMN_RANGE       0x21    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x7F = COL127
#define OLED_CMD_SET_PAGE_RANGE         0x22    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x07 = PAGE7

// Hardware Config (pg.31)
#define OLED_CMD_SET_DISPLAY_START_LINE 0x40
#define OLED_CMD_SET_SEGMENT_REMAP      0xA1    
#define OLED_CMD_SET_MUX_RATIO          0xA8    // follow with 0x3F = 64 MUX
#define OLED_CMD_SET_COM_SCAN_MODE      0xC8    
#define OLED_CMD_SET_DISPLAY_OFFSET     0xD3    // follow with 0x00
#define OLED_CMD_SET_COM_PIN_MAP        0xDA    // follow with 0x12
#define OLED_CMD_NOP                    0xE3    // NOP

// Timing and Driving Scheme (pg.32)
#define OLED_CMD_SET_DISPLAY_CLK_DIV    0xD5    // follow with 0x80
#define OLED_CMD_SET_PRECHARGE          0xD9    // follow with 0xF1
#define OLED_CMD_SET_VCOMH_DESELCT      0xDB    // follow with 0x30

// Charge Pump (pg.62)
#define OLED_CMD_SET_CHARGE_PUMP        0x8D    // follow with 0x14





   vTaskDelay(200 / portTICK_RATE_MS);


{
	esp_err_t espRc;

	//oled demo: init
	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, 0x14, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP, true); // reverse left-right mapping
	i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true); // reverse up-bottom mapping

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(ESP32_I2C_Master_Definition->i2c_obj,
		cmd,
		10 / portTICK_PERIOD_MS);

	if (espRc == ESP_OK) {
		printf("OLED configured successfully");
	} else {
		printf("OLED configuration failed. code: 0x%.2X", espRc);
	}

	i2c_cmd_link_delete(cmd);
}

{
	// display pattern
	i2c_cmd_handle_t cmd;

	for (uint8_t i = 0; i < 8; i++) {
		cmd = i2c_cmd_link_create();
		i2c_master_start(cmd);
		i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
		i2c_master_write_byte(cmd, 0xB0 | i, true);
		i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);

		for (uint8_t j = 0; j < 128; j++) {
			i2c_master_write_byte(cmd, 0xFF >> (j % 8), true);
		}

		i2c_master_stop(cmd);

		i2c_master_cmd_begin(ESP32_I2C_Master_Definition->i2c_obj,
			cmd,
			10 / portTICK_PERIOD_MS);

		i2c_cmd_link_delete(cmd);
	}

	
}




















/* @brief test code to write esp-i2c-slave
 *
 * 1. set mode
 * _________________________________________________________________
 * | start | slave_addr + wr_bit + ack | write 1 byte + ack  | stop |
 * --------|---------------------------|---------------------|------|
 * 2. wait more than 24 ms
 * 3. read data
 * ______________________________________________________________________________________
 * | start | slave_addr + rd_bit + ack | read 1 byte + ack  | read 1 byte + nack | stop |
 * --------|---------------------------|--------------------|--------------------|------|
 */
/*
esp_err_t i2c_master_sensor_test(i2c_port_t i2c_num, uint8_t* data_h, uint8_t* data_l)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
    i2c_master_stop(cmd);
  // part in I.O. Device
    int ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ret;
    }
    vTaskDelay(30 / portTICK_RATE_MS);
    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd, data_h, ACK_VAL);
    i2c_master_read_byte(cmd, data_l, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ESP_FAIL;
    }
    return ESP_OK;
}
*/










/*
// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_I2C_Master_SET_I2C_NUM)
			        | (1 << ESP32_I2C_Master_SET_I2C_MODE)
			        | (1 << ESP32_I2C_Master_SET_SDA_IO)
			        | (1 << ESP32_I2C_Master_SET_SDA_IO_PULLUP)
			        | (1 << ESP32_I2C_Master_SET_SCL_IO)
			        | (1 << ESP32_I2C_Master_SET_SCL_IO_PULLUP) );

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition
    ,parsedKVInput				// KVInput parsed
    ,defArgsText				// our args text
    ,defArgsTextLen) ) {			// our args text len

    // Processing reports an problem. Args not taken. Response with error text.

    // alloc mem for retMsg
    retMsg = malloc(sizeof(strTextMultiple_t));

    // response with error text
    retMsg->strTextLen = asprintf(&retMsg->strText
      ,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
      ,defArgsTextLen
      ,defArgsText);

    // free allocated memory for query result key-field
    free(parsedKVInput);

    return retMsg;
  }

// ------------------------------------------------------------------------------------------------
*/
  // set affected readings
 // ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition
  //  ,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  //free(parsedKVInput);


// ------------------------------------------------------------------------------------------------

  // set up 1st idle Callback
  ESP32_I2C_Master_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

// alternative end in case of errors - free/destroy all allocated things and return SCDE_FAIL.
/* err:

  if (parsedKVInput) {

    free(parsedKVInput);

  }

  if (p_i2c->rx_ring_buf) {

    vRingbufferDelete(p_i2c->rx_ring_buf);
    p_i2c->rx_ring_buf = NULL;
    p_i2c->rx_buf_length = 0;

  }

  if (p_i2c->tx_ring_buf) {

    vRingbufferDelete(p_i2c->tx_ring_buf);
    p_i2c->tx_ring_buf = NULL;
    p_i2c->tx_buf_length = 0;

  }

  if (p_i2c->cmd_sem) {

    vSemaphoreDelete(p_i2c->cmd_sem);

  }

  if (p_i2c->cmd_mux) {

    vSemaphoreDelete(p_i2c->cmd_mux);

  }

  if (p_i2c->slv_rx_mux) {

    vSemaphoreDelete(p_i2c->slv_rx_mux);

  }

  if (p_i2c->slv_tx_mux) {

    vSemaphoreDelete(p_i2c->slv_tx_mux);
  }
*/
  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_DirectWrite
 *  Desc: for 2 stage designs - called to give write job to 1st stage (this stage)
 *  Info: 
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
/*
strTextMultiple_t *
ESP32_I2C_Master_DirectWrite(
	 Common_Definition_t *Common_Definition_Stage1
	,Common_Definition_t *Common_Definition_Stage2
	,Common_StageXCHG_t *Common_StageXCHG)
{
  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;
  // to adress 1st stage definition - make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition_Stage1 =
	(ESP32_I2C_Master_Definition_t*) Common_Definition_Stage1;
  // make common ptr to modul specific ptr
  ESP32_I2C_Master_StageXCHG_t *ESP32_I2C_Master_StageXCHG =
	(ESP32_I2C_Master_StageXCHG_t*) Common_StageXCHG;
// -------------------------------------------------------------------------------------------------
// check 4 matching modules
// -------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------
  #if ESP32_I2C_Master_Module_DBG >= 5
  SCDEFn->Log3Fn(
	 ESP32_I2C_Master_Definition_Stage1->common.name
	,ESP32_I2C_Master_Definition_Stage1->common.nameLen
	,5
	,"DirectWriteFn of Definition '%.*s' (Module '%.*s') is called "
  	 "from Definition '%.*s' (Module '%.*s') to exec write job."
	,ESP32_I2C_Master_Definition_Stage1->common.nameLen
	,ESP32_I2C_Master_Definition_Stage1->common.name
	,ESP32_I2C_Master_Definition_Stage1->common.module->ProvidedByModule->typeNameLen
	,ESP32_I2C_Master_Definition_Stage1->common.module->ProvidedByModule->typeName
	,Common_Definition_Stage2->nameLen
	,Common_Definition_Stage2->name
	,Common_Definition_Stage2->module->ProvidedByModule->typeNameLen
	,Common_Definition_Stage2->module->ProvidedByModule->typeName);
  #endif
// -------------------------------------------------------------------------------------------------
  return retMsg;
}
*/


/*
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int //feedModuleTask
ESP32_I2C_Master_IdleCb(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("\n|ESP32_I2C_Master_IdleCb, Def:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------


/*
  // build pointer to make the hardware counter accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_I2C_Master_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // build pointer to make the hardware timer accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_I2C_Master_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
*/
/*
  printf("|STATUS: A:%u, B:%u>"
	,pPWM_Timer->LEDC_HSTIMER_CNT
	,pPWM_Channel->DUTY_CYCLEX);
*/

/*
  // build ptr to access hw-counter
  ESP32_I2C_Master_CNT_CNT_REG_t *pESP32_I2C_Master_CNT_CNT_REG =
	(ESP32_I2C_Master_CNT_CNT_REG_t*) 0x3FF57060;
  printf("|STATUS: Using ctr-unit:%u, old HW-Ctr:%d, new ATT:%u, gpio:%u>"
	,ESP32_I2C_Master_Definition->counterUnit
	,pESP32_I2C_Master_CNT_CNT_REG[ESP32_I2C_Master_Definition->counterUnit].CNT_PULS_CNT
	,ESP32_I2C_Master_Definition->ATTShiftBuf[0]
	,gpio_get_level(22) ); //=att ?
  ESP32_I2C_Master_CNT_CONF_REG_t *pESP32_I2C_Master_CNT_CONF_REG = (ESP32_I2C_Master_CNT_CONF_REG_t*) 0x3FF57000;
	SCDEFn->HexDumpOutFn ("verify:"
		,&pESP32_I2C_Master_CNT_CONF_REG[0]
		, 0x80);  //sizeof(0x80) ); //ESP32_I2C_Master_CNT_CONF_REG_t) );
*/
/*
 if (WebIf_Definition->reverse) {
  // get assigned HTTPD-Connection-Slot-Data
  WebIf_HTTPDConnSlotData_t *conn
	= WebIf_Definition->reverse;
  // execute disconnection (indicated by NEEDS_CLOSE flag) or send more data ...
  if (conn->ConnCtrlFlags & F_GENERATE_IDLE_CALLBACK)
	{
	// execute Idle Callback
	WebIf_IdleCb(WebIf_Definition);
	}
}
*/


  // set up next idle Callback
  ESP32_I2C_Master_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
ESP32_I2C_Master_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn = SCDERootptr->SCDEFn;

  SCDEFn->Log3Fn(ESP32_I2C_Master_ProvidedByModule.typeName
		  ,ESP32_I2C_Master_ProvidedByModule.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,ESP32_I2C_Master_ProvidedByModule.typeNameLen
		  ,ESP32_I2C_Master_ProvidedByModule.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t *
ESP32_I2C_Master_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("\n|ESP32_I2C_Master_Set, Name:%.*s, got args:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn->ParseKVInputArgsFn(ESP32_I2C_Master_SET_NUMBER_OF_IK	// Num Implementated KEYs MAX for Set Fn
	,ESP32_I2C_Master_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
//  parsedKVInput->forbiddenKVBF = ( (1 << ESP32_I2C_Master_SET_CNT_UNIT) );
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine ESP32_I2C_Master_Definition.common.Name'
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("\n|ESP32_I2C_Master_Shutdown, Name:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_I2C_Master_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
	(ESP32_I2C_Master_Definition_t*) Common_Definition;

  #if ESP32_I2C_Master_Module_DBG >= 5
  printf("\n|ESP32_I2C_Master_Undefine, Name:%.*s>"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);

  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"ESP32_I2C_Master_Undefine, Name:%.*s"
	,ESP32_I2C_Master_Definition->common.nameLen
	,ESP32_I2C_Master_Definition->common.name);

  return retMsg;

}



/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: strTextMultiple_t* -> SCDE_OK, or error txts - for log
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_I2C_Master_ProcessKVInputArgs(ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition,
	parsedKVInputArgs_t *parsedKVInput,
	uint8_t *argsText,
	size_t argsTextLen)
{
 printf("|0");
  // start without error
  strTextMultiple_t *retMsg = SCDE_OK;


 // remember the readings affected by the parsing process
  uint32_t affectedReadings = 0;

// -------------------------------------------------------------------------------------------------
// 1. Step: Create backup structures, if required mirror current effective values.
// -------------------------------------------------------------------------------------------------

  // Block #01 Backup the current I2C-Block
  uint8_t new_i2c_num;
  new_i2c_num = ESP32_I2C_Master_Definition->i2c_num;

// -------------------------------------------------------------------------------------------------

  // Block #02 Backup the current I2C mode
  i2c_mode_t new_i2c_mode;
  new_i2c_mode = ESP32_I2C_Master_Definition->i2c_config.mode;

// -------------------------------------------------------------------------------------------------

  // Block #03 Backup the current SDA & SCL pin configuration used by I2C
  gpio_num_t new_sda_io_num;
  gpio_pullup_t new_sda_pullup_en;
  gpio_num_t new_scl_io_num;
  gpio_pullup_t new_scl_pullup_en;

  new_sda_io_num = ESP32_I2C_Master_Definition->i2c_config.sda_io_num;
  new_sda_pullup_en = ESP32_I2C_Master_Definition->i2c_config.sda_pullup_en;
  new_scl_io_num = ESP32_I2C_Master_Definition->i2c_config.scl_io_num;
  new_scl_pullup_en = ESP32_I2C_Master_Definition->i2c_config.scl_pullup_en;

// -------------------------------------------------------------------------------------------------

  // Block #04 Backup the current I2C clock speed
  uint32_t new_clk_speed;
  new_clk_speed = ESP32_I2C_Master_Definition->i2c_config.master.clk_speed;

// -------------------------------------------------------------------------------------------------

  // Block #05 Backup the current setting for 10Bit adressing in slave mode
  uint8_t new_addr_10bit_en;
  new_addr_10bit_en = ESP32_I2C_Master_Definition->i2c_config.slave.addr_10bit_en;

// -------------------------------------------------------------------------------------------------

  // Block #06 Backup the current I2C slave adress in slave
  uint8_t new_slave_addr;
  new_slave_addr = ESP32_I2C_Master_Definition->i2c_config.slave.slave_addr;

// -------------------------------------------------------------------------------------------------












// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'Block' KEY in advance here, because we need this information early
  // Block=High_Speed|Low_Speed
  // -> Setzt den Hardware-PWM-Block des ESP32 (0=HighSpeed / 1= LowSpeed) der verwendet werden soll
  // -> Sets the hardware-PWM-Block of the ESP32 (0=HighSpeed / 1= LowSpeed) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_BLOCK) ) {
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_BLOCK].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_BLOCK].len, &newBlock, ESP32_I2C_Master_PWM_BLOCK)
		&& (newBlock <= 1) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
  /*
  // we need to process the 'CHANNEL' KEY in advance here, because we need this information early
  // CHANNEL=[0-7]
  // -> Setzt den Hardware-PWM-Kanal des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware-pwm-channel of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CHANNEL) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CHANNEL].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CHANNEL].len, &newChannel) 
		&& (newChannel <= 7) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'TIMER' KEY in advance here, because we need this information early
  // TIMER=[0-3]
  // -> Setzt den Hardware-Timer f\FCr den gew\E4hlten PWM-Kanal des ESP32 (0-3) der verwendet werden soll
  // -> Sets the hardware-timer for the choosen pwm-channel of the ESP32 (0-3) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_TIMER) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_TIMER].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_TIMER].len, &newTimer) 
		&& (newTimer <= 3) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*
  // block #4 get current assigned / connected GPIO
  uint8_t newGPIO = ESP32_I2C_Master_Definition->GPIO;
  // block #5 reserve for new ATT
  uint32_t newATTVal;
  // block #6 reserve for new AVU
  char newAverageUnit[3];	
  // block #7  get ESP32 PWM channel configuration from selected channel
  // this stores our temp values
  ESP32_PWM_Channel_t newPWM_Channel;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * newChannel));
  // access low speed channels (instead of high speed channels)?
  if (newBlock) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // move data to temp storage
  memcpy(&newPWM_Channel, pPWM_Channel, sizeof(ESP32_PWM_Channel_t));
  // block #8  get ESP32 PWM timer configuration from selected timer
  // this stores our temp values
  ESP32_PWM_Timer_t newPWM_Timer;
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * newTimer));
  // access low speed timers (instead of high speed timers)?
  if (newBlock) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
  // move data to temp storage
  memcpy(&newPWM_Timer, pPWM_Timer, sizeof(ESP32_PWM_Timer_t));
  // store choosen timer in choosen channel
  newPWM_Channel.TIMER_SEL = newTimer;
*/



// ------------------------------------------------------------------------------------------------
// 2. Step: Process the possible input keys



// -------------------------------------------------------------------------------------------------
// I2C_NUM=[0-9] -> Setzt den I2C-Block der verwendet werden soll (0-1) 
// I2C_NUM=[0-9] -> Set the I2C-Block that should be used (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_I2C_NUM) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_NUM].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_NUM].len
		,&number)) {

		if (number < I2C_NUM_MAX) {

			// valid, take it
			new_i2c_num = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_NUM].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_NUM");
		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// I2C_MODE=[Master|Slave] -> Setzt den I2C modus ()
// I2C_MODE=[Master|Slave] -> Set the I2C mode ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_I2C_MODE) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_MODE].len, &number, ESP32_I2C_Master_I2C_MODE)) {

		// valid, take it
		new_i2c_mode = number;

		// mark affected readings for TX
		affectedReadings |= 
			parsedKVInput->keyData_t[ESP32_I2C_Master_SET_I2C_MODE].affectedReadings;

//		// Push processed CMD to to Response ...
//		RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_MODE");
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO=[0-9] -> Setzt den SDA IO Pin für I2C (?)
// SDA_IO=[0-9] -> Set the SDA IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SDA_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO].len, &number)) {

		if (GPIO_IS_VALID_OUTPUT_GPIO(number)) {

			// valid, take it
			new_sda_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SDA IO Pin für I2C ()
// SDA_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SDA IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SDA_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO_PULLUP].len, &number, ESP32_I2C_Master_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_sda_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_sda_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SDA_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO=[0-9] -> Setzt den SCL IO Pin für I2C (?)
// SCL_IO=[0-9] -> Set the SCL IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SCL_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO].len, &number)) {

		if ((GPIO_IS_VALID_OUTPUT_GPIO(number)) ||
    			(GPIO_IS_VALID_GPIO(number) && new_i2c_mode == I2C_MODE_SLAVE)) {

			// valid, take it
			new_scl_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SCL_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SCL IO Pin für I2C ()
// SCL_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SCL IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SCL_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO_PULLUP].len, &number, ESP32_I2C_Master_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_scl_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_scl_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=CLA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// MASTER_CLOCK=[0-9] -> Setzt den I2C-Takt (0-1) 
// MASTER_CLOCK=[0-9] -> Set the I2C-Clock (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_MASTER_CLOCK) {

	uint32_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_MASTER_CLOCK].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_MASTER_CLOCK].len, &number)) {

//		if (number < 65000) { //?????????????????????????????

			// valid, take it
			new_clk_speed = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_MASTER_CLOCK].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=MASTER_CLOCK");
//		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Setzt 10Bit Adressierung - im Slave-Mode für I2C ()
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Set 10Bit adresing - in slave-mode for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SLAVE_10BIT_ENA) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SLAVE_10BIT_ENA].len, &number, ESP32_I2C_Master_DisEna)) {

//		if (number < 65000) { //?????????????????????????????


			// valid, take it
			new_addr_10bit_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SLAVE_10BIT_ENA].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_10BIT_ENA");
//		}

		// invalid input detected ?
//		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// SLAVE_ADRESS=[0-9] -> Setzt die I2C-Slave-Adrsse (0-1) 
// SLAVE_ADRESS=[0-9] -> Set the I2C-Slave-Adress (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_I2C_Master_SET_SLAVE_ADRESS) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SLAVE_ADRESS].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SLAVE_ADRESS].len
		,&number)) {

		if (number < 100) { //?????????????????????????????

			// valid, take it
			new_slave_addr = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_I2C_Master_SET_SLAVE_ADRESS].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_ADRESS");
		}
	}

	// invalid input detected ?
	else return true;
  }































/*
//>Caps Bit 0---------------------------------------------------------------------------------------
  // on=[ ] -> Setze Kanal an (0-x)
  // on=[ ] -> Set channel on (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_on)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_on].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
//--------------------------------------------------------------------------------------------------
  // off=[ ] -> Setze Kanal aus (0-x)
  // off=[ ] -> Set channel off (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_off)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_off].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=off");
	}
//>Caps Bit 1---------------------------------------------------------------------------------------
  // max=[ ] -> Setze Kanal maximal (0-x)
  // max=[ ] -> Set channel maximum (0-x) 
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_max)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_max].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=max");
	}
//--------------------------------------------------------------------------------------------------
  // min=[ ] -> Setze Kanal minimal (0-x)
  // min=[ ] -> Set channel minimal (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_min)
	{
	// New Value = Min
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_min].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=min");
	}
//>Caps Bit 2---------------------------------------------------------------------------------------
  // val=[0-9] -> Setze Wert f\FCr Kanal (uint8) (0-x)
  // val=[0-9] -> Set value for channel (uint8) (0-x)
 else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_val)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_val].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_val].len, &NewVal))
		{
		// val input value clipping
		if (NewVal > SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax;
			}
		else if (NewVal < SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin;
			}
		// save mirror
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_val].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=val");
		}
	}
//>Caps Bit 3---------------------------------------------------------------------------------------
  // dim=[0-9] -> Setze dimmer f\FCr Kanal (uint8) (0-x)
  // dim=[0-9] -> Set dimming for channel (uint8) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_dim)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].len, &NewVal))
		
		{
		// dim input value clipping
		if (NewVal > 100) NewVal = 100;
		else if (NewVal < 0) NewVal = 0;
		// calculate val from dim
		NewVal = ( (NewVal *
			(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
			SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) /
			100 );
		// New Value = calculated from input
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// save mirror
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=dim");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_name].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) )
		{	
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_name].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_caps)
	{
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_caps].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
*/

/*
  // ATT=[0-9]
  // -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Z\E4hlerstand
  // -> Set alltime-total-tics meeting the currend meter-reading
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATT) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &newATTVal)) {
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= newATTVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------
  // AVU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Durchschnitts-Verbrauchs-Wert (char[3])
  // -> Set unit for average-consumption-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_AVU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &newAverageUnit
		,sizeof (newAverageUnit) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		,3) ) {
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1---------------------------------------------------------------------------------------
  // AVF=[0-9.]
  // -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // -> Set average consumption calculation factor (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_AVF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");
		}
	// invalid input detected ?
	else return true;
  }
//--------------------------------------------------------------------------------------------------
  // ATU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Allzeit-Gesamt-Wert (char[3])
  // -> Set unit for alltime-total-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		 {
		// store the value to temp
		//befehl hier!;
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 2---------------------------------------------------------------------------------------
  // ATF=[0-9.]
  // -> Setze Umrechnungsfaktor f\FCr den Allzeit-Total-Wert (float)
  // -> Set factor for alltime total value (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_ATF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");
		}
	// invalid input detected ?
	else return true;
  }
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_I2C_Master_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 3---------------------------------------------------------------------------------------
  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))
		{
		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
		{	
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{
	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;
//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");
	}
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_I2C_Master_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_HCTRL_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_HCTRL_MODE].len, &NewMode, ESP32_I2C_Master_CTRL_MODE) ) {
		// store ne value
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_I2C_Master_SET_CH1_POS_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_I2C_Master_SET_CH1_POS_MODE].len, &NewMode, ESP32_I2C_Master_CH_MODE) ) {
		// store ne value
		ESP32_I2C_Master_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/



// ------------------------------------------------------------------------------------------------
// 3. Step: check if all required Key=Value components for operation are included
//          -> if not, return with msg

  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! NOT all required Key=Value args found!");

	return retMsg;
  }



// ------------------------------------------------------------------------------------------------
// 4. Step: check if forbidden Key=Value components are included
//          -> if not, return with msg

  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! FORBIDDEN Key=Value args found!");

	return retMsg;
  }













// ------------------------------------------------------------------------------------------------
// 5. Step: Changes will happen, deinit old ...


/*
esp_err_t i2c_driver_delete(i2c_port_t i2c_num)
{

    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(p_i2c_obj[i2c_num] != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);
    i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

    uint32_t intr_mask = I2C_MASTER_TRAN_COMP_INT_ENA_M |
                         I2C_TIME_OUT_INT_ENA_M |
                         I2C_TRANS_COMPLETE_INT_ENA_M |
                         I2C_TRANS_START_INT_ENA_M |
                         I2C_TX_SEND_EMPTY_INT_ENA_M |
                         I2C_ARBITRATION_LOST_INT_ENA_M |
                         I2C_ACK_ERR_INT_ENA_M |
                         I2C_RXFIFO_OVF_INT_ENA_M |
                         I2C_RX_REC_FULL_INT_ENA_M |
                         I2C_SLAVE_TRAN_COMP_INT_ENA_M;

    CLEAR_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

    esp_intr_free(p_i2c->intr_handle);

    p_i2c->intr_handle = NULL;

    if (p_i2c->cmd_mux) {
        xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);
        vSemaphoreDelete(p_i2c->cmd_mux);
    }
    if (p_i2c->cmd_sem) {
        vSemaphoreDelete(p_i2c->cmd_sem);
    }
    if (p_i2c->slv_rx_mux) {
        vSemaphoreDelete(p_i2c->slv_rx_mux);
    }
    if (p_i2c->slv_tx_mux) {
        vSemaphoreDelete(p_i2c->slv_tx_mux);
    }
    if (p_i2c->rx_ring_buf) {
        vRingbufferDelete(p_i2c->rx_ring_buf);
        p_i2c->rx_ring_buf = NULL;
        p_i2c->rx_buf_length = 0;
    }
    if (p_i2c->tx_ring_buf) {
        vRingbufferDelete(p_i2c->tx_ring_buf);
        p_i2c->tx_ring_buf = NULL;
        p_i2c->tx_buf_length = 0;
    }

    free(p_i2c_obj[i2c_num]);
    p_i2c_obj[i2c_num] = NULL;

    return ESP_OK;
}
*/



// ------------------------------------------------------------------------------------------------
// 6. Step: Make the changes effective ...

  // block #1 store/use I2C Block (0 / 1)
  if (parsedKVInput->keysFoundBF | (1 << ESP32_I2C_Master_SET_I2C_NUM) ) {

	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 I2C_NUM=%d>"
		,new_i2c_num);	
  	#endif

	// enable i2c 0
	if (new_i2c_num == I2C_NUM_0) {

		periph_module_enable(PERIPH_I2C0_MODULE);
	}

	// enable i2c 1
	else if (new_i2c_num == I2C_NUM_1) {

		periph_module_enable(PERIPH_I2C1_MODULE);
	}

	// store assigned I2C Block
	ESP32_I2C_Master_Definition->i2c_num = 
		new_i2c_num;
  }

// ------------------------------------------------------------------------------------------------

  // block #2 store/use I2C Mode (Master/Slave)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_I2C_Master_SET_I2C_MODE) ) ) {

	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 I2C_MODE=%d>"
		,new_i2c_mode);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set rx data msb first
	I2C[new_i2c_num]->ctr.rx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// set tx data msb first
	I2C[new_i2c_num]->ctr.tx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// mode for master or slave
	I2C[new_i2c_num]->ctr.ms_mode = new_i2c_mode;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.sda_force_out = 1;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.scl_force_out = 1;

	// sample at high level of clock
	I2C[new_i2c_num]->ctr.sample_scl_level = 0;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;

		I2C[new_i2c_num]->fifo_conf.fifo_addr_cfg_en = 0;

		I2C[new_i2c_num]->fifo_conf.rx_fifo_full_thrhd =
			I2C_FIFO_FULL_THRESH_VAL;

		I2C[new_i2c_num]->fifo_conf.tx_fifo_empty_thrhd =
			I2C_FIFO_EMPTY_THRESH_VAL;

		I2C[new_i2c_num]->int_ena.rx_fifo_full = 1;

		I2C[new_i2c_num]->ctr.trans_start = 0;
	}

	// master mode ?
	else {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;
	}

	// ??
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Mode
	ESP32_I2C_Master_Definition->i2c_config.mode
		= new_i2c_mode;
  }

// ------------------------------------------------------------------------------------------------

  // block #3 store/use I2C Pin connections
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_I2C_Master_SET_SDA_IO)
			       		| (1 << ESP32_I2C_Master_SET_SDA_IO_PULLUP)
			       		| (1 << ESP32_I2C_Master_SET_SCL_IO)
			       		| (1 << ESP32_I2C_Master_SET_SCL_IO_PULLUP) ) ) {

	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 I2C Pins SDA_IO=%d, SDA_IO_PULLUP=%d,SCL_IO=%d, SCL_IO_PULLUP=%d,>"
		,new_sda_io_num,new_sda_pullup_en,new_scl_io_num,new_scl_pullup_en);	
  	#endif




/*


  SCDE_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR);
  SCDE_CHECK(((GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num))), I2C_SDA_IO_ERR_STR);
  SCDE_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
              (GPIO_IS_VALID_GPIO(scl_io_num) && mode == I2C_MODE_SLAVE),
              I2C_SCL_IO_ERR_STR);
  SCDE_CHECK((sda_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num)) ||
               sda_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
  SCDE_CHECK((scl_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
               scl_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
*/
	int sda_in_sig, sda_out_sig, scl_in_sig, scl_out_sig;

	// prepare the i2c gpio settings according to used hardware 
	switch (new_i2c_num) {

		case I2C_NUM_1:
			sda_out_sig = I2CEXT1_SDA_OUT_IDX;
			sda_in_sig = I2CEXT1_SDA_IN_IDX;
			scl_out_sig = I2CEXT1_SCL_OUT_IDX;
			scl_in_sig = I2CEXT1_SCL_IN_IDX;
			break;

		case I2C_NUM_0:
			default:
			sda_out_sig = I2CEXT0_SDA_OUT_IDX;
			sda_in_sig = I2CEXT0_SDA_IN_IDX;
			scl_out_sig = I2CEXT0_SCL_OUT_IDX;
			scl_in_sig = I2CEXT0_SCL_IN_IDX;
			break;
	}

	// sda gpio configuration
	if (new_sda_io_num >= 0) {

		gpio_set_level(new_sda_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_sda_io_num], PIN_FUNC_GPIO);

		gpio_set_direction(new_sda_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

		if (new_sda_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_sda_io_num, GPIO_PULLUP_ONLY);
		 } 

		else {

			gpio_set_pull_mode(new_sda_io_num, GPIO_FLOATING);
 		}

		gpio_matrix_out(new_sda_io_num, sda_out_sig, 0, 0);

		gpio_matrix_in(new_sda_io_num, sda_in_sig, 0);
	}

	// scl gpio configuration
	if (new_scl_io_num >= 0) {

		gpio_set_level(new_scl_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_scl_io_num], PIN_FUNC_GPIO);

		if (new_i2c_mode == I2C_MODE_MASTER) {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

			gpio_matrix_out(new_scl_io_num, scl_out_sig, 0, 0);
		}

		else {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT);
		}

		if (new_scl_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_scl_io_num, GPIO_PULLUP_ONLY);
		}

		else {

			gpio_set_pull_mode(new_scl_io_num, GPIO_FLOATING);
		}

		gpio_matrix_in(new_scl_io_num, scl_in_sig, 0);
 	}

	// store assigned I2C Pin connections
	ESP32_I2C_Master_Definition->i2c_config.sda_io_num
		= new_sda_io_num;

	ESP32_I2C_Master_Definition->i2c_config.sda_pullup_en
		= new_sda_pullup_en;

	ESP32_I2C_Master_Definition->i2c_config.scl_io_num
		= new_scl_io_num;

	ESP32_I2C_Master_Definition->i2c_config.scl_pullup_en
		= new_scl_pullup_en;
  }

// ------------------------------------------------------------------------------------------------

  // block #4 store/use I2C clock speed (when use as master only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_I2C_Master_SET_MASTER_CLOCK) ) ) {

	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 MASTER_CLOCK=%d>"
		,new_clk_speed);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set frequency
	int half_cycle = ( I2C_APB_CLK_FREQ / new_clk_speed ) / 2;
	I2C[new_i2c_num]->scl_low_period.period =
		 half_cycle - 1;
	I2C[new_i2c_num]->scl_high_period.period =
		( I2C_APB_CLK_FREQ / new_clk_speed ) - half_cycle - 1;

	// set timing for start signal
	I2C[new_i2c_num]->scl_start_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_rstart_setup.time = half_cycle;

	// set timing for stop signal
	I2C[new_i2c_num]->scl_stop_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_stop_setup.time = half_cycle;

	// set timing for data
	I2C[new_i2c_num]->sda_hold.time = half_cycle / 2;
	I2C[new_i2c_num]->sda_sample.time = half_cycle / 2;

	// set timeout of receving data
	I2C[new_i2c_num]->timeout.tout = 200000;

	// ???
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Pin connections
	ESP32_I2C_Master_Definition->i2c_config.master.clk_speed =
		new_clk_speed;
  }

// ------------------------------------------------------------------------------------------------

  // block #5 store/use I2C 10bit enable (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_I2C_Master_SET_SLAVE_10BIT_ENA) ) ) {

/*	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/

	// store assigned I2C Pin connections
	ESP32_I2C_Master_Definition->i2c_config.slave.addr_10bit_en =
		new_addr_10bit_en;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.en_10bit =
			new_addr_10bit_en;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------

  // block #6 store/use I2C slave adress (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_I2C_Master_SET_SLAVE_ADRESS) ) ) {

/*	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/

	// store assigned I2C Pin connections
	ESP32_I2C_Master_Definition->i2c_config.slave.slave_addr =
		new_slave_addr;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.addr =
			new_slave_addr;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------







/*
  // block #1 store assigned PWM-Block (low speed / high speed)
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_BLOCK) ) ) {
	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif
	// store assigned PWM-Block
	ESP32_I2C_Master_Definition->Block = newBlock;
  }
  // block #2 store assigned PWM Channel
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_CHANNEL) ) ) {
	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#02 PWM_Channel=%d>"
		,newChannel);	
  	#endif
	// store assigned PWM Channel
	ESP32_I2C_Master_Definition->Channel = newChannel;
  }
  // block #3 store assigned PWM Timer
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_TIMER) ) ) {
	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#03 PWM_Timer=%d>"
		,newTimer);	
  	#endif
	// store assigned PWM Timer
	ESP32_I2C_Master_Definition->Timer = newTimer;
  }
  // block #4 store assigned / connected GPIO
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_I2C_Master_SET_GPIO) ) ) {
	#if ESP32_I2C_Master_Module_DBG >= 5
	printf("|W B#04 PWM_GPIO=%d>"
		,newGPIO);	
  	#endif
	// store assigned GPIO
	ESP32_I2C_Master_Definition->GPIO = newGPIO;
	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newGPIO], PIN_FUNC_GPIO);
	// set GPIO as output
	gpio_set_direction(newGPIO, GPIO_MODE_OUTPUT);
	// configure for high-speed or low-speed ?
	if (newBlock) {
		// setup gpio matrix for low speed
	}
	else {
		// setup gpio matrix for high speed
		gpio_matrix_out(newGPIO, LEDC_HS_SIG_OUT0_IDX + newChannel, 0, 0);
		
	}
  }
  // block #5 store ESP32 pwm configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_I2C_Master_SET_TIMER)
				   | (1 << ESP32_I2C_Master_SET_SIG_OUT_EN)
				   | (1 << ESP32_I2C_Master_SET_IDLE_LV)
				   | (1 << ESP32_I2C_Master_SET_HPOINT)
				   | (1 << ESP32_I2C_Master_SET_DUTY) ) ) {
	// store ESP32 PWM configuration registers
	memcpy(pPWM_Channel, &newPWM_Channel, sizeof(ESP32_PWM_Channel_t));
	# if ESP32_I2C_Master_Module_DBG >= 5
	printf("|ESP32_PWM_Channel_s addr=%p>"
		,pPWM_Channel);
	SCDEFn->HexDumpOutFn ("dump"
		,pPWM_Channel
		, sizeof(ESP32_PWM_Channel_t) );
	# endif
  }
  // block #6 store ESP32 pwm-timer configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_I2C_Master_SET_TIMER)
				   | (1 << ESP32_I2C_Master_SET_RESOLUTION )
				   | (1 << ESP32_I2C_Master_SET_TICK_SOURCE)
			   	   | (1 << ESP32_I2C_Master_SET_FREQ_HZ) ) ) {
	// reset? It seems that a reset is needed to start timer
	newPWM_Timer.RESET = 0;
	// low speed timer? -> needs 'LOW_SPEED_UPDATE' bit set to take settings
	if (!newBlock) newPWM_Timer.LOW_SPEED_UPDATE = 1;
	// store ESP32 timer configuration registers
	memcpy(pPWM_Timer, &newPWM_Timer, sizeof(ESP32_PWM_Timer_t));
	# if ESP32_I2C_Master_Module_DBG >= 5
	printf("|ESP32_PWM_Timer_s addr=%p>"
		,pPWM_Timer);
	SCDEFn->HexDumpOutFn ("dump"
		,pPWM_Timer
		, sizeof(ESP32_PWM_Timer_t) );
	# endif
  }
*/


// ------------------------------------------------------------------------------------------------
// 7. Step:Set affected readings




  return retMsg;

}
















/*
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_val)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&val=%u",(uint) SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val);
	}
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_dim)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&dim=%u",(100 *
		(SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val -
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) / 
		(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) );
	}
//>Add Readings Bit 02 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += SwITCH_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=000F");						// 0b1111 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
//>always add Reading - state ----------------------------------------------------------------------
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	if (SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val == 0)
		RespArgsWPos += os_sprintf(RespArgsWPos, "state=off");
	else  RespArgsWPos += os_sprintf(RespArgsWPos, "state=on");
//--------------------------------------------------------------------------------------------------
*/
















/**
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_I2C_Master_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_I2C_Master_SetAffectedReadings(ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition
	,uint64_t affectedReadings)
{
/*
 affectedReadings = 0xfffffffffffffff;
  // do we have updates?
  if (affectedReadings) {
  SCDEFn->readingsBeginUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition);
  }
  // we have no updates
  else return false;
// -----------------------------------------------------------------------------------------------
  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_I2C_Master_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_I2C_Master_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (ESP32_I2C_Master_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  // add reading 'Duty'
  if (affectedReadings & ESP32_I2C_Master_R_DUTY) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Duty");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,pPWM_Channel->DUTY);
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  // add reading 'Resolution'
  if (affectedReadings & ESP32_I2C_Master_R_RESOLUTION) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Resolution");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,(1 << pPWM_Timer->RESOLUTION) );
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_I2C_Master_R_AV01_AV05_AV15) {
	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...
	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );
		}
	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );
		}
	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	
		}
	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Factor' //avf'
  if (affectedReadings & ESP32_I2C_Master_R_AVF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) ESP32_I2C_Master_Definition->IB01_AverageFactor	
		,(int) ( (ESP32_I2C_Master_Definition->IB01_AverageFactor -
		(int) ESP32_I2C_Master_Definition->IB01_AverageFactor) * 10000) );
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Unit' //avu'
  if (affectedReadings & ESP32_I2C_Master_R_AVU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_I2C_Master_Definition->IB01_AverageUnit);
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & ESP32_I2C_Master_R_ATF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor -
		(int) ESP32_I2C_Master_Definition->IB01_AlltimeTotalFactor) * 10000) );
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & ESP32_I2C_Master_R_ATU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_I2C_Master_Definition->IB01_AlltimeTotalUnit);
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------
/*
  // add reading 'Debounce' //deb'
  if (affectedReadings & ESP32_I2C_Master_R_DEB) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_I2C_Master_Definition->IB01_Debounce);
	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_I2C_Master_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
//  SCDEFn->readingsEndUpdateFn((Common_Definition_t*) ESP32_I2C_Master_Definition);


  return true;
}








/*

    For i2c master mode, we don't need to use a buffer for the data, the APIs will execute the master commands
and return after all of the commands have been sent out or when error occurs. So when we send master commands,
we should free or modify the source data only after the i2c_master_cmd_begin function returns.
    For i2c slave mode, we need a data buffer to stash the sending and receiving data, because the hardware fifo
has only 32 bytes.
*/
esp_err_t 
i2c_driver_install( i2c_port_t i2c_num,
	i2c_obj_t** pp_i2c_obj,
	i2c_mode_t mode,
	size_t slv_rx_buf_len,
	size_t slv_tx_buf_len,
	int intr_alloc_flags)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(mode == I2C_MODE_MASTER || ( slv_rx_buf_len > 100 || slv_tx_buf_len > 100 ),
	I2C_SLAVE_BUFFER_LEN_ERR_STR, ESP_ERR_INVALID_ARG);

  uint32_t intr_mask = 0;

  // i2c driver not initialized ?
  if (*pp_i2c_obj == NULL) {

	#if !CONFIG_SPIRAM_USE_MALLOC
        *pp_i2c_obj = (i2c_obj_t*) calloc(1, sizeof(i2c_obj_t));

	#else

	if( !(intr_alloc_flags & ESP_INTR_FLAG_IRAM) ) {

 		 *pp_i2c_obj = (i2c_obj_t*) calloc(1, sizeof(i2c_obj_t));

        } else {

		*pp_i2c_obj = (i2c_obj_t*) heap_caps_calloc(1,
			sizeof(i2c_obj_t), MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
        }
	#endif

        if ( *pp_i2c_obj == NULL ) {
 
		ESP_LOGE(I2C_TAG, I2C_DRIVER_MALLOC_ERR_STR);

		return ESP_FAIL;
	}

	// get the ptr to the allocated i2c obj
	i2c_obj_t* p_i2c = *pp_i2c_obj;

        p_i2c->i2c_num = i2c_num;
        p_i2c->mode = mode;
        p_i2c->cmd_idx = 0;
        p_i2c->rx_cnt = 0;
        p_i2c->status = I2C_STATUS_IDLE;

	#if CONFIG_SPIRAM_USE_MALLOC
        p_i2c->intr_alloc_flags = intr_alloc_flags;
	#endif

        p_i2c->rx_fifo_remain = I2C_FIFO_LEN;
        p_i2c->tx_fifo_remain = I2C_FIFO_LEN;

        if (mode == I2C_MODE_SLAVE) {

		//we only use ringbuffer for slave mode.
		if (slv_rx_buf_len > 0) {

                	p_i2c->rx_ring_buf = 
				xRingbufferCreate(slv_rx_buf_len, RINGBUF_TYPE_BYTEBUF);

			if (p_i2c->rx_ring_buf == NULL) {

				ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);

				goto err;
			}

			p_i2c->rx_buf_length = slv_rx_buf_len;

		} else {

			p_i2c->rx_ring_buf = NULL;
			p_i2c->rx_buf_length = 0;
		}

		if (slv_tx_buf_len > 0) {

			p_i2c->tx_ring_buf =
				xRingbufferCreate(slv_tx_buf_len, RINGBUF_TYPE_BYTEBUF);

			if (p_i2c->tx_ring_buf == NULL) {

				ESP_LOGE(I2C_TAG, I2C_BUF_ERR_STR);

				goto err;
			}

			p_i2c->tx_buf_length = slv_tx_buf_len;

		} else {

			p_i2c->tx_ring_buf = NULL;

			p_i2c->tx_buf_length = 0;

		}

 		p_i2c->slv_rx_mux = xSemaphoreCreateMutex();

		p_i2c->slv_tx_mux = xSemaphoreCreateMutex();

		if (p_i2c->slv_rx_mux == NULL || p_i2c->slv_tx_mux == NULL) {

			ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);

			goto err;
		}

		intr_mask |= ( I2C_RXFIFO_FULL_INT_ENA_M | I2C_TRANS_COMPLETE_INT_ENA_M);

	} else {

		// semaphore to sync sending process, because we only have 32 bytes for hardware fifo.
		p_i2c->cmd_mux = xSemaphoreCreateMutex();

		#if !CONFIG_SPIRAM_USE_MALLOC
		p_i2c->cmd_evt_queue = 
			xQueueCreate(I2C_EVT_QUEUE_LEN, sizeof(i2c_cmd_evt_t));

		#else
		if( !(intr_alloc_flags & ESP_INTR_FLAG_IRAM) ) {

			p_i2c->cmd_evt_queue = xQueueCreate(I2C_EVT_QUEUE_LEN, sizeof(i2c_cmd_evt_t));

		} else {

			_i2c->evt_queue_storage = 
				(uint8_t *)heap_caps_calloc(I2C_EVT_QUEUE_LEN,
				sizeof(i2c_cmd_evt_t),
				MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);

			if( p_i2c->evt_queue_storage == NULL ) {

				ESP_LOGE(I2C_TAG, I2C_DRIVER_MALLOC_ERR_STR);

				goto err;
  			}

			memset(&p_i2c->evt_queue_buffer, 0, sizeof(StaticQueue_t));

			p_i2c->cmd_evt_queue =  
				xQueueCreateStatic(I2C_EVT_QUEUE_LEN,
					sizeof(i2c_cmd_evt_t),
					p_i2c->evt_queue_storage,
					&p_i2c->evt_queue_buffer);
		}
		#endif

		if (p_i2c->cmd_mux == NULL || p_i2c->cmd_evt_queue == NULL) {

			ESP_LOGE(I2C_TAG, I2C_SEM_ERR_STR);

			goto err;
		}

		// command link
		p_i2c->cmd_link.cur = NULL;
		p_i2c->cmd_link.head = NULL;
		p_i2c->cmd_link.free = NULL;

		p_i2c->tx_ring_buf = NULL;
		p_i2c->rx_buf_length = 0;
		p_i2c->tx_ring_buf = NULL;
		p_i2c->tx_buf_length = 0;

		intr_mask |= I2C_ARBITRATION_LOST_INT_ENA_M | I2C_TIME_OUT_INT_ST_M;

	}

  // i2c driver already initialized !
  } else {

	ESP_LOGE(I2C_TAG, I2C_DRIVER_ERR_STR);

	return ESP_FAIL;
  }

  i2c_obj_t* p_i2c = *pp_i2c_obj;

  // hook isr handler
  i2c_isr_register(i2c_num,
	i2c_isr_handler_default,
	*pp_i2c_obj,
	intr_alloc_flags,
	&p_i2c->intr_handle);

  intr_mask |= ( I2C_TRANS_COMPLETE_INT_ENA_M |
		 I2C_TRANS_START_INT_ENA_M |
		 I2C_ACK_ERR_INT_ENA_M |
		 I2C_RXFIFO_OVF_INT_ENA_M |
		 I2C_SLAVE_TRAN_COMP_INT_ENA_M);

  I2C[i2c_num]->int_clr.val = intr_mask;

  I2C[i2c_num]->int_ena.val = intr_mask;

  return ESP_OK;


  err:

  // Some error has happened. Free/destroy all allocated things and return ESP_FAIL.
  if (*pp_i2c_obj) {

	// get the ptr to the allocated i2c obj
	i2c_obj_t* p_i2c = *pp_i2c_obj;

	if (p_i2c->rx_ring_buf) {

		vRingbufferDelete(p_i2c->rx_ring_buf);

		p_i2c->rx_ring_buf = NULL;

		p_i2c->rx_buf_length = 0;
	}

	if (p_i2c->tx_ring_buf) {

		vRingbufferDelete(p_i2c->tx_ring_buf);

		p_i2c->tx_ring_buf = NULL;

		p_i2c->tx_buf_length = 0;
	}

	if (p_i2c->cmd_evt_queue) {

		vQueueDelete(p_i2c->cmd_evt_queue);

		p_i2c->cmd_evt_queue = NULL;
	}

	if (p_i2c->cmd_mux) {

		vSemaphoreDelete(p_i2c->cmd_mux);
	}

	if (p_i2c->slv_rx_mux) {

		vSemaphoreDelete(p_i2c->slv_rx_mux);
	}

	if (p_i2c->slv_tx_mux) {

		vSemaphoreDelete(p_i2c->slv_tx_mux);
	}

	#if CONFIG_SPIRAM_USE_MALLOC
	if (p_i2c->evt_queue_storage) {

		free(p_i2c->evt_queue_storage);

 		p_i2c->evt_queue_storage = NULL;
	}
	#endif

  free(p_i2c);

  *pp_i2c_obj = NULL;

  }

  return ESP_FAIL;
}



static esp_err_t 
i2c_hw_enable(i2c_port_t i2c_num)
{
  if (i2c_num == I2C_NUM_0) {

	periph_module_enable(PERIPH_I2C0_MODULE);

  } else if (i2c_num == I2C_NUM_1) {

	periph_module_enable(PERIPH_I2C1_MODULE);
  }

  return ESP_OK;
}



static esp_err_t 
i2c_hw_disable(i2c_port_t i2c_num)
{
  if (i2c_num == I2C_NUM_0) {

	periph_module_disable(PERIPH_I2C0_MODULE);

  } else if (i2c_num == I2C_NUM_1) {

	periph_module_disable(PERIPH_I2C1_MODULE);
  }

  return ESP_OK;
}



esp_err_t 
i2c_driver_delete(i2c_obj_t** p_i2c_obj)
{
  // get the pointer to the i2c object
  i2c_obj_t* p_i2c = *p_i2c_obj;	// i2c_obj_t ptr, named p_i2c = read data from prt p_i2c_obj

  i2c_port_t i2c_num = p_i2c->i2c_num;

  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(p_i2c != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);

  I2C[i2c_num]->int_ena.val = 0;

  esp_intr_free(p_i2c->intr_handle);

  p_i2c->intr_handle = NULL;

  if (p_i2c->cmd_mux) {

	xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);

	vSemaphoreDelete(p_i2c->cmd_mux);
  }

  if (p_i2c->cmd_evt_queue) {

	vQueueDelete(p_i2c->cmd_evt_queue);

	p_i2c->cmd_evt_queue = NULL;
  }

  if (p_i2c->slv_rx_mux) {

	vSemaphoreDelete(p_i2c->slv_rx_mux);
  }

  if (p_i2c->slv_tx_mux) {

	vSemaphoreDelete(p_i2c->slv_tx_mux);
  }

  if (p_i2c->rx_ring_buf) {

	vRingbufferDelete(p_i2c->rx_ring_buf);

	p_i2c->rx_ring_buf = NULL;

	p_i2c->rx_buf_length = 0;
  }

  if (p_i2c->tx_ring_buf) {

	vRingbufferDelete(p_i2c->tx_ring_buf);

	p_i2c->tx_ring_buf = NULL;

	p_i2c->tx_buf_length = 0;
  }

  #if CONFIG_SPIRAM_USE_MALLOC
  if (p_i2c->evt_queue_storage) {

	free(p_i2c->evt_queue_storage);

	p_i2c->evt_queue_storage = NULL;
  }
  #endif

  // finally free the i2c object
  free(p_i2c);
  *p_i2c_obj = NULL;

  i2c_hw_disable(i2c_num);

  return ESP_OK;
}






/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_reset_tx_fifo
 *  Desc: Resets the hardware tx fifo
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_reset_tx_fifo(i2c_port_t i2c_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->fifo_conf.tx_fifo_rst = 1;

  I2C[i2c_num]->fifo_conf.tx_fifo_rst = 0;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_reset_rx_fifo
 *  Desc: Resets the hardware rx fifo 
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_reset_rx_fifo(i2c_port_t i2c_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->fifo_conf.rx_fifo_rst = 1;

  I2C[i2c_num]->fifo_conf.rx_fifo_rst = 0;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



static void IRAM_ATTR
i2c_isr_handler_default(void* arg)
{
/*  // we got ptr to ESP32_I2C_Master_Definition_t
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) arg;
  // create ptr to i2c_obj_t
  i2c_obj_t* p_i2c = &ESP32_I2C_Master_Definition->i2c_obj;
*/

  i2c_obj_t* p_i2c = (i2c_obj_t*) arg;

  int i2c_num = p_i2c->i2c_num;

  uint32_t status = I2C[i2c_num]->int_status.val;

  int idx = 0;

  portBASE_TYPE HPTaskAwoken = pdFALSE;

  while (status != 0) {

    status = I2C[i2c_num]->int_status.val;

    if (status & I2C_TX_SEND_EMPTY_INT_ST_M) {

      I2C[i2c_num]->int_clr.tx_send_empty = 1;

    } else if (status & I2C_RX_REC_FULL_INT_ST_M) {

      I2C[i2c_num]->int_clr.rx_rec_full = 1;

    } else if (status & I2C_ACK_ERR_INT_ST_M) {

      I2C[i2c_num]->int_clr.ack_err = 1;

      if (p_i2c->mode == I2C_MODE_MASTER) {

        p_i2c->status = I2C_STATUS_ACK_ERROR;

        I2C[i2c_num]->int_clr.ack_err = 1;

        //get error ack value from slave device, stop the commands
        i2c_master_cmd_begin_static(p_i2c);
      }

    } else if (status & I2C_TRANS_START_INT_ST_M) {

      I2C[i2c_num]->int_clr.trans_start = 1;

    } else if (status & I2C_TIME_OUT_INT_ST_M) {

      I2C[i2c_num]->int_clr.time_out = 1;

    } else if (status & I2C_TRANS_COMPLETE_INT_ST_M) {

      I2C[i2c_num]->int_clr.trans_complete = 1;

      if (p_i2c->mode == I2C_MODE_SLAVE) {

        int rx_fifo_cnt = I2C[i2c_num]->status_reg.rx_fifo_cnt;

        for (idx = 0; idx < rx_fifo_cnt; idx++) {

          p_i2c->data_buf[idx] = I2C[i2c_num]->fifo_data.data;
        }

        xRingbufferSendFromISR(p_i2c->rx_ring_buf
          ,p_i2c->data_buf
          ,rx_fifo_cnt
          ,&HPTaskAwoken);

        if (HPTaskAwoken == pdTRUE) {

          portYIELD_FROM_ISR();
        }

        I2C[i2c_num]->int_clr.rx_fifo_full = 1;

      } else {

        if (p_i2c->status != I2C_STATUS_ACK_ERROR) {

          i2c_master_cmd_begin_static(p_i2c);
        }
      }

    } else if (status & I2C_MASTER_TRAN_COMP_INT_ST_M) {

      I2C[i2c_num]->int_clr.master_tran_comp = 1;

    } else if (status & I2C_ARBITRATION_LOST_INT_ST_M) {

      I2C[i2c_num]->int_clr.arbitration_lost = 1;

    } else if (status & I2C_SLAVE_TRAN_COMP_INT_ST_M) {

      I2C[i2c_num]->int_clr.slave_tran_comp = 1;

    } else if (status & I2C_END_DETECT_INT_ST_M) {

      I2C[i2c_num]->int_ena.end_detect = 0;

      I2C[i2c_num]->int_clr.end_detect = 1;

      i2c_master_cmd_begin_static(p_i2c);

    } else if (status & I2C_RXFIFO_OVF_INT_ST_M) {

      I2C[i2c_num]->int_clr.rx_fifo_ovf = 1;

    } else if (status & I2C_TXFIFO_EMPTY_INT_ST_M) {

      int tx_fifo_rem = I2C_FIFO_LEN - 
        I2C[i2c_num]->status_reg.tx_fifo_cnt;

      size_t size = 0;

      uint8_t *data = (uint8_t*) xRingbufferReceiveUpToFromISR(p_i2c->tx_ring_buf
        ,&size
        ,tx_fifo_rem);

      if (data) {

        for (idx = 0; idx < size; idx++) {

          WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), data[idx]);
        }

        vRingbufferReturnItemFromISR(p_i2c->tx_ring_buf, data, &HPTaskAwoken);

          if (HPTaskAwoken == pdTRUE) {
            portYIELD_FROM_ISR();
          }

        I2C[i2c_num]->int_ena.tx_fifo_empty = 1;

        I2C[i2c_num]->int_clr.tx_fifo_empty = 1;

        } else {

      I2C[i2c_num]->int_ena.tx_fifo_empty = 0;

      I2C[i2c_num]->int_clr.tx_fifo_empty = 1;
    }

  } else if (status & I2C_RXFIFO_FULL_INT_ST_M) {

    int rx_fifo_cnt = I2C[i2c_num]->status_reg.rx_fifo_cnt;

    for (idx = 0; idx < rx_fifo_cnt; idx++) {

      p_i2c->data_buf[idx] = I2C[i2c_num]->fifo_data.data;
    }

    xRingbufferSendFromISR(p_i2c->rx_ring_buf, p_i2c->data_buf, rx_fifo_cnt, &HPTaskAwoken);

    if (HPTaskAwoken == pdTRUE) {

      portYIELD_FROM_ISR();
    }

    I2C[i2c_num]->int_clr.rx_fifo_full = 1;

    } else {

      I2C[i2c_num]->int_clr.val = status;
    }
  }
}



esp_err_t 
i2c_set_data_mode(i2c_port_t i2c_num, i2c_trans_mode_t tx_trans_mode, i2c_trans_mode_t rx_trans_mode)

{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(tx_trans_mode < I2C_DATA_MODE_MAX, I2C_TRANS_MODE_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(rx_trans_mode < I2C_DATA_MODE_MAX, I2C_TRANS_MODE_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->ctr.rx_lsb_first = rx_trans_mode; //set rx data msb first

  I2C[i2c_num]->ctr.tx_lsb_first = tx_trans_mode; //set tx data msb first

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t
i2c_get_data_mode(i2c_port_t i2c_num, i2c_trans_mode_t *tx_trans_mode, i2c_trans_mode_t *rx_trans_mode)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  if (tx_trans_mode) {

        *tx_trans_mode = I2C[i2c_num]->ctr.tx_lsb_first;
  }

  if (rx_trans_mode) {

        *rx_trans_mode = I2C[i2c_num]->ctr.rx_lsb_first;
  }

  return ESP_OK;
}



/* Some slave device will die by accident and keep the SDA in low level,
 * in this case, master should send several clock to make the slave release the bus.
 * Slave mode of ESP32 might also get in wrong state that held the SDA low,
 * in this case, master device could send a stop signal to make esp32 slave release the bus.
 **/
static esp_err_t 
i2c_master_clear_bus(i2c_port_t i2c_num)

{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  const int scl_half_period = I2C_CLR_BUS_HALF_PERIOD_US; // use standard 100kHz data rate

  int sda_in_sig = 0, scl_in_sig = 0;

  int i = 0;

  if (i2c_num == I2C_NUM_0) {

	sda_in_sig = I2CEXT0_SDA_IN_IDX;

	scl_in_sig = I2CEXT0_SCL_IN_IDX;

  } else if (i2c_num == I2C_NUM_1) {

	sda_in_sig = I2CEXT1_SDA_IN_IDX;

	scl_in_sig = I2CEXT1_SCL_IN_IDX;

  }

  int scl_io = GPIO.func_in_sel_cfg[scl_in_sig].func_sel;

  int sda_io = GPIO.func_in_sel_cfg[sda_in_sig].func_sel;

  I2C_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io)), I2C_SCL_IO_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(sda_io)), I2C_SDA_IO_ERR_STR, ESP_ERR_INVALID_ARG);

  gpio_set_direction(scl_io, GPIO_MODE_OUTPUT_OD);

  gpio_set_direction(sda_io, GPIO_MODE_INPUT_OUTPUT_OD);

  // If a SLAVE device was in a read operation when the bus was interrupted, the SLAVE device is controlling SDA.
  // The only bit during the 9 clock cycles of a READ byte the MASTER(ESP32) is guaranteed control over is during the ACK bit
  // period. If the slave is sending a stream of ZERO bytes, it will only release SDA during the ACK bit period.
  // So, this reset code needs to synchronize the bit stream with, Either, the ACK bit, Or a 1 bit to correctly generate

  // a STOP condition.
  gpio_set_level(scl_io, 0);

  gpio_set_level(sda_io, 1);

  ets_delay_us(scl_half_period);

  while(!gpio_get_level(sda_io) && (i++ < I2C_CLR_BUS_SCL_NUM)) {

	gpio_set_level(scl_io, 1);

	ets_delay_us(scl_half_period);

	gpio_set_level(scl_io, 0);

	ets_delay_us(scl_half_period);
  }

  gpio_set_level(sda_io,0); // setup for STOP

  gpio_set_level(scl_io,1);

  ets_delay_us(scl_half_period);

  gpio_set_level(sda_io, 1); // STOP, SDA low -> high while SCL is HIGH

  i2c_set_pin(i2c_num, sda_io, scl_io, 1, 1, I2C_MODE_MASTER);

  return ESP_OK;
}



/**if the power and SDA/SCL wires are in proper condition, everything works find with reading the slave.
 * If we remove the power supply for the slave during I2C is reading, or directly connect SDA or SCL to ground,
 * this would cause the I2C FSM get stuck in wrong state, all we can do is to reset the I2C hardware in this case.
 **/
static esp_err_t 
i2c_hw_fsm_reset(i2c_port_t i2c_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  uint32_t ctr              = I2C[i2c_num]->ctr.val;
  uint32_t fifo_conf        = I2C[i2c_num]->fifo_conf.val;
  uint32_t scl_low_period   = I2C[i2c_num]->scl_low_period.val;
  uint32_t scl_high_period  = I2C[i2c_num]->scl_high_period.val;
  uint32_t scl_start_hold   = I2C[i2c_num]->scl_start_hold.val;
  uint32_t scl_rstart_setup = I2C[i2c_num]->scl_rstart_setup.val;
  uint32_t scl_stop_hold    = I2C[i2c_num]->scl_stop_hold.val;
  uint32_t scl_stop_setup   = I2C[i2c_num]->scl_stop_setup.val;
  uint32_t sda_hold         = I2C[i2c_num]->sda_hold.val;
  uint32_t sda_sample       = I2C[i2c_num]->sda_sample.val;
  uint32_t timeout          = I2C[i2c_num]->timeout.val;
  uint32_t scl_filter_cfg   = I2C[i2c_num]->scl_filter_cfg.val;
  uint32_t sda_filter_cfg   = I2C[i2c_num]->sda_filter_cfg.val;
  uint32_t slave_addr       = I2C[i2c_num]->slave_addr.val;



  // to reset the I2C hw module, we need re-enable the hw

  i2c_hw_disable(i2c_num);
  i2c_master_clear_bus(i2c_num);
  i2c_hw_enable(i2c_num);

  I2C[i2c_num]->int_ena.val          = 0;
  I2C[i2c_num]->ctr.val              = ctr & (~I2C_TRANS_START_M);
  I2C[i2c_num]->fifo_conf.val        = fifo_conf;
  I2C[i2c_num]->scl_low_period.val   = scl_low_period;
  I2C[i2c_num]->scl_high_period.val  = scl_high_period;
  I2C[i2c_num]->scl_start_hold.val   = scl_start_hold;
  I2C[i2c_num]->scl_rstart_setup.val = scl_rstart_setup;
  I2C[i2c_num]->scl_stop_hold.val    = scl_stop_hold;
  I2C[i2c_num]->scl_stop_setup.val   = scl_stop_setup;
  I2C[i2c_num]->sda_hold.val         = sda_hold;
  I2C[i2c_num]->sda_sample.val       = sda_sample;
  I2C[i2c_num]->timeout.val          = timeout;
  I2C[i2c_num]->scl_filter_cfg.val   = scl_filter_cfg;
  I2C[i2c_num]->sda_filter_cfg.val   = sda_filter_cfg;

  uint32_t intr_mask = ( I2C_TRANS_COMPLETE_INT_ENA_M
                       | I2C_TRANS_START_INT_ENA_M
                       | I2C_ACK_ERR_INT_ENA_M
                       | I2C_RXFIFO_OVF_INT_ENA_M
                       | I2C_SLAVE_TRAN_COMP_INT_ENA_M
                       | I2C_TIME_OUT_INT_ENA_M);

  if (I2C[i2c_num]->ctr.ms_mode == I2C_MODE_SLAVE) {

	I2C[i2c_num]->slave_addr.val = slave_addr;

	intr_mask |= ( I2C_RXFIFO_FULL_INT_ENA_M | I2C_TRANS_COMPLETE_INT_ENA_M);

  } else {

	intr_mask |= I2C_ARBITRATION_LOST_INT_ENA_M;
  }

  I2C[i2c_num]->int_clr.val = intr_mask;

  I2C[i2c_num]->int_ena.val = intr_mask;

  return ESP_OK;
}








/** syncd
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_param_config
 *  Desc: Configures the i2c Hardware,
 *  Info: 
 *  Para: i2c_port_t i2c_num -> the number of i2c-HW to use
 *  const i2c_config_t *i2c_conf -> ptr to filled cfg-data
 *  Rets: strTextMultiple_t* -> SCDE_OK, or error txts - for log
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
i2c_param_config(i2c_port_t i2c_num
	,const i2c_config_t *i2c_conf)
{
  // start without error
  strTextMultiple_t* retMsg = SCDE_OK;

  SCDE_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR);
  SCDE_CHECK(i2c_conf != NULL, I2C_ADDR_ERROR_STR);
  SCDE_CHECK(i2c_conf->mode < I2C_MODE_MAX, I2C_MODE_ERR_STR);

  // config the GPIO-pin,
  retMsg = i2c_set_pin(i2c_num, i2c_conf->sda_io_num, i2c_conf->scl_io_num,
			i2c_conf->sda_pullup_en, i2c_conf->scl_pullup_en, i2c_conf->mode);
  // error during config ? return with MSG
  if (retMsg != SCDE_OK) {

	return retMsg;
  }

  // Reset+enable the I2C hardware in case there is a soft reboot.
  i2c_hw_disable(i2c_num);
  i2c_hw_enable(i2c_num);

  // ??
  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  // set rx data msb first
  I2C[i2c_num]->ctr.rx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

  // set tx data msb first
  I2C[i2c_num]->ctr.tx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

  // mode for master or slave
  I2C[i2c_num]->ctr.ms_mode = i2c_conf->mode;

  // set open-drain output mode
  I2C[i2c_num]->ctr.sda_force_out = 1;

  // set open-drain output mode
  I2C[i2c_num]->ctr.scl_force_out = 1;

  // sample at high level of clock
  I2C[i2c_num]->ctr.sample_scl_level = 0;

  // slave mode ?
  if (i2c_conf->mode == I2C_MODE_SLAVE) {

	I2C[i2c_num]->slave_addr.addr = i2c_conf->slave.slave_addr;
	I2C[i2c_num]->slave_addr.en_10bit = i2c_conf->slave.addr_10bit_en;
	I2C[i2c_num]->fifo_conf.nonfifo_en = 0;
	I2C[i2c_num]->fifo_conf.fifo_addr_cfg_en = 0;
	I2C[i2c_num]->fifo_conf.rx_fifo_full_thrhd = I2C_FIFO_FULL_THRESH_VAL;
	I2C[i2c_num]->fifo_conf.tx_fifo_empty_thrhd = I2C_FIFO_EMPTY_THRESH_VAL;
	I2C[i2c_num]->int_ena.rx_fifo_full = 1;
	I2C[i2c_num]->ctr.trans_start = 0;
	I2C[i2c_num]->timeout.tout = I2C_SLAVE_TIMEOUT_DEFAULT;

	//set timing for data
	I2C[i2c_num]->sda_hold.time = I2C_SLAVE_SDA_HOLD_DEFAULT;
	I2C[i2c_num]->sda_sample.time = I2C_SLAVE_SDA_SAMPLE_DEFAULT;
  }

  // master mode ?
  else {

	I2C[i2c_num]->fifo_conf.nonfifo_en = 0;

	int cycle = (I2C_APB_CLK_FREQ / i2c_conf->master.clk_speed);

	int half_cycle = cycle / 2;

	I2C[i2c_num]->timeout.tout = cycle * I2C_MASTER_TOUT_CNUM_DEFAULT;

	//set timing for data
	I2C[i2c_num]->sda_hold.time = half_cycle / 2;
	I2C[i2c_num]->sda_sample.time = half_cycle / 2;

	I2C[i2c_num]->scl_low_period.period = half_cycle;
	I2C[i2c_num]->scl_high_period.period = half_cycle;

	//set timing for start signal
	I2C[i2c_num]->scl_start_hold.time = half_cycle;
	I2C[i2c_num]->scl_rstart_setup.time = half_cycle;

	//set timing for stop signal
	I2C[i2c_num]->scl_stop_hold.time = half_cycle;
	I2C[i2c_num]->scl_stop_setup.time = half_cycle;

	//Default, we enable hardware filter

	i2c_filter_enable(i2c_num, I2C_FILTER_CYC_NUM_DEF);
  }

  // ???
  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return retMsg;
}



esp_err_t 
i2c_set_period(i2c_port_t i2c_num, int high_period, int low_period)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((high_period <= I2C_SCL_HIGH_PERIOD_V) && (high_period > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((low_period <= I2C_SCL_LOW_PERIOD_V) && (low_period > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->scl_high_period.period = high_period;

  I2C[i2c_num]->scl_low_period.period = low_period;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_get_period(i2c_port_t i2c_num, int* high_period, int* low_period)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  if (high_period) {

	*high_period = I2C[i2c_num]->scl_high_period.period;
  }

  if (low_period) {

	*low_period = I2C[i2c_num]->scl_low_period.period;
  }

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_filter_enable(i2c_port_t i2c_num, uint8_t cyc_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->scl_filter_cfg.thres = cyc_num;

  I2C[i2c_num]->sda_filter_cfg.thres = cyc_num;

  I2C[i2c_num]->scl_filter_cfg.en = 1;

  I2C[i2c_num]->sda_filter_cfg.en = 1;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_filter_disable(i2c_port_t i2c_num)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->scl_filter_cfg.en = 0;

  I2C[i2c_num]->sda_filter_cfg.en = 0;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_set_start_timing(i2c_port_t i2c_num, int setup_time, int hold_time)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((hold_time <= I2C_SCL_START_HOLD_TIME_V) && (hold_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((setup_time <= I2C_SCL_RSTART_SETUP_TIME_V) && (setup_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->scl_start_hold.time = hold_time;

  I2C[i2c_num]->scl_rstart_setup.time = setup_time;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_get_start_timing(i2c_port_t i2c_num, int* setup_time, int* hold_time)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  if (hold_time) {

	*hold_time = I2C[i2c_num]->scl_start_hold.time;
  }

  if (setup_time) {

	*setup_time = I2C[i2c_num]->scl_rstart_setup.time;
  }

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_set_stop_timing(i2c_port_t i2c_num, int setup_time, int hold_time)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((setup_time <= I2C_SCL_STOP_SETUP_TIME_V) && (setup_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((hold_time <= I2C_SCL_STOP_HOLD_TIME_V) && (hold_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->scl_stop_hold.time = hold_time;

  I2C[i2c_num]->scl_stop_setup.time = setup_time;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_get_stop_timing(i2c_port_t i2c_num, int* setup_time, int* hold_time)

{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  if (setup_time) {

	*setup_time = I2C[i2c_num]->scl_stop_setup.time;
  }

  if (hold_time) {

        *hold_time = I2C[i2c_num]->scl_stop_hold.time;
  }

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_set_data_timing(i2c_port_t i2c_num, int sample_time, int hold_time)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((sample_time <= I2C_SDA_SAMPLE_TIME_V) && (sample_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((hold_time <= I2C_SDA_HOLD_TIME_V) && (hold_time > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->sda_hold.time = hold_time;

  I2C[i2c_num]->sda_sample.time = sample_time;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_get_data_timing(i2c_port_t i2c_num, int* sample_time, int* hold_time)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  if (sample_time) {

	*sample_time = I2C[i2c_num]->sda_sample.time;
  }

  if (hold_time) {

	*hold_time = I2C[i2c_num]->sda_hold.time;
  }

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_set_timeout(i2c_port_t i2c_num, int timeout)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK((timeout <= I2C_TIME_OUT_REG_V) && (timeout > 0), I2C_TIMEING_VAL_ERR_STR, ESP_ERR_INVALID_ARG);

  I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

  I2C[i2c_num]->timeout.tout = timeout;

  I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

  return ESP_OK;
}



esp_err_t 
i2c_get_timeout(i2c_port_t i2c_num, int* timeout)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);

  if (timeout) {

	*timeout = I2C[i2c_num]->timeout.tout;

  }

  return ESP_OK;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_isr_register
 *  Desc: Registers the Interrupt for i2c  (2 available)
 *  Data: 
 *       i2c_port_t i2c_num
 *	 void (*fn)(void*)
 *	 void * arg
 *	 int intr_alloc_flags
 *	 intr_handle_t *handle -> the handle will be stored here
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_isr_register(i2c_port_t i2c_num
	,void (*fn)(void*)
	,void * arg
	,int intr_alloc_flags
	,intr_handle_t *handle)
{
  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(fn != NULL, I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);

  esp_err_t ret;

  switch (i2c_num) {

	case I2C_NUM_1:

		ret = esp_intr_alloc(ETS_I2C_EXT1_INTR_SOURCE, intr_alloc_flags, fn, arg, handle);

		break;

	case I2C_NUM_0:
	default:

		ret = esp_intr_alloc(ETS_I2C_EXT0_INTR_SOURCE, intr_alloc_flags, fn, arg, handle);

		break;
  }

  return ret;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: i2c_isr_free
 *  Desc: Unregisters the Interrupt for i2c
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_isr_free(intr_handle_t handle)
{
  return esp_intr_free(handle);
}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_set_pin
 *  Desc: Setup the i2c GPIO pin
 *  Info: 
 *  Para: i2c_obj_t *p_i2c -> ptr to the i2c processing object for this i2c num
 *        gpio_num_t sda_io_num -> 
 *        gpio_num_t scl_io_num -> 
 *        gpio_pullup_t sda_pullup_en -> 
 *        gpio_pullup_t scl_pullup_en -> 
 *        i2c_mode_t mode -> 
 *  Rets: strTextMultiple_t* -> SCDE_OK, or error txts - for log
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
i2c_set_pin(i2c_port_t i2c_num
			,gpio_num_t sda_io_num
			,gpio_num_t scl_io_num
			,gpio_pullup_t sda_pullup_en
			,gpio_pullup_t scl_pullup_en
			,i2c_mode_t mode)
{
  // start without error
  strTextMultiple_t* retMsg = SCDE_OK;

  SCDE_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR);
  SCDE_CHECK(((GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num))), I2C_SDA_IO_ERR_STR);
  SCDE_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
              (GPIO_IS_VALID_GPIO(scl_io_num) && mode == I2C_MODE_SLAVE),
              I2C_SCL_IO_ERR_STR);
  SCDE_CHECK((sda_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num)) ||
               sda_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
  SCDE_CHECK((scl_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
               scl_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);

  int sda_in_sig, sda_out_sig, scl_in_sig, scl_out_sig;

  // prepare the i2c settings according to used hardware 
  switch (i2c_num) {

	case I2C_NUM_1:
		sda_out_sig = I2CEXT1_SDA_OUT_IDX;
		sda_in_sig = I2CEXT1_SDA_IN_IDX;
		scl_out_sig = I2CEXT1_SCL_OUT_IDX;
		scl_in_sig = I2CEXT1_SCL_IN_IDX;
		break;

	case I2C_NUM_0:
		default:
		sda_out_sig = I2CEXT0_SDA_OUT_IDX;
		sda_in_sig = I2CEXT0_SDA_IN_IDX;
		scl_out_sig = I2CEXT0_SCL_OUT_IDX;
		scl_in_sig = I2CEXT0_SCL_IN_IDX;
		break;
  }

  if (sda_io_num >= 0) {

	gpio_set_level(sda_io_num, I2C_IO_INIT_LEVEL);

	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[sda_io_num], PIN_FUNC_GPIO);

	gpio_set_direction(sda_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

	if (sda_pullup_en == GPIO_PULLUP_ENABLE) {

		gpio_set_pull_mode(sda_io_num, GPIO_PULLUP_ONLY);
        } 

	else {

		gpio_set_pull_mode(sda_io_num, GPIO_FLOATING);
        }

	gpio_matrix_out(sda_io_num, sda_out_sig, 0, 0);

	gpio_matrix_in(sda_io_num, sda_in_sig, 0);
  }

  if (scl_io_num >= 0) {

	gpio_set_level(scl_io_num, I2C_IO_INIT_LEVEL);

	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[scl_io_num], PIN_FUNC_GPIO);

	if (mode == I2C_MODE_MASTER) {

		gpio_set_direction(scl_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

		gpio_matrix_out(scl_io_num, scl_out_sig, 0, 0);
	}

	else {

		gpio_set_direction(scl_io_num, GPIO_MODE_INPUT);
	}

	if (scl_pullup_en == GPIO_PULLUP_ENABLE) {

		gpio_set_pull_mode(scl_io_num, GPIO_PULLUP_ONLY);
	}

	else {

		gpio_set_pull_mode(scl_io_num, GPIO_FLOATING);
	}

	gpio_matrix_in(scl_io_num, scl_in_sig, 0);
  }

  return retMsg;
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_cmd_link_create
 *  Desc: Allocates a linked list head - without elements 
 *  Info: calloc -> zero filled
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *  Rets: i2c_cmd_desc_t* as void* i2c_cmd_handle_t
 * -------------------------------------------------------------------------------------------------
 */
i2c_cmd_handle_t
i2c_cmd_link_create()
{
  #if !CONFIG_SPIRAM_USE_MALLOC
  i2c_cmd_desc_t* cmd_desc = (i2c_cmd_desc_t*) calloc(1, sizeof(i2c_cmd_desc_t));
  #else
  i2c_cmd_desc_t* cmd_desc = (i2c_cmd_desc_t*) heap_caps_calloc(1, sizeof(i2c_cmd_desc_t), MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
  #endif

  return (i2c_cmd_handle_t) cmd_desc;
}



/** to stage 2 module!??
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_cmd_link_delete
 *  Desc: Frees linked list: All linked list elements + head
 *  Info: 
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *  Rets: -/-
 * -------------------------------------------------------------------------------------------------
 */
void
i2c_cmd_link_delete(i2c_cmd_handle_t cmd_handle)
{
  // is it a valid handle ?
  if (cmd_handle == NULL) {

	return;
  }

  // get ptr to linked list head 
  i2c_cmd_desc_t *cmd = (i2c_cmd_desc_t*) cmd_handle;

  // loop throug the linked list elements and free them
  while (cmd->free) {

	i2c_cmd_link_t* ptmp = cmd->free;

	cmd->free = cmd->free->next;

	free(ptmp);
  }

  // makes no sense? its freed...
  cmd->cur = NULL;
  cmd->free = NULL;
  cmd->head = NULL;

  // free the head of the linked list
  free(cmd_handle);

  return;
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_cmd_link_append
 *  Desc: Append to linked list: Adds a command i2c_cmd_t at the given ptr to the linked i2c cmd list
 *  Info: 
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *        i2c_cmd_t* cmd -> ptr to the cmd data (data will be copied to allocated memory)
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
static esp_err_t
i2c_cmd_link_append(i2c_cmd_handle_t cmd_handle,
	i2c_cmd_t *cmd)
{
  // get ptr to linked list head 
  i2c_cmd_desc_t* cmd_desc = (i2c_cmd_desc_t*) cmd_handle;

  // is this the first element? (new list)
  if (cmd_desc->head == NULL) {

	#if !CONFIG_SPIRAM_USE_MALLOC
        cmd_desc->head = (i2c_cmd_link_t*) calloc(1, sizeof(i2c_cmd_link_t));
	#else
        cmd_desc->head = (i2c_cmd_link_t*) heap_caps_calloc(1, sizeof(i2c_cmd_link_t), MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
	#endif

	// alloc error
	if (cmd_desc->head == NULL) {

		ESP_LOGE(I2C_TAG, I2C_CMD_MALLOC_ERR_STR);

		goto err;
	}

	// initialize - the first -
	cmd_desc->cur = cmd_desc->head;
	cmd_desc->free = cmd_desc->head;

	// there are already elements in the linked list ..
  } else {

	#if !CONFIG_SPIRAM_USE_MALLOC
        cmd_desc->cur->next = (i2c_cmd_link_t*) calloc(1, sizeof(i2c_cmd_link_t));
	#else
        cmd_desc->cur->next = (i2c_cmd_link_t*) heap_caps_calloc(1, sizeof(i2c_cmd_link_t), MALLOC_CAP_INTERNAL|MALLOC_CAP_8BIT);
	#endif

	// alloc error
	if (cmd_desc->cur->next == NULL) {

		ESP_LOGE(I2C_TAG, I2C_CMD_MALLOC_ERR_STR);

		goto err;
	}

	// update new last list element in head
	cmd_desc->cur = cmd_desc->cur->next;
  }

  // now copy the i2c command data to allocated memory
  memcpy((uint8_t*) &cmd_desc->cur->cmd, (uint8_t*) cmd, sizeof(i2c_cmd_t));

  // and initialize the next field in this list element
  cmd_desc->cur->next = NULL;

  return ESP_OK;

  err:

  return ESP_FAIL;
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_start
 *  Desc: Append to linked list: initial start cmd with cmd.op_code = I2C_CMD_START 
 *  Info: This should be first element in a i2c cmd linked list
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_master_start(i2c_cmd_handle_t cmd_handle)
{
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 0;
  cmd.data = NULL;
  cmd.op_code = I2C_CMD_RESTART;

  return i2c_cmd_link_append(cmd_handle, &cmd);
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_stop
 *  Desc: Append to linked list: final stop cmd with cmd.op_code = I2C_CMD_STOP 
 *  Info: This should finalize a i2c cmd linked list
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t
i2c_master_stop(i2c_cmd_handle_t cmd_handle)
{
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 0;
  cmd.data = NULL;
  cmd.op_code = I2C_CMD_STOP;

  return i2c_cmd_link_append(cmd_handle, &cmd);
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_write
 *  Desc: append to linked list: write len bytes from source ptr to master cmd with 
 *        cmd.op_code = I2C_CMD_WRITE
 *  Info:
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *        uint8_t* data -> source ptr to bytes to write
 *        size_t data_len -> number of bytes to write
 *        bool ack_en ->
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_master_write(i2c_cmd_handle_t cmd_handle,
	uint8_t *data,
	size_t data_len,
	bool ack_en)
{
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  uint8_t len_tmp;

  int data_offset = 0;

  esp_err_t ret;

  while (data_len > 0) {

    len_tmp = data_len > 0xff ? 0xff : data_len;
    data_len -= len_tmp;

    i2c_cmd_t cmd;

    cmd.ack_en = ack_en;
    cmd.ack_exp = 0;
    cmd.ack_val = 0;
    cmd.byte_num = len_tmp;
    cmd.op_code = I2C_CMD_WRITE;
    cmd.data = data + data_offset;

    ret = i2c_cmd_link_append(cmd_handle, &cmd);

    data_offset += len_tmp;

    if (ret != ESP_OK) {

      return ret;
    }
  }

  return ESP_OK;
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_write_byte
 *  Desc: append to linked list: write the given byte to master cmd with cmd.op_code = I2C_CMD_WRITE
 *  Info:
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *        uint8_t data -> the byte to write
 *        bool ack_en ->
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_master_write_byte(i2c_cmd_handle_t cmd_handle,
	uint8_t data,
	bool ack_en)
{
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = ack_en;
  cmd.ack_exp = 0;
  cmd.ack_val = 0;
  cmd.byte_num = 1;
  cmd.op_code = I2C_CMD_WRITE;
  cmd.data = NULL;
  cmd.byte_cmd = data;

  return i2c_cmd_link_append(cmd_handle, &cmd);
}



static esp_err_t 
i2c_master_read_static(i2c_cmd_handle_t cmd_handle, uint8_t* data,
	size_t data_len,
	i2c_ack_type_t ack)
{
  int len_tmp;
  int data_offset = 0;
  esp_err_t ret;

  while (data_len > 0) {

	len_tmp = data_len > 0xff ? 0xff : data_len;
	data_len -= len_tmp;
	i2c_cmd_t cmd;
	cmd.ack_en = 0;
	cmd.ack_exp = 0;
	cmd.ack_val = ack & 0x1;
	cmd.byte_num = len_tmp;
	cmd.op_code = I2C_CMD_READ;
	cmd.data = data + data_offset;

	ret = i2c_cmd_link_append(cmd_handle, &cmd);

	data_offset += len_tmp;

	if (ret != ESP_OK) {

		return ret;
	}
  }

  return ESP_OK;
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_read_byte
 *  Desc: Append to linked list: Operation "Read one byte from master"
 *        - build operation "read one byte from master via cmd.op_code = I2C_CMD_READ"
 *          to the data destination adress
 *        - append this operation to linked list
 *  Info:
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *        uint8_t* data -> destination ptr for the byte to read
 *        i2c_ack_type_t ack ->
 *  Rets: esp_err_t -> from "i2c_cmd_link_append" FN
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t
i2c_master_read_byte(i2c_cmd_handle_t cmd_handle
	,uint8_t *data
	,i2c_ack_type_t ack)
{
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(ack < I2C_MASTER_ACK_MAX, I2C_ACK_TYPE_ERR_STR, ESP_ERR_INVALID_ARG);

  i2c_cmd_t cmd;

  cmd.ack_en = 0;
  cmd.ack_exp = 0;
  cmd.ack_val = ((ack == I2C_MASTER_LAST_NACK) ? I2C_MASTER_NACK : (ack & 0x1));
  cmd.byte_num = 1;
  cmd.op_code = I2C_CMD_READ;
  cmd.data = data;

  return i2c_cmd_link_append(cmd_handle, &cmd);
}



/** to stage 2 module!
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_read
 *  Desc: append to linked list: read len bytes from master cmd with cmd.op_code = I2C_CMD_READ
 *        to the data destinstion adress
 *  Info:
 *  Para: i2c_cmd_handle_t cmd_handle -> head of linked list - i2c commands
 *        uint8_t* data -> ptr to the bytes to write
 *        size_t data_len -> no. of bytes to write
 *        int ack ->
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t 
i2c_master_read(i2c_cmd_handle_t cmd_handle
	,uint8_t *data
	,size_t data_len
	,i2c_ack_type_t ack)
{
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(ack < I2C_MASTER_ACK_MAX, I2C_ACK_TYPE_ERR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(data_len > 0, I2C_DATA_LEN_ERR_STR, ESP_ERR_INVALID_ARG);

  if(ack != I2C_MASTER_LAST_NACK) {

	return i2c_master_read_static(cmd_handle, data, data_len, ack);

  } else {

	if(data_len == 1) {

		return i2c_master_read_byte(cmd_handle, data, I2C_MASTER_NACK);

	} else {

		esp_err_t ret;

		if ((ret =  i2c_master_read_static(cmd_handle, data, data_len - 1, I2C_MASTER_ACK)) != ESP_OK) {

                	return ret;

		}

		return i2c_master_read_byte(cmd_handle, data + data_len - 1, I2C_MASTER_NACK);
	}
  }
}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_cmd_begin_static
 *  Desc: 
 *  Info: RUNS IN INTERRUPT !
 *  Para: i2c_obj_t *p_i2c -> ptr to the i2c processing object for this i2c num
 *  Rets: void
 * -------------------------------------------------------------------------------------------------
 */
static void IRAM_ATTR 
i2c_master_cmd_begin_static(i2c_obj_t* p_i2c)
{
  // get the assigned i2c num.
  int i2c_num = p_i2c->i2c_num;

  portBASE_TYPE HPTaskAwoken = pdFALSE;

  i2c_cmd_evt_t evt;

  //This should never happen
  if (p_i2c->mode == I2C_MODE_SLAVE) {

	return;
  }

  if (p_i2c->status == I2C_STATUS_DONE) {
	return;
  } else if ((p_i2c->status == I2C_STATUS_ACK_ERROR)
		|| (p_i2c->status == I2C_STATUS_TIMEOUT)) {

	I2C[i2c_num]->int_ena.end_detect = 0;
	I2C[i2c_num]->int_clr.end_detect = 1;

	if(p_i2c->status == I2C_STATUS_TIMEOUT) {
		I2C[i2c_num]->int_clr.time_out = 1;
		I2C[i2c_num]->int_ena.val = 0;
	}

	evt.type = I2C_CMD_EVT_DONE;
	xQueueOverwriteFromISR(p_i2c->cmd_evt_queue, &evt, &HPTaskAwoken);

	if (HPTaskAwoken == pdTRUE) {

		portYIELD_FROM_ISR();
	}

	return;

  } else if (p_i2c->cmd_link.head != NULL && p_i2c->status == I2C_STATUS_READ) {

	i2c_cmd_t *cmd = &p_i2c->cmd_link.head->cmd;

	while (p_i2c->rx_cnt-- > 0) {

		*cmd->data++ = READ_PERI_REG(I2C_DATA_APB_REG(i2c_num));
	}

	if (cmd->byte_num > 0) {

		p_i2c->rx_fifo_remain = I2C_FIFO_LEN;
		p_i2c->cmd_idx = 0;

	} else {

		p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;
	}
  }

  if (p_i2c->cmd_link.head == NULL) {
        p_i2c->cmd_link.cur = NULL;
        evt.type = I2C_CMD_EVT_DONE;
        xQueueOverwriteFromISR(p_i2c->cmd_evt_queue, &evt, &HPTaskAwoken);
        if (HPTaskAwoken == pdTRUE) {
            portYIELD_FROM_ISR();
        }
        // Return to the IDLE status after cmd_eve_done signal were send out.
        p_i2c->status = I2C_STATUS_IDLE;
        return;
	}

	while (p_i2c->cmd_link.head) {

		i2c_cmd_t *cmd = &p_i2c->cmd_link.head->cmd;

		I2C[i2c_num]->command[p_i2c->cmd_idx].val = 0;
		I2C[i2c_num]->command[p_i2c->cmd_idx].ack_en = cmd->ack_en;
		I2C[i2c_num]->command[p_i2c->cmd_idx].ack_exp = cmd->ack_exp;
		I2C[i2c_num]->command[p_i2c->cmd_idx].ack_val = cmd->ack_val;
		I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = cmd->byte_num;
		I2C[i2c_num]->command[p_i2c->cmd_idx].op_code = cmd->op_code;

		if (cmd->op_code == I2C_CMD_WRITE) {
			uint32_t wr_filled = 0;

		//TODO: to reduce interrupt number
		if (cmd->data) {
			while (p_i2c->tx_fifo_remain > 0 && cmd->byte_num > 0) {
				WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), *cmd->data++);
				p_i2c->tx_fifo_remain--;
				cmd->byte_num--;
				wr_filled++;
			}
		} else {
			WRITE_PERI_REG(I2C_DATA_APB_REG(i2c_num), cmd->byte_cmd);
			p_i2c->tx_fifo_remain--;
			cmd->byte_num--;
			wr_filled ++;
		}
		// Workaround for register field operation.
		I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = wr_filled;
		I2C[i2c_num]->command[p_i2c->cmd_idx + 1].val = 0;
		I2C[i2c_num]->command[p_i2c->cmd_idx + 1].op_code = I2C_CMD_END;
		p_i2c->tx_fifo_remain = I2C_FIFO_LEN;
		p_i2c->cmd_idx = 0;

		if (cmd->byte_num > 0) {

		} else {

			p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;
		}

		p_i2c->status = I2C_STATUS_WRITE;

		break;

	} else if (cmd->op_code == I2C_CMD_READ) {

		//TODO: to reduce interrupt number
		p_i2c->rx_cnt = 
			cmd->byte_num > p_i2c->rx_fifo_remain ? p_i2c->rx_fifo_remain : cmd->byte_num;

		cmd->byte_num -= p_i2c->rx_cnt;
		I2C[i2c_num]->command[p_i2c->cmd_idx].byte_num = p_i2c->rx_cnt;
		I2C[i2c_num]->command[p_i2c->cmd_idx].ack_val = cmd->ack_val;
		I2C[i2c_num]->command[p_i2c->cmd_idx + 1].val = 0;
		I2C[i2c_num]->command[p_i2c->cmd_idx + 1].op_code = I2C_CMD_END;
		p_i2c->status = I2C_STATUS_READ;
		break;

	} else {
	}

	p_i2c->cmd_idx++;

	p_i2c->cmd_link.head = p_i2c->cmd_link.head->next;

	if (p_i2c->cmd_link.head == NULL || p_i2c->cmd_idx >= 15) {

		p_i2c->tx_fifo_remain = I2C_FIFO_LEN;

		p_i2c->cmd_idx = 0;

		break;
	}
  }

  I2C[i2c_num]->int_clr.end_detect = 1;
  I2C[i2c_num]->int_ena.end_detect = 1;
  I2C[i2c_num]->ctr.trans_start = 0;
  I2C[i2c_num]->ctr.trans_start = 1;

  return;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: i2c_master_cmd_begin
 *  Desc: Starts the processing of the i2c command linked list. Will continue in interrupt
 *  Info: NOT called from interrupt
 *  Para: i2c_obj_t *p_i2c -> ptr to the i2c processing object for this i2c num
 *        i2c_cmd_handle_t cmd_handle -> head of linked list that stores the i2c commands
 *        portBASE_TYPE ticks_to_wait -> ???
 *  Rets: esp_err_t ->
 * -------------------------------------------------------------------------------------------------
 */
esp_err_t
i2c_master_cmd_begin(i2c_obj_t *p_i2c,
	i2c_cmd_handle_t cmd_handle,
	TickType_t ticks_to_wait)
{
  // get the assigned i2c num.
  int i2c_num = p_i2c->i2c_num;

  I2C_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
  I2C_CHECK(p_i2c != NULL, I2C_DRIVER_NOT_INSTALL_ERR_STR, ESP_ERR_INVALID_STATE);
  I2C_CHECK(p_i2c->mode == I2C_MODE_MASTER, I2C_MASTER_MODE_ERR_STR, ESP_ERR_INVALID_STATE);
  I2C_CHECK(cmd_handle != NULL, I2C_CMD_LINK_INIT_ERR_STR, ESP_ERR_INVALID_ARG);

  #if CONFIG_SPIRAM_USE_MALLOC
  //If the i2c read or write buffer is not in internal RAM, we will return ESP_FAIL
  //to avoid the ISR handler function crashing when the cache is disabled.

  if( (p_i2c_obj[i2c_num]->intr_alloc_flags & ESP_INTR_FLAG_IRAM) ) {

	if( !is_cmd_link_buffer_internal(((i2c_cmd_desc_t*)cmd_handle)->head) ) {

		ESP_LOGE(I2C_TAG, I2C_PSRAM_BUFFER_WARN_STR);

		return ESP_ERR_INVALID_ARG;
	}
  }
  #endif

  // Sometimes when the FSM get stuck, the ACK_ERR interrupt will occur endlessly until we reset the FSM and clear bus.
  static uint8_t clear_bus_cnt = 0;

  esp_err_t ret = ESP_FAIL;

  portTickType ticks_start = xTaskGetTickCount();

  portBASE_TYPE res = xSemaphoreTake(p_i2c->cmd_mux, ticks_to_wait);

  if (res == pdFALSE) {

	return ESP_ERR_TIMEOUT;
  }

  xQueueReset(p_i2c->cmd_evt_queue);

  if (p_i2c->status == I2C_STATUS_TIMEOUT
	|| I2C[i2c_num]->status_reg.bus_busy == 1) {

	i2c_hw_fsm_reset(i2c_num);

	clear_bus_cnt = 0;
  }

  i2c_reset_tx_fifo(i2c_num);
  i2c_reset_rx_fifo(i2c_num);

  i2c_cmd_desc_t* cmd = (i2c_cmd_desc_t*) cmd_handle;

  p_i2c->cmd_link.free = cmd->free;
  p_i2c->cmd_link.cur = cmd->cur;
  p_i2c->cmd_link.head = cmd->head;
  p_i2c->status = I2C_STATUS_IDLE;
  p_i2c->cmd_idx = 0;
  p_i2c->rx_cnt = 0;

  p_i2c->tx_fifo_remain = I2C_FIFO_LEN;
  p_i2c->rx_fifo_remain = I2C_FIFO_LEN;

  i2c_reset_tx_fifo(i2c_num);
  i2c_reset_rx_fifo(i2c_num);

  // These two interrupts some times can not be cleared when the FSM gets stuck.
  // so we disable them when these two interrupt occurs and re-enable them here.
  I2C[i2c_num]->int_ena.ack_err = 1;
  I2C[i2c_num]->int_ena.time_out = 1;

  //start send commands, at most 32 bytes one time, isr handler will process the remaining commands.
  i2c_master_cmd_begin_static(p_i2c);

  // Wait event bits
  i2c_cmd_evt_t evt;

  while (1) {

	TickType_t wait_time = xTaskGetTickCount();

	if (wait_time - ticks_start > ticks_to_wait) { // out of time

		wait_time = I2C_CMD_ALIVE_INTERVAL_TICK;

	} else {

		wait_time = ticks_to_wait - (wait_time - ticks_start);

		if (wait_time < I2C_CMD_ALIVE_INTERVAL_TICK) {

			wait_time = I2C_CMD_ALIVE_INTERVAL_TICK;
		}
	}

	// In master mode, since we don't have an interrupt to detective bus error or FSM state, what we do here is to make
	// sure the interrupt mechanism for master mode is still working.
	// If the command sending is not finished and there is no interrupt any more, the bus is probably dead caused by external noise.
	portBASE_TYPE evt_res = xQueueReceive(p_i2c->cmd_evt_queue, &evt, wait_time);

	if (evt_res == pdTRUE) {

		if (evt.type == I2C_CMD_EVT_DONE) {

			if (p_i2c->status == I2C_STATUS_TIMEOUT) {

 				// If the I2C slave are powered off or the SDA/SCL are connected to ground, for example,
				// I2C hw FSM would get stuck in wrong state, we have to reset the I2C module in this case.
				i2c_hw_fsm_reset(i2c_num);

				clear_bus_cnt = 0;

				ret = ESP_ERR_TIMEOUT;

			} else if (p_i2c->status == I2C_STATUS_ACK_ERROR) {

				clear_bus_cnt++;

				if(clear_bus_cnt >= I2C_ACKERR_CNT_MAX) {

					i2c_master_clear_bus(i2c_num);

					clear_bus_cnt = 0;
				}

			ret = ESP_FAIL;

			} else {

				ret = ESP_OK;
			}

			break;
		}

		if (evt.type == I2C_CMD_EVT_ALIVE) {

		}

	} else {

	ret = ESP_ERR_TIMEOUT;

	// If the I2C slave are powered off or the SDA/SCL are connected to ground, for example,
	// I2C hw FSM would get stuck in wrong state, we have to reset the I2C module in this case.
	i2c_hw_fsm_reset(i2c_num);

	clear_bus_cnt = 0;

	break;
	}
  }

  p_i2c->status = I2C_STATUS_DONE;

  xSemaphoreGive(p_i2c->cmd_mux);

  return ret;
}



int 
i2c_slave_write_buffer(i2c_obj_t *p_i2c,
	uint8_t* data,
	int size,
	TickType_t ticks_to_wait)

{
  i2c_port_t i2c_num = p_i2c->i2c_num;

  I2C_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR, ESP_FAIL);
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_FAIL);
  I2C_CHECK(p_i2c->mode == I2C_MODE_SLAVE, I2C_MODE_SLAVE_ERR_STR, ESP_FAIL);

  portBASE_TYPE res;

  int cnt = 0;

  portTickType ticks_end = xTaskGetTickCount() + ticks_to_wait;

  res = xSemaphoreTake(p_i2c->slv_tx_mux, ticks_to_wait);

  if (res == pdFALSE) {

	return 0;
  }

  ticks_to_wait = ticks_end - xTaskGetTickCount();

  res = xRingbufferSend(p_i2c->tx_ring_buf, data, size, ticks_to_wait);

  if (res == pdFALSE) {

	cnt = 0;

  } else {

	I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

	I2C[i2c_num]->int_clr.tx_fifo_empty = 1;

	I2C[i2c_num]->int_ena.tx_fifo_empty = 1;

	I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

	cnt = size;
  }

  xSemaphoreGive(p_i2c->slv_tx_mux);

  return cnt;
}



static 
int i2c_slave_read(i2c_obj_t* p_i2c,
	uint8_t* data,
	size_t max_size,
	TickType_t ticks_to_wait)

{
  i2c_port_t i2c_num = p_i2c->i2c_num;

  size_t size = 0;

  uint8_t* pdata = (uint8_t*) xRingbufferReceiveUpTo(p_i2c->rx_ring_buf, &size, ticks_to_wait, max_size);

  if (pdata && size > 0) {

	memcpy(data, pdata, size);

	vRingbufferReturnItem(p_i2c->rx_ring_buf, pdata);
  }

  return size;
}



int 
i2c_slave_read_buffer(i2c_obj_t* p_i2c,
	uint8_t* data,
	size_t max_size,
	TickType_t ticks_to_wait)
{
  i2c_port_t i2c_num = p_i2c->i2c_num;

  I2C_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR, ESP_FAIL);
  I2C_CHECK((data != NULL), I2C_ADDR_ERROR_STR, ESP_FAIL);
  I2C_CHECK(p_i2c->mode == I2C_MODE_SLAVE, I2C_MODE_SLAVE_ERR_STR, ESP_FAIL);

  portBASE_TYPE res;

  portTickType ticks_end = xTaskGetTickCount() + ticks_to_wait;

  res = xSemaphoreTake(p_i2c->slv_rx_mux, ticks_to_wait);

  if (res == pdFALSE) {

	return 0;
  }

  ticks_to_wait = ticks_end - xTaskGetTickCount();

  int cnt = i2c_slave_read(p_i2c, data, max_size, ticks_to_wait);

  if (cnt > 0) {

	I2C_ENTER_CRITICAL(&i2c_spinlock[i2c_num]);

	I2C[i2c_num]->int_ena.rx_fifo_full = 1;

	I2C_EXIT_CRITICAL(&i2c_spinlock[i2c_num]);

	ticks_to_wait = ticks_end - xTaskGetTickCount();

	if (cnt < max_size && ticks_to_wait > 0) {

		cnt += i2c_slave_read(p_i2c, data + cnt, max_size - cnt, ticks_to_wait);
		}

	} else {

	cnt = 0;

  }

  xSemaphoreGive(p_i2c->slv_rx_mux);

  return cnt;
}




