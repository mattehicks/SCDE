/* #################################################################################################
 *
 *  Function: ESP32_S0 Module for SCDE (Smart Connected Device Engine)
 *
 *  ESP 8266EX & ESP32 SOC Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 */

/*
USAGE for S0 Counter, counting when low:
define S0.1.at.GPIO.16 esp32_S0 Pulse_CH0_GPIO=16&UNIT=0&CH0_POS_MODE=no_effect&CH0_NEG_MODE=inc_counter&CH0_HCTRL_MODE=no_modification&CH0_LCTRL_MODE=no_modification&THR_L_LIM_EN=Disabled&THR_H_LIM_EN=Disabled&THR_ZERO_EN=Disabled&THR_THRES0_EN=Disabled&THR_THRES1_EN=Disabled&FILTER_EN=Enabled&FILTER_THRES=500
define S0.1.at.GPIO.16 FILTER_THRES=5000
set myS0 CH1_POS_MODE=no_effect
set myS0 CH1_NEG_MODE=inc_counter
set myS0 CH1_HCTRL_MODE=no_modification
set myS0 CH1_LCTRL_MODE=no_modification
*/


/* DONT FORGET THE PAUSE BIT & START COUNTING BIT!!!

  uint32_t *pX_REG =
	(uint32_t*) 0x3FF570B0;

  // config counter -> NOT paused + NOT in reset state
  *pX_REG &= (~(0b11<<(ESP32_S0_Definition->unit * 2)));

*/

#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>

#include <SCDE_s.h>

#include "ESP32_S0_Module.h"

#include "SCDE_Main.h"



// we are using the hardware counter
#include "soc/pcnt_reg.h"
#include "soc/pcnt_struct.h"


#include "driver/gpio.h"






//???
#include "driver/periph_ctrl.h"
#include "driver/gpio.h"
//#include "driver/pcnt.h"
#include "esp_attr.h"
#include "esp_log.h"
#include "soc/gpio_sig_map.h"




// -------------------------------------------------------------------------------------------------

// ammount of debug information 0 = off 5 max?
#ifndef ESP32_S0_DBG
#define ESP32_S0_DBG 0
#endif

// -------------------------------------------------------------------------------------------------

// make data root locally available
static SCDERoot_t* SCDERoot;

// make locally available from data-root: the SCDEFn (Functions / callbacks) for operation
static SCDEFn_t* SCDEFn;

// -------------------------------------------------------------------------------------------------

#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------

 

/*
 * Implemented Values for Keys
 */

// ESP32_S0_SET_THR_THRES1_EN -> 'THR_THRES1_EN' -> DIS/ENA
// ESP32_S0_SET_THR_THRES0_EN -> 'THR_THRES0_EN' -> DIS/ENA
// ESP32_S0_SET_THR_L_LIM_EN -> 'THR_L_LIM_EN' -> DIS/ENA
// ESP32_S0_SET_THR_H_LIM_EN -> 'THR_H_LIM_EN' -> DIS/ENA
// ESP32_S0_SET_THR_ZERO_EN -> 'THR_ZERO_EN' -> DIS/ENA
// ESP32_S0_SET_FILTER_EN -> 'FILTER_EN' -> DIS/ENA
SelectAData ESP32_S0_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// values for KEY-GROUP 'CTRL_MODE'
// ESP32_S0_SET_CH1_LCTRL_MODE -> 'CH1_LCTRL_MODE'
// ESP32_S0_SET_CH1_HCTRL_MODE -> 'CH1_HCTRL_MODE'
// ESP32_S0_SET_CH0_LCTRL_MODE -> 'CH0_LCTRL_MODE'
// ESP32_S0_SET_CH0_HCTRL_MODE -> 'CH0_HCTRL_MODE'
SelectAData ESP32_S0_CTRL_MODE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"no_modification"},
  {1,"invert"},
  {2,"inhibit_modification"},
  {0, NULL}
  };

// Values for KEY-GROUP 'ESP32_S0_CH_MODE'
// ESP32_S0_SET_CH1_POS_MODE -> 'CH1_POS_MODE' 1: Increase the counter; 2: Decrease the counter; 0, 3: No effect on counter
// ESP32_S0_SET_CH1_NEG_MODE -> 'CH1_NEG_MODE'
// ESP32_S0_SET_CH0_POS_MODE -> 'CH0_POS_MODE'
// ESP32_S0_SET_CH0_NEG_MODE -> 'CH0_NEG_MODE'
SelectAData ESP32_S0_CH_MODE[]= {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"no_effect"},
  {1,"inc_counter"},
  {2,"dec_counter"},
  {0, NULL}
  };



/**
 * For Type: ESP32_S0
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in ESP32_S0_parsedKVInput_t
 */
enum ESP32_S0_SET_IK {				// Bit #XX for debugging

// S0 calculation configuration
    ESP32_S0_SET_IK_ATT		= 0		// Bit #00 'att' -> 

  , ESP32_S0_SET_IK_AVU				// Bit #01 'avu' -> 
  , ESP32_S0_SET_IK_AVF				// Bit #02 'avf' -> 

  , ESP32_S0_SET_IK_ATU				// Bit #03 'atu' -> 
  , ESP32_S0_SET_IK_ATF				// Bit #04 'atf' -> 

  , ESP32_S0_SET_IK_DEB				// Bit #05 'deb' -> 
  , ESP32_S0_SET_IK_NAME			// Bit #06 'name' -> 
  , ESP32_S0_SET_IK_CAPS			// Bit #07 'caps' -> #atv fehlt!

  // Block #01 HW counter, general configuration
  , ESP32_S0_SET_PULSE_CH0_GPIO			// Bit #08 'PULSE_CH0_GPIO' -> 
  , ESP32_S0_SET_CONTROL_CH0_GPIO		// Bit #09 'CONTROL_CH0_GPIO' -> 
  , ESP32_S0_SET_PULSE_CH1_GPIO			// Bit #10 'PULSE_CH1_GPIO' -> 
  , ESP32_S0_SET_CONTROL_CH1_GPIO		// Bit #11 'CONTROL_CH1_GPIO' -> 
  , ESP32_S0_SET_UNIT				// Bit #12 'UNIT' -> decval 0-7

  // Block #02 HW-counter, detail configuration
  , ESP32_S0_SET_CH1_LCTRL_MODE			// Bit #13 'CH1_LCTRL_MODE' -> no_mod/invert/inh_mod
  , ESP32_S0_SET_CH1_HCTRL_MODE			// Bit #14 'CH1_HCTRL_MODE' -> no_mod/invert/inh_mod
  , ESP32_S0_SET_CH1_POS_MODE			// Bit #15 'CH1_POS_MODE' -> inc/dec/inh_mod
  , ESP32_S0_SET_CH1_NEG_MODE			// Bit #16 'CH1_NEG_MODE' -> inc/dec/inh_mod
  , ESP32_S0_SET_CH0_LCTRL_MODE			// Bit #17 'CH0_LCTRL_MODE' -> no_mod/invert/inh_mod
  , ESP32_S0_SET_CH0_HCTRL_MODE			// Bit #18 'CH0_HCTRL_MODE' -> no_mod/invert/inh_mod
  , ESP32_S0_SET_CH0_POS_MODE			// Bit #19 'CH0_POS_MODE' -> inc/dec/inh_mod
  , ESP32_S0_SET_CH0_NEG_MODE			// Bit #20 'CH0_NEG_MODE' -> inc/dec/inh_mod
  , ESP32_S0_SET_THR_THRES1_EN			// Bit #21 'THR_THRES1_EN' -> DIS/ENA
  , ESP32_S0_SET_THR_THRES0_EN			// Bit #22 'THR_THRES0_EN' -> DIS/ENA
  , ESP32_S0_SET_THR_L_LIM_EN			// Bit #23 'THR_L_LIM_EN' -> DIS/ENA
  , ESP32_S0_SET_THR_H_LIM_EN			// Bit #24 'THR_H_LIM_EN' -> DIS/ENA
  , ESP32_S0_SET_THR_ZERO_EN			// Bit #25 'THR_ZERO_EN' -> DIS/ENA
  , ESP32_S0_SET_FILTER_EN			// Bit #26 'FILTER_EN' -> DIS/ENA
  , ESP32_S0_SET_FILTER_THRES			// Bit #27 'FILTER_THRES' -> decval 10 bit zahl
  , ESP32_S0_SET_CNT_THRES1			// Bit #28 'CNT_THRES1' -> decval 16 bit zahl
  , ESP32_S0_SET_CNT_THRES0			// Bit #29 'CNT_THRES0' -> decval 16 bit zahl
  , ESP32_S0_SET_CNT_L_LIM			// Bit #30 'CNT_L_LIM' -> decval 10 bit zahl
  , ESP32_S0_SET_CNT_H_LIM			// Bit #31 'CNT_H_LIM' -> decval 10 bit zahl

// end marker
  , ESP32_S0_SET_IK_Number_of_keys		// Bit #32 MAX 64 IMPLEMENTED !

};



/**
 * For Type: ESP32_S0
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum ESP32_S0_Readings {			// Bit #XX for debugging

   ESP32_S0_R_ATT		= (1<<0)	// Bit #00 'att'  -> 

  ,ESP32_S0_R_ATV		= (1<<1)	// Bit #01 'atv' -> 

  ,ESP32_S0_R_AV01_AV05_AV15	= (1<<2)	// Bit #02 'av01'  -> 

  ,ESP32_S0_R_AVF		= (1<<3)	// Bit #03 'avf' -> 

  ,ESP32_S0_R_AVU		= (1<<4)	// Bit #04 'avu'  -> 

  ,ESP32_S0_R_ATF		= (1<<5)	// Bit #05 'atf' -> 

  ,ESP32_S0_R_ATU		= (1<<6)	// Bit #06 'atu' -> 

  ,ESP32_S0_R_DEB		= (1<<7)	// Bit #07 'deb' -> 

  ,ESP32_S0_R_NAME		= (1<<8)	// Bit #08 'name' + caps + ufid -> 

};



/**
 * For Type: ESP32_S0
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()

 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t ESP32_S0_Set_ImplementedKeys[] = {
// |                                                          affected readings										              	|  CMD

// S0 calculation configuration
   { ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "att" }		// #00

  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "avu" }		// #01
  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "avf" }		// #02

  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "atu" }		// #03
  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "atf" }		// #04

  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB			, "deb" }		// #05
  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB | ESP32_S0_R_NAME	, "name" }		// #06
  ,{ ESP32_S0_R_ATT | ESP32_S0_R_ATV | ESP32_S0_R_AV01_AV05_AV15 | ESP32_S0_R_AVF | ESP32_S0_R_AVU | ESP32_S0_R_ATF | ESP32_S0_R_ATU | ESP32_S0_R_DEB | ESP32_S0_R_NAME	, "caps" }		// #07

// S0 counter configuration  
  ,{ 0																					, "Pulse_CH0_GPIO" }	// #08
  ,{ 0																					, "Control_CH0_GPIO" }	// #09
  ,{ 0																					, "Pulse_CH1_GPIO" }	// #10
  ,{ 0																					, "Control_CH1_GPIO" }	// #11
  ,{ 0																					, "Unit" }		// #12
  ,{ 0																					, "CH1_LCTRL_MODE" }	// #13
  ,{ 0																					, "CH1_HCTRL_MODE" }	// #14
  ,{ 0																					, "CH1_POS_MODE" }	// #15
  ,{ 0																					, "CH1_NEG_MODE" }	// #16
  ,{ 0																					, "CH0_LCTRL_MODE" }	// #17
  ,{ 0																					, "CH0_HCTRL_MODE" }	// #18
  ,{ 0																					, "CH0_POS_MODE" }	// #19
  ,{ 0																					, "CH0_NEG_MODE" }	// #20
  ,{ 0																					, "THR_THRES1_EN" }	// #21
  ,{ 0																					, "THR_THRES0_EN" }	// #22
  ,{ 0																					, "THR_L_LIM_EN" }	// #23
  ,{ 0																					, "THR_H_LIM_EN" }	// #24
  ,{ 0																					, "THR_ZERO_EN" }	// #25
  ,{ 0																					, "FILTER_EN" }		// #26
  ,{ 0																					, "FILTER_THRES" }	// #27
  ,{ 0																					, "CNT_THRES1" }	// #28
  ,{ 0																					, "CNT_THRES0" }	// #29
  ,{ 0																					, "CNT_L_LIM" }		// #30
  ,{ 0																					, "CNT_H_LIM" }		// #31

}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !





/*"WSAP_Password ";
	$list .= "WSAP_RF_Channel:uzsuSelectRadio,1,2,3,4,5,6,7,8,9,10,11,12,13 ";

"WSAP_Beacon_Interval:slider,100,10,60000 ";

uint8Slider,a,b,c

uint16Slider,a,b,c
uint32Slider,a,b,c
int8Slider,a,b,c
int16Slider,a,b,c
int32Slider,a,b,c

*/



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_S0_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t ESP32_S0_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_S0_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t ESP32_S0_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_S0_Module
 *  Desc: Data 'Provided By Module' for the ESP32_S0 module (functions + infos this module provides
 *        to SCDE)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
ProvidedByModule_t ESP32_S0_ProvidedByModule =  { 
  // A-Z order

  "ESP32_S0"				// Type-Name of module -> should be same name as libfilename.so !
  ,8					// size of Type-Name

  ,NULL					// Add

  ,ESP32_S0_Attribute			// Attribute

  ,ESP32_S0_Define			// Define

  ,NULL					// Delete

  ,NULL					// Except

  ,NULL					// Get

  ,ESP32_S0_IdleCb			// IdleCb

  ,ESP32_S0_Initialize			// Initialize

  ,NULL					// Notify

  ,NULL					// Parse

  ,NULL					// Read

  ,NULL					// Ready

  ,NULL					// Rename

  ,ESP32_S0_Set				// Set

  ,ESP32_S0_Shutdown			// Shutdown

  ,NULL					// State

  ,NULL					// Sub

  ,ESP32_S0_Undefine			// Undefine

  ,NULL					// DirectRead

  ,NULL					// DirectWrite

//  ,NULL		 		// FnProvided

  ,sizeof(ESP32_S0_Definition_t)	// Size of modul specific definition structure (Common_Definition_t + X)

};



/* -------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Attribute
 *  Desc: Informs an Definition of this Type for attribute activities (set/del)
 *  Info: 'attrCmd' is the command text for the activity: set, del
 *        'attrName' is the attribute name text
 *        'attrVal' is the attribute value text
 *        THE attrVal CAN BE MANIPULATED / CORRECTED
 *  Para: Common_Definition_t *Common_Definition -> the belonging definition for the attribute-activitie
 *	  const uint8_t *attrCmdText -> ptr to attribute-command text "attrCmd"
 *	  const size_t attrCmdTextLen -> length of attribute-command text "attrCmd"

 *	  const uint8_t *attrNameText -> ptr to attribute-name text "attrName"
 *	  const size_t attrNameTextLen -> length of attribute-name text "attrName"
 *	  uint8_t **attrValTextPtr -> ptr to ptr holding attribute-value text "attrValue" - manipulation possible
 *	  size_t *attrValLenTextPtr -> ptr to length of attribute-value text "attrValue" - manipulation possible
 *  Rets: strTextMultiple_t* -> veto = error-text-string in allocated mem, or NULL = OK - no veto
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_S0_Attribute(Common_Definition_t *Common_Definition
		,const uint8_t *attrCmdText
		,const size_t attrCmdTextLen
		,const uint8_t *attrNameText
		,const size_t attrNameTextLen
		,uint8_t **attrValTextPtr
		,size_t *attrValTextLenPtr)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  uint8_t *attrValText = *attrValTextPtr;
  size_t attrValTextLen = *attrValTextLenPtr;

  printf("ESP32_S0_AttributeFN for defName:%.*s -> attrCmd:%.*s attrName:%.*s attrVal:%.*s\n"
	,Common_Definition->nameLen
	,Common_Definition->name
	,attrCmdTextLen
	,attrCmdText
  	,attrNameTextLen
	,attrNameText
	,(int) attrValTextLen
	,attrValText);



/*
  // set start of possible def-Name
  const uint8_t *defName = args;

  // set start of possible attr-Name
  const uint8_t *attrName = args;

  // a seek-counter
  int i = 0;

  // seek to next space !'\32'
  while( (i < argsLen) && (*attrName != ' ') ) {i++;attrName++;}

  // length of def-Name
  size_t defNameLen = i;


  // seek to start position of attr-Name '\32'
  while( (i < argsLen) && (*attrName == ' ') ) {i++;attrName++;}

  // set start of possible attr-Val
  const uint8_t *attrVal = attrName;

  // a 2nd seek-counter
  int j = 0;

  // seek to next space !'\32'
  while( (i < argsLen) && (*attrVal != ' ') ) {i++,j++;attrVal++;}

  // length of attr-Name
  size_t attrNameLen = j;

  // start position of attr-Val
  while( (i < argsLen) && (*attrVal == ' ') ) {i++;attrVal++;}

  // length of attr-Val
  size_t attrValLen = argsLen - i;

  // veryfy lengths > 0, definition 0 allowed
  if ( (defNameLen == 0) || (attrNameLen == 0) )

		{


		// response with error text
		asprintf(&retMsg
				,"Could not interpret command ''! Usage: Attr <defname> <attrname> [<attrval>]");

		return retMsg;

	//	}

// -------------------------------------------------------------------------------------------------
*/

  return retMsg;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Define
 *  Desc: Finalizes the defines a new "device" of 'ESP32_S0' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR 
ESP32_S0_Define(Common_Definition_t *Common_Definition)
//	,uint8_t *defArgsText
//	,size_t defArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_S0_Definition_t* ESP32_S0_Definition =
		  (ESP32_S0_Definition_t*) Common_Definition;
/*
  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_Def, Def:%.*s>"
	,ESP32_S0_Definition->common.definitionLen
	,ESP32_S0_Definition->common.definition);
  #endif
*/
  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_Def, Name:%.*s, got args:%.*s>"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name
	,defArgsTextLen
	,defArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Expected Args!");

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  ESP32_S0_Definition->common.fd = -1;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  ESP32_S0_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (ESP32_S0_Definition->WebIf_Provided.WebIf_FnProvided) {

	ESP32_S0_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &ESP32_S0_ActiveResourcesDataA_forWebIf;

	ESP32_S0_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &ESP32_S0_ActiveResourcesDataB_forWebIf;

	}

  else	{

	SCDEFn->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,ESP32_S0_Definition->common.nameLen
		,ESP32_S0_Definition->common.name
		,ESP32_S0_Definition->common.module->ProvidedByModule->typeNameLen
		,ESP32_S0_Definition->common.module->ProvidedByModule->typeName);
	}

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn->ParseKVInputArgsFn(ESP32_S0_SET_IK_Number_of_keys	// Num Implementated KEYs MAX
	,ESP32_S0_Set_ImplementedKeys		// Implementated Keys
	,defArgsText				// our args text
	,defArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,defArgsTextLen
		,defArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

//  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_S0_SET_UNIT) );
/*
  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_S0_SET_PULSE_CH0_GPIO)
			        | (1 << ESP32_S0_SET_UNIT)
			        | (1 << ESP32_S0_SET_CH1_LCTRL_MODE)
			        | (1 << ESP32_S0_SET_CH1_HCTRL_MODE)
			        | (1 << ESP32_S0_SET_CH1_POS_MODE)
			        | (1 << ESP32_S0_SET_CH1_NEG_MODE)
			        | (1 << ESP32_S0_SET_CH0_LCTRL_MODE)
			        | (1 << ESP32_S0_SET_CH0_HCTRL_MODE)
			        | (1 << ESP32_S0_SET_CH0_POS_MODE)
			        | (1 << ESP32_S0_SET_CH0_NEG_MODE)
			        | (1 << ESP32_S0_SET_THR_THRES1_EN)
			        | (1 << ESP32_S0_SET_THR_THRES0_EN)
			        | (1 << ESP32_S0_SET_THR_L_LIM_EN)
			        | (1 << ESP32_S0_SET_THR_H_LIM_EN)
			        | (1 << ESP32_S0_SET_THR_ZERO_EN)
			        | (1 << ESP32_S0_SET_FILTER_EN)
			        | (1 << ESP32_S0_SET_FILTER_THRES)
			        | (1 << ESP32_S0_SET_CNT_THRES1)
			        | (1 << ESP32_S0_SET_CNT_THRES0)
			        | (1 << ESP32_S0_SET_CNT_L_LIM)
			        | (1 << ESP32_S0_SET_CNT_H_LIM) );
*/
  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;


  // enable the  counter
//  SET_PERI_REG_MASK(DPORT_PERIP_CLK_EN_REG, DPORT_PCNT_CLK_EN);
//  CLEAR_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_PCNT_RST);

  DPORT_SET_PERI_REG_MASK(DPORT_PERIP_CLK_EN_REG, DPORT_PCNT_CLK_EN);
  DPORT_CLEAR_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_PCNT_RST);

  // process the set-args (key=value@) protocol
  if (ESP32_S0_ProcessKVInputArgs(ESP32_S0_Definition
	,parsedKVInput				// KVInput parsed
	,defArgsText				// our args text
	,defArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,defArgsTextLen
		,defArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_S0_SetAffectedReadings(ESP32_S0_Definition
	,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  // set up 1st idle Callback
  ESP32_S0_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

}



/*
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int //feedModuleTask
ESP32_S0_IdleCb(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_S0_Definition_t* ESP32_S0_Definition =
		  (ESP32_S0_Definition_t*) Common_Definition;

  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_IdleCb, Def:%.*s>"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------


  ESP32_S0_CntProcessing1M(ESP32_S0_Definition);


  ESP32_S0_SetAffectedReadings(ESP32_S0_Definition
	,0xfffffffffffffff);


/*
 if (WebIf_Definition->reverse) {

  // get assigned HTTPD-Connection-Slot-Data
  WebIf_HTTPDConnSlotData_t *conn
	= WebIf_Definition->reverse;

  // execute disconnection (indicated by NEEDS_CLOSE flag) or send more data ...
  if (conn->ConnCtrlFlags & F_GENERATE_IDLE_CALLBACK)

	{

	// execute Idle Callback
	WebIf_IdleCb(WebIf_Definition);

	}

}
*/


  // set up next idle Callback
  ESP32_S0_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
ESP32_S0_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn = SCDERootptr->SCDEFn;

  SCDEFn->Log3Fn(ESP32_S0_ProvidedByModule.typeName
		  ,ESP32_S0_ProvidedByModule.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,ESP32_S0_ProvidedByModule.typeNameLen
		  ,ESP32_S0_ProvidedByModule.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_S0_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_S0_Definition_t* ESP32_S0_Definition =
	(ESP32_S0_Definition_t*) Common_Definition;

  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_Set, Name:%.*s, got args:%.*s>"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn->ParseKVInputArgsFn(ESP32_S0_SET_IK_Number_of_keys	// Num Implementated KEYs MAX for Set Fn
	,ESP32_S0_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = ( (1 << ESP32_S0_SET_PULSE_CH0_GPIO)
 				 | (1 << ESP32_S0_SET_CONTROL_CH0_GPIO)
			         | (1 << ESP32_S0_SET_UNIT) );

  // process the set-args (key=value@) protocol
  if (ESP32_S0_ProcessKVInputArgs(ESP32_S0_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_S0_SetAffectedReadings(ESP32_S0_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine ESP32_S0_Definition.common.Name'
 *  Para: ESP32_S0_Definition_t *ESP32_S0_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text

 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_S0_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_S0_Definition_t* ESP32_S0_Definition =
	(ESP32_S0_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_Shutdown, Name:%.*s>"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_S0_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_S0_Definition_t* ESP32_S0_Definition =
	(ESP32_S0_Definition_t*) Common_Definition;

  #if ESP32_S0_DBG >= 5
  printf("\n|ESP32_S0_Undefine, Name:%.*s>"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name);
  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"ESP32_S0_Undefine, Name:%.*s"
	,ESP32_S0_Definition->common.nameLen
	,ESP32_S0_Definition->common.name);

  return retMsg;

}



/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: ESP32_S0_Definition_t *ESP32_S0_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * -------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_S0_ProcessKVInputArgs(ESP32_S0_Definition_t *ESP32_S0_Definition
	,parsedKVInputArgs_t *parsedKVInput
	,uint8_t *argsText
	,size_t argsTextLen)
{

// 1. Step: Prepare structures with current values from TYPE & SYSTEM 
//          (to allow an abort if values not complete or in case of processing errors)

  // block #1 get current assigned counter unit
  uint8_t newUnit = ESP32_S0_Definition->unit;

// ------------------------------------------------------------------------------------------------
  
  // we need to process the 'UNIT' KEY in advance here, because we need this information early

  // UNIT=[0-7]
  // -> Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_UNIT) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_UNIT].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_UNIT].len, &newUnit) 
		&& (newUnit <= 7) ) {

/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
		}

	// invalid input detected ?
	else return true;
  }

// ------------------------------------------------------------------------------------------------

  // block #2 get current assigned / connected GPIO for pulse input channel 0
  uint8_t newPulseCH0GPIO = ESP32_S0_Definition->pulseCH0GPIO;

  // block #3 get current assigned / connected GPIO for control input channel 0
  uint8_t newControlCH0GPIO = ESP32_S0_Definition->controlCH0GPIO;

  // block #4 get current assigned / connected GPIO for pulse input channel 1
  uint8_t newPulseCH1GPIO = ESP32_S0_Definition->pulseCH1GPIO;

  // block #5 get current assigned / connected GPIO for control input channel 1
  uint8_t newControlCH1GPIO = ESP32_S0_Definition->controlCH1GPIO;

  // block #6 get current ESP32 counter configuration registers from selected unit
  // this stores temp values
  ESP32_S0_CNT_CONF_REG_t newS0_CNT_CONF_REG;
  // pointer to make hardware counters accessible
  ESP32_S0_CNT_CONF_REG_t *pS0_CNT_CONF_REG =
	(ESP32_S0_CNT_CONF_REG_t*) (0x3FF57000 + (0x0c * newUnit));
  memcpy(&newS0_CNT_CONF_REG, &pS0_CNT_CONF_REG, sizeof(ESP32_S0_CNT_CONF_REG_t));
// clear befehl implementieren?
// memset(&ESP32_S0_CNT_CONF_REG, 0, sizeof(ESP32_S0_CNT_CONF_REG_t));

// ------------------------------------------------------------------------------------------------

// 2. Step: Process the possible input keys

  // att=[0-9] -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Zählerstand
  // att=[0-9] -> Set alltime-total-tics meeting the currend meter-reading
/*
  if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_att)

	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &NewVal))

		{

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

		}

	}

//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------

  // avu=[a-zA-Z0-9_.] -> Setze Einheit für den Durchschnitts-Verbrauchs-Wert (char[3])
  // avu=[a-zA-Z0-9_.] -> Set unit for average-consumption-value (char[3])

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_avu)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit)
		,3) ) // -> case 3 = (Alpha+Num+"³") for Unit Name

		{	

		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");

		}

	}

//>Caps Bit 1---------------------------------------------------------------------------------------

  // avf=[0-9.] -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // avf=[0-9.] -> Set average consumption calculation factor (float)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_avf)

	{

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal))

		{

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");

		}

	}

//--------------------------------------------------------------------------------------------------

  // atu=[a-zA-Z0-9_.] -> Setze Einheit für den Allzeit-Gesamt-Wert (char[3])
  // atu=[a-zA-Z0-9_.] -> Set unit for alltime-total-value (char[3])

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_atu)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"³") for Unit Name

		{	

		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");

		}

	}

//>Caps Bit 2---------------------------------------------------------------------------------------

  // atf=[0-9.] -> Setze Umrechnungsfaktor für den Allzeit-Total-Wert (float)
  // atf=[0-9.] -> Set factor for alltime total value (float)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_atf)

	{

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal))

		{

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");

		}

	}

//>Caps Bit 3---------------------------------------------------------------------------------------

  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)

	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))

		{

		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");

		}

	}


//>Caps Bit n.a.------------------------------------------------------------------------------------

  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

		{	

		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // caps=[ ] -> Fragt nach den Fähigkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)


 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{

	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;

//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");

	}

*/






// ------------------------------------------------------------------------------------------------

  // Pulse_CH0_GPIO=[0-9]
  // -> Verbindet die HW-Counter-Unit (Pulse Input-Channel 0) mit dem angegebenen GPIO (inklusive der Konfiguration)
  // -> Connects the HW-Counter-Unit (pulse input-channel 0) with the given GPIO (including the setup)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_PULSE_CH0_GPIO) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_PULSE_CH0_GPIO].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_PULSE_CH0_GPIO].len, &newPulseCH0GPIO)
		&& (newPulseCH0GPIO <= 33) ) {
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

// ------------------------------------------------------------------------------------------------

  // Control_CH0_GPIO=[0-9]
  // -> Verbindet die HW-Counter-Unit (Control Input-Channel 0) mit dem angegebenen GPIO (inklusive der Konfiguration)
  // -> Connects the HW-Counter-Unit (control input-channel 0) with the given GPIO (including the setup)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CONTROL_CH0_GPIO) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CONTROL_CH0_GPIO].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CONTROL_CH0_GPIO].len, &newControlCH0GPIO)
		&& (newControlCH0GPIO <= 33) ) {
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
		}

	// invalid input detected ?
	else return true;
  }
// ------------------------------------------------------------------------------------------------

  // Pulse_CH1_GPIO=[0-9]
  // -> Verbindet die HW-Counter-Unit (Pulse Input-Channel 1) mit dem angegebenen GPIO (inklusive der Konfiguration)
  // -> Connects the HW-Counter-Unit (pulse input-channel 1) with the given GPIO (including the setup)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_PULSE_CH1_GPIO) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_PULSE_CH1_GPIO].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_PULSE_CH1_GPIO].len, &newPulseCH1GPIO)
		&& (newPulseCH1GPIO <= 33) ) {
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
		}

	// invalid input detected ?
	else return true;
  }

// ------------------------------------------------------------------------------------------------

  // Control_CH1_GPIO=[0-9]
  // -> Verbindet die HW-Counter-Unit (Control Input-Channel 1) mit dem angegebenen GPIO (inklusive der Konfiguration)
  // -> Connects the HW-Counter-Unit (control input-channel 1) with the given GPIO (including the setup)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CONTROL_CH1_GPIO) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CONTROL_CH1_GPIO].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CONTROL_CH1_GPIO].len, &newControlCH1GPIO)
		&& (newControlCH1GPIO <= 33) ) {
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH1_LCTRL_MODE) ) {

	uint8_t newMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_S0_CTRL_MODE)
		&& (newMode <= 3) ) {

		// store the value to temp
		newS0_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;


/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH1_HCTRL_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH1_HCTRL_MODE].len, &NewMode, ESP32_S0_CTRL_MODE) ) {


		// store ne value
		newS0_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH1_POS_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH1_POS_MODE].len, &NewMode, ESP32_S0_CH_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH1_NEG_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH1_NEG_MODE) ) {
	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH1_NEG_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH1_NEG_MODE].len, &NewMode, ESP32_S0_CH_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH1_NEG_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH0_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH0_LCTRL_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH0_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH0_LCTRL_MODE].len, &NewMode, ESP32_S0_CTRL_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH0_LCTRL_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH0_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH0_HCTRL_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH0_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH0_HCTRL_MODE].len, &NewMode, ESP32_S0_CTRL_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH0_HCTRL_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH0_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH0_POS_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH0_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH0_POS_MODE].len, &NewMode, ESP32_S0_CH_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH0_POS_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CH0_NEG_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CH0_NEG_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CH0_NEG_MODE].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CH0_NEG_MODE].len, &NewMode, ESP32_S0_CH_MODE) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CH0_NEG_MODE = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // THR_THRES1_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_THR_THRES1_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_THR_THRES1_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_THR_THRES1_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_THR_THRES1_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // THR_THRES0_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_THR_THRES0_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_THR_THRES0_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_THR_THRES0_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_THR_THRES0_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // THR_L_LIM_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_THR_L_LIM_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_THR_L_LIM_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_THR_L_LIM_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_THR_L_LIM_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // THR_H_LIM_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_THR_H_LIM_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_THR_H_LIM_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_THR_H_LIM_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_THR_H_LIM_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // THR_ZERO_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_THR_ZERO_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_THR_ZERO_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_THR_ZERO_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_THR_ZERO_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // FILTER_EN=Disabled|Enabled
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_FILTER_EN) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_FILTER_EN].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_FILTER_EN].len, &NewMode, ESP32_S0_DisEna) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_FILTER_EN = NewMode;

/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // FILTER_THRES=[0-9]
  // -> ??? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ???  Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_FILTER_THRES) ) {

	uint16_t NewVal;

	// valid input happened ?

	if (SCDEH_GetDecUInt16Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_FILTER_THRES].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_FILTER_THRES].len, &NewVal) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_FILTER_THRES = NewVal;
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CNT_THRES1=[0-9]
  // -> ??? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ???  Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CNT_THRES1) ) {

	uint16_t NewVal;

	// valid input happened ?

	if (SCDEH_GetDecUInt16Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CNT_THRES1].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CNT_THRES1].len, &NewVal) ) {

		// store ne value
		newS0_CNT_CONF_REG.CNT_CNT_THRES1 = NewVal;
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CNT_THRES0=[0-9] 
  // -> ??? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ???  Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CNT_THRES0) ) {

	uint16_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt16Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CNT_THRES0].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CNT_THRES0].len, &NewVal) ) {
		// store ne value
		newS0_CNT_CONF_REG.CNT_CNT_THRES0 = NewVal;
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CNT_L_LIM=[0-9]
  // -> ??? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ???  Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CNT_L_LIM) ) {

	uint16_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt16Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CNT_L_LIM].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CNT_L_LIM].len, &NewVal) ) {
		// store ne value
		newS0_CNT_CONF_REG.CNT_CNT_L_LIM = NewVal;
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

  // CNT_H_LIM=[0-9]
  // -> ??? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ???  Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_S0_SET_CNT_H_LIM) ) {

	uint16_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt16Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_S0_SET_CNT_H_LIM].off
		,parsedKVInput->keyData_t[ESP32_S0_SET_CNT_H_LIM].len, &NewVal) ) {
		// store ne value
		newS0_CNT_CONF_REG.CNT_CNT_H_LIM = NewVal;
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

*/
		}

	// invalid input detected ?
	else return true;
  }

//> ------------------------------------------------------------------------------------------------

// 3. Step: Check if the ammount of input elements meets our criteria

  // check if all required Key=Value components are included -> return with FALSE
  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	#if ESP32_S0_DBG >= 5
	printf("|requiredKVBF, no match!>");	
  	#endif

	return true;
  }

  // check if forbidden Key=Value components are included -> return with FALSE
  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	#if ESP32_S0_DBG >= 5
	printf("|forbiddenKVBF, match!>");	
  	#endif

	return true;
  }

//> ------------------------------------------------------------------------------------------------

// 4. Step: Passed. Store the new values

  // block #1 store counter unit
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_S0_SET_UNIT) ) ) {

	#if ESP32_S0_DBG >= 5
	printf("|W B#01 Unit=%d>"
		,newUnit);	
  	#endif

	// store counter unit
	ESP32_S0_Definition->unit = newUnit;
  }

  // block #2 store assigned / connected pulse GPIO channel 0
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_S0_SET_PULSE_CH0_GPIO) ) ) {

	#if ESP32_S0_DBG >= 5
	printf("|W B#02 Pulse_CH0_GPIO=%d>"
		,newPulseCH0GPIO);	
  	#endif

	// store assigned pulse GPIO channel 0
	ESP32_S0_Definition->pulseCH0GPIO = newPulseCH0GPIO;

	// setup the GPIO and connect the matrix
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newPulseCH0GPIO], PIN_FUNC_GPIO);

        gpio_set_direction(newPulseCH0GPIO, GPIO_MODE_INPUT);

        gpio_set_pull_mode(newPulseCH0GPIO, GPIO_PULLUP_ONLY);

         gpio_matrix_in(newPulseCH0GPIO
		,PCNT_SIG_CH0_IN0_IDX + 4 * newUnit
		,0);
  }

  // block #3 store assigned / connected control GPIO channel 0
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_S0_SET_CONTROL_CH0_GPIO) ) ) {

	#if ESP32_S0_DBG >= 5
	printf("|W B#03 Control_CH0_GPIO=%d>"
		,newControlCH0GPIO);	
  	#endif

	// store assigned control GPIO channel 0
	ESP32_S0_Definition->controlCH0GPIO = newControlCH0GPIO;

	// setup the GPIO and connect the matrix
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newControlCH0GPIO], PIN_FUNC_GPIO);

        gpio_set_direction(newControlCH0GPIO, GPIO_MODE_INPUT);

        gpio_set_pull_mode(newControlCH0GPIO, GPIO_PULLUP_ONLY);

        gpio_matrix_in(newControlCH0GPIO
		,PCNT_CTRL_CH0_IN0_IDX + 4 * newUnit
		,0);
  }

  // block #4 store assigned / connected pulse GPIO channel 1
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_S0_SET_PULSE_CH1_GPIO) ) ) {

	#if ESP32_S0_DBG >= 5
	printf("|W B#04 Pulse_CH1_GPIO=%d>"
		,newPulseCH1GPIO);	
  	#endif

	// store assigned pulse GPIO channel 1
	ESP32_S0_Definition->pulseCH1GPIO = newPulseCH1GPIO;

	// setup the GPIO and connect the matrix
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newPulseCH1GPIO], PIN_FUNC_GPIO);

        gpio_set_direction(newPulseCH1GPIO, GPIO_MODE_INPUT);

        gpio_set_pull_mode(newPulseCH1GPIO, GPIO_PULLUP_ONLY);

	gpio_matrix_in(newPulseCH1GPIO
		,PCNT_SIG_CH1_IN0_IDX + 4 * newUnit
		,0);
  }

  // block #5 store assigned / connected control GPIO channel 1
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_S0_SET_CONTROL_CH1_GPIO) ) ) {

	#if ESP32_S0_DBG >= 5
	printf("|W B#05 Control_CH1_GPIO=%d>"
		,newControlCH1GPIO);	
  	#endif

	// store assigned control GPIO channel 1
	ESP32_S0_Definition->controlCH1GPIO = newControlCH1GPIO;

	// setup the GPIO and connect the matrix
        PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newControlCH1GPIO], PIN_FUNC_GPIO);

        gpio_set_direction(newControlCH1GPIO, GPIO_MODE_INPUT);

        gpio_set_pull_mode(newControlCH1GPIO, GPIO_PULLUP_ONLY);

        gpio_matrix_in(newControlCH1GPIO
		,PCNT_CTRL_CH1_IN0_IDX + 4 * newUnit
		,0);
  }

  // block #6 store ESP32 counter configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_S0_SET_CH1_LCTRL_MODE)
				   | (1 << ESP32_S0_SET_CH1_HCTRL_MODE)
				   | (1 << ESP32_S0_SET_CH1_POS_MODE)
				   | (1 << ESP32_S0_SET_CH1_NEG_MODE)
				   | (1 << ESP32_S0_SET_CH0_LCTRL_MODE)
				   | (1 << ESP32_S0_SET_CH0_HCTRL_MODE)
				   | (1 << ESP32_S0_SET_CH0_POS_MODE)
				   | (1 << ESP32_S0_SET_CH0_NEG_MODE)
				   | (1 << ESP32_S0_SET_THR_THRES1_EN)
				   | (1 << ESP32_S0_SET_THR_THRES0_EN)
				   | (1 << ESP32_S0_SET_THR_L_LIM_EN)
				   | (1 << ESP32_S0_SET_THR_H_LIM_EN)
				   | (1 << ESP32_S0_SET_THR_ZERO_EN)
				   | (1 << ESP32_S0_SET_FILTER_EN)
				   | (1 << ESP32_S0_SET_FILTER_THRES)
				   | (1 << ESP32_S0_SET_CNT_THRES1)
				   | (1 << ESP32_S0_SET_CNT_THRES0)
				   | (1 << ESP32_S0_SET_CNT_L_LIM)
				   | (1 << ESP32_S0_SET_CNT_H_LIM) ) ) {

	// store ESP32 counter configuration register
	memcpy(pS0_CNT_CONF_REG
		,&newS0_CNT_CONF_REG
		,sizeof(ESP32_S0_CNT_CONF_REG_t));

	# if ESP32_S0_DBG >= 5
	printf("|W B#06 ESP32_S0_CNT_CONF_REG_s addr=%p>"
		,pS0_CNT_CONF_REG);

	SCDEFn->HexDumpOutFn ("dump"
		,pS0_CNT_CONF_REG
		, sizeof(ESP32_S0_CNT_CONF_REG_t) );
	# endif
  }

  return false;

}



/**
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: ESP32_S0_Definition_t *ESP32_S0_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_S0_SetAffectedReadings(ESP32_S0_Definition_t* ESP32_S0_Definition
	,uint64_t affectedReadings)
{

  // do we have updates?
  if (affectedReadings) {

  SCDEFn->readingsBeginUpdateFn((Common_Definition_t*) ESP32_S0_Definition);

  }

  // we have no updates
  else return false;

// -----------------------------------------------------------------------------------------------

  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;


//>Add Readings Bit 00 -----------------------------------------------------------------------------

  // add reading 'Alltime_Total_Tics' //att'
  if (affectedReadings & ESP32_S0_R_ATT) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Tics");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_S0_Definition->ATTShiftBuf[0]);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

//	RespArgsWPos += os_sprintf(RespArgsWPos,
//		"&att=%u", SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]);



//>Add Readings Bit 01 -----------------------------------------------------------------------------

  // add reading 'Alltime_Total_Value' //atv'
  if (affectedReadings & ESP32_S0_R_ATV) {

	// calc helper ...
	float RB01_AlltimeTotalValue = ( ESP32_S0_Definition->ATTShiftBuf[0] *
		ESP32_S0_Definition->IB01_AlltimeTotalFactor);

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Value");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%03d"
		,(int) (RB01_AlltimeTotalValue)
		,(int) ( (RB01_AlltimeTotalValue - (int) RB01_AlltimeTotalValue) * 1000) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }

//	// calc helper ...
//	float RB01_AlltimeTotalValue = ( SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0] *
//		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor);

//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atv=%d.%03d"
//		,(int)(RB01_AlltimeTotalValue)
//		,(int)((RB01_AlltimeTotalValue - (int)RB01_AlltimeTotalValue)*1000) );


//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_S0_R_AV01_AV05_AV15) {

	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...

	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );

		}

	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );

		}

	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	

		}

	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------

  // add reading 'Average_Factor' //avf'
  if (affectedReadings & ESP32_S0_R_AVF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) ESP32_S0_Definition->IB01_AverageFactor	
		,(int) ( (ESP32_S0_Definition->IB01_AverageFactor -
		(int) ESP32_S0_Definition->IB01_AverageFactor) * 10000) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------

  // add reading 'Average_Unit' //avu'
  if (affectedReadings & ESP32_S0_R_AVU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_S0_Definition->IB01_AverageUnit);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }


//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------

  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & ESP32_S0_R_ATF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (ESP32_S0_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (ESP32_S0_Definition->IB01_AlltimeTotalFactor -
		(int) ESP32_S0_Definition->IB01_AlltimeTotalFactor) * 10000) );

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------

  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & ESP32_S0_R_ATU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_S0_Definition->IB01_AlltimeTotalUnit);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------

  // add reading 'Debounce' //deb'
  if (affectedReadings & ESP32_S0_R_DEB) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_S0_Definition->IB01_Debounce);

	SCDEFn->readingsBulkUpdateFn((Common_Definition_t*) ESP32_S0_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }


//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_S0_R_name)
	{

	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);

	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX

	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);

	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");

	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
  SCDEFn->readingsEndUpdateFn((Common_Definition_t*) ESP32_S0_Definition);


  return true;
}
































/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_S0_CntProcessing1M
 *  Desc: Gets the impulses from the count hardware and calculates the values
 *  Info: Invoked by cmd-line 'Undefine ESP32_S0_Definition.common.Name'
 *  Para: ESP32_S0_Definition_t *ESP32_S0_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
//##################################################################################################
//### FName: S0_CntDetection (Called 100 times / Sec by timer!)
//###  Desc: Average Calculations + Detection of the S0 Counts at the GPIOs
//###  Para: NONE
//###  Rets: NONE
//##################################################################################################
void ICACHE_FLASH_ATTR
ESP32_S0_CntProcessing1M(ESP32_S0_Definition_t* ESP32_S0_Definition)
{

  // shift the ATT - last 15 minutes buffer
  for (int i = 14; i >=0 ; i--) {

	ESP32_S0_Definition->ATTShiftBuf[i+1] = 
		ESP32_S0_Definition->ATTShiftBuf[i];
  }

// -------------------------------------------------------------------------------------------------




  // build ptr to access hw-counter
  ESP32_S0_CNT_CNT_REG_t *pESP32_S0_CNT_CNT_REG =
	(ESP32_S0_CNT_CNT_REG_t*) 0x3FF57060;

  // add counts from hardware to att
  ESP32_S0_Definition->ATTShiftBuf[0] += 
	pESP32_S0_CNT_CNT_REG[ESP32_S0_Definition->unit].CNT_PULS_CNT;


  printf("|STATUS: Using counter-unit:%u, HW-Ctr:%d -> new ATT:%u, gpio:%u>"
	,ESP32_S0_Definition->unit
	,pESP32_S0_CNT_CNT_REG[ESP32_S0_Definition->unit].CNT_PULS_CNT
	,ESP32_S0_Definition->ATTShiftBuf[0]
	,gpio_get_level(22) ); //=att ?




  ESP32_S0_CNT_CONF_REG_t *pESP32_S0_CNT_CONF_REG = (ESP32_S0_CNT_CONF_REG_t*) 0x3FF570B0;

	SCDEFn->HexDumpOutFn ("verify:"
		,&pESP32_S0_CNT_CONF_REG[0]
		, 0x4);  //sizeof(0x80) ); //ESP32_S0_CNT_CONF_REG_t) );







  uint32_t *pX_REG =
	(uint32_t*) 0x3FF570B0;

  // config counter -> reset state to zero counter
  *pX_REG |= 1<<(ESP32_S0_Definition->unit * 2);
 for (int i = 140; i >=0 ; i--)
  // config counter -> NOT in reset state
  *pX_REG &= ~(1<<(ESP32_S0_Definition->unit * 2));
/*
 *pX_REG = 0b10;
 *pX_REG = 0b01;
 for (int i = 140; i >=0 ; i--)
 *pX_REG = 0;
*/



  // import the current counter value to ATTShiftBuf[0]
//  ESP32_S0_Definition->ATTShiftBuf[0] =
//	0;
  	

  // calculate average 01min
  ESP32_S0_Definition->RB01_Average01Min = 
	( (float) (ESP32_S0_Definition->ATTShiftBuf[0] - ESP32_S0_Definition->ATTShiftBuf[1])  *
	( (3600 / 01) / 60) * ESP32_S0_Definition->IB01_AverageFactor);

  // calculate average 05min
  ESP32_S0_Definition->RB01_Average05Min =
	( (float) (ESP32_S0_Definition->ATTShiftBuf[0] - ESP32_S0_Definition->ATTShiftBuf[5])  *
	( (3600 / 05) / 60) * ESP32_S0_Definition->IB01_AverageFactor);

  // calculate average 15min
  ESP32_S0_Definition->RB01_Average15Min =
	( (float) (ESP32_S0_Definition->ATTShiftBuf[0] - ESP32_S0_Definition->ATTShiftBuf[15]) *
	( (3600 / 15) / 60) * ESP32_S0_Definition->IB01_AverageFactor);

  // New Timestamp for this reading block
//  ESP32_S0_Definition->RB01_X_TiSt =
//	GetUniqueTIST();


// -------------------------------------------------------------------------------------------------

  #if ESP32_S0_DBG >= 5
  // 'ATT' -> Alltime Total Tics
  printf(",ATT=%u", ESP32_S0_Definition->ATTShiftBuf[0]);

  // calc helper ...
  float RB01_AlltimeTotalValue = ( ESP32_S0_Definition->ATTShiftBuf[0] *
	ESP32_S0_Definition->IB01_AlltimeTotalFactor);
  // 'ATV' -> Alltime Total Value
  printf(",ATV=%d.%03d"
	,(int)(RB01_AlltimeTotalValue)
	,(int)((RB01_AlltimeTotalValue - (int)RB01_AlltimeTotalValue)*1000) );

  // 'AV01' -> AVerage 01 min (calculated)
  printf(",AV01=%d.%03d"
	,(int)(ESP32_S0_Definition->RB01_Average01Min)	
	,(int)((ESP32_S0_Definition->RB01_Average01Min - 
	 (int)ESP32_S0_Definition->RB01_Average01Min)*1000) );

  // 'AV05' -> AVerage 05 min (calculated)
  printf(",AV05=%d.%03d"
	,(int)(ESP32_S0_Definition->RB01_Average05Min)	
	,(int)((ESP32_S0_Definition->RB01_Average05Min -
	 (int)ESP32_S0_Definition->RB01_Average05Min)*1000) );

  // 'AV15' -> AVerage 15 min (calculated)
  printf(",AV15=%d.%03d"
	,(int)(ESP32_S0_Definition->RB01_Average15Min)	
	,(int)((ESP32_S0_Definition->RB01_Average15Min -
	 (int)ESP32_S0_Definition->RB01_Average15Min)*1000) );	

  printf(",AVF=%d.%04d"
	,(int)(ESP32_S0_Definition->IB01_AverageFactor)	
	,(int)((ESP32_S0_Definition->IB01_AverageFactor -
	 (int)ESP32_S0_Definition->IB01_AverageFactor)*10000) );

  // 'AVU' -> Average Unit
  printf(",AVU=%s"
	,ESP32_S0_Definition->IB01_AverageUnit);

  // 'ATF' -> Alltime Total Factor
  printf(",ATF=%d.%04d"
	,(int)(ESP32_S0_Definition->IB01_AlltimeTotalFactor)	
	,(int)((ESP32_S0_Definition->IB01_AlltimeTotalFactor -
	 (int)ESP32_S0_Definition->IB01_AlltimeTotalFactor)*10000) );

  // 'ATU' -> Alltime Total Unit
  printf(",ATU=%s"
	,ESP32_S0_Definition->IB01_AlltimeTotalUnit);
  #endif

// -------------------------------------------------------------------------------------------------

}
		











