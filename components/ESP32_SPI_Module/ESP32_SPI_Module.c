/* #################################################################################################
 *
 *      Name: ESP32_SPI Module
 *  Function: This is used to set up GPIOs as a switch with the goal to control switching hardware
 *            (relay, ...). The GPIO switching is Hardware PWM driven (for ESP32 SOC only). 
 *            Module for use with SCDE (Smart Connected Device Engine) only !
 *
 *  ESP 8266EX & ESP32 SoC Activities ...
 *  HoME CoNTROL & Smart Connected Device Engine Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 *
 *
 */


//define mySPI ESP32_SPI KEY=ARG


#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>

// the Smart-Connected-Device-Engine structures & types ..
#include <SCDE_s.h>

// provides WebIf, need the structures & types ...
#include "WebIf_Module.h"

// this Modules structures & types ...
#include "ESP32_SPI_Module_s.h"
#include "ESP32_SPI_Module.h"

//#include "SCDE_Main.h"
//#include "driver/gpio.h"



// ptr zur Fehlermeldung in allokierter strTextMultiple_t WENN NOCH KEIN FEHLER WAR
#define SCDE_OK  NULL

/*
static const char* I2S_TAG = "I2S";
#define SCDE_CHECK(a, str, ret) if (!(a)) {                                              \
        ESP_LOGE(I2S_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);       \
        return (ret);                                                                   \
        }
//  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
*/



// SCDE_CHECK MAKRO: Prüft Bedingung und gibt Fehler in allokierter strTextMultiple_t zurück
#define SCDE_CHECK(a, str) if (!(a)) {							\
	retMsg = malloc(sizeof(strTextMultiple_t));					\
	retMsg->strTextLen = asprintf(&retMsg->strText					\
		,"Error! '%s'"								\
		,str);									\
	return retMsg;									\
	}






// -------------------------------------------------------------------------------------------------

// set default build verbose - if no external override
#ifndef ESP32_SPI_Module_DBG  
#define ESP32_SPI_Module_DBG  5	// 5 is default
#endif 

// -------------------------------------------------------------------------------------------------



#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------



/*
 * Implemented Values for Keys
 */

// ESP32_SPI_SET_DISENA -> 'SDA_IO_PULLUP' -> Disabled|Enabled
//                             -> 'SCL_IO_PULLUP' -> Disabled|Enabled
SelectAData ESP32_SPI_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// ESP32_SPI_SET_I2C_MODE -> 'I2C_MODE' -> Master|Slave
SelectAData ESP32_SPI_I2C_MODE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Master"},
  {1,"Slave"}, 
  {0, NULL}
  };

/*
// ESP32_SPI_SET_IDLE_LV -> 'IDLE_LV' -> Low|High
SelectAData ESP32_SPI_LoHi[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Low"},
  {1,"High"}, 
  {0, NULL}
  };
// ESP32_SPI_SET_BLOCK -> 'PWM_BLOCK'-> High_Speed|Low_Speed
SelectAData ESP32_SPI_PWM_BLOCK[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"High_Speed"},
  {1,"Low_Speed"},
  {0, NULL}
  };
// ESP32_SPI_SET_TICK_SOURCE -> 'TICK_SOURCE'-> REF|APB_SLOW
SelectAData ESP32_SPI_TICK_SOURCE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"REF"},
  {1,"APB_SLOW"}, 
  {0, NULL}
  };
*/



/**
 * For Type: ESP32_SPI
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in ESP32_SPI_parsedKVInput_t
 */
enum ESP32_SPI_SET_IK {				// Bit #XX for debugging

  // Block #1 I2C Block to use
    ESP32_SPI_SET_I2C_NUM			// Bit #01 'I2C_NUM' -> 

  // Block #2 I2C Master/Slave ?
  , ESP32_SPI_SET_I2C_MODE			// Bit #02 'I2C_MODE' -> 

  // Block #3 I2C Pin connections
  , ESP32_SPI_SET_SDA_IO				// Bit #03 'SDA_IO' -> 
  , ESP32_SPI_SET_SDA_IO_PULLUP			// Bit #04 'SDA_IO_PULLUP' -> 
  , ESP32_SPI_SET_SCL_IO				// Bit #05 'SCL_IO' ->
  , ESP32_SPI_SET_SCL_IO_PULLUP			// Bit #06 'SCL_IO_PULLUP' ->

  // Block #4 I2C Pin connections
  , ESP32_SPI_SET_MASTER_CLOCK			// Bit #07 'MASTER_CLOCK' ->

  // Block #5 I2C Pin connections
  , ESP32_SPI_SET_SLAVE_10BIT_ENA		// Bit #08 'SLAVE_10BIT_ENA' ->

  // Block #6 I2C Pin connections
  , ESP32_SPI_SET_SLAVE_ADRESS			// Bit #09 'SLAVE_ADRESS' ->

// end marker
  , ESP32_SPI_SET_NUMBER_OF_IK			// Bit #10 MAX 64 IMPLEMENTED !

};

 

/**
 * For Type: ESP32_SPI
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum ESP32_SPI_Readings {			// Bit #XX for debugging

   ESP32_SPI_R_DUTY		= (1<<0)	// Bit #00 'Duty'  -> 

  ,ESP32_SPI_R_RESOLUTION	= (1<<1)	// Bit #01 'Resolution' -> 

  ,ESP32_SPI_R_NAME		= (1<<2)	// Bit #02 'name' + caps + ufid -> 

};



/**
 * For Type: ESP32_SPI
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()
 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t ESP32_SPI_Set_ImplementedKeys[] = {
// |                     affectedreadings						       	|  CMD

// for usage

// for configuration
   { 0												,"I2C_NUM" }		// #01
  ,{ 0												,"I2C_MODE" }		// #02
  ,{ 0												,"SDA_IO" }		// #03
  ,{ 0												,"SDA_IO_PULLUP" }	// #04
  ,{ 0												,"SCL_IO" }		// #05
  ,{ 0												,"SCL_IO_PULLUP" }	// #06
  ,{ 0												,"MASTER_CLOCK" }	// #07
  ,{ 0												,"SLAVE_10BIT_ENA" }	// #08
  ,{ 0												,"SLAVE_ADRESS" }	// #09
 
}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_SPI_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t ESP32_SPI_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_SPI_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t ESP32_SPI_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



// -------------------------------------------------------------------------------------------------



/*
 * DName: ESP32_SPI_Fn (SCDE Functions)
 * Desc: Stores function callbacks provided & made accessible for client modules using this module,
 *       for operation and helpers
 * Data: 
 */
ESP32_SPI_Fn_t ESP32_SPI_Fn = {
  ESP32_SPI_Module_spi_bus_add_device,
  ESP32_SPI_Module_spi_bus_remove_device
};



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_SPI_Module
 *  Desc: Data 'Provided By Module' for the ESP32_SPI module (functions + infos this module
 *        provides to SCDE)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
ProvidedByModule_t ESP32_SPI_ProvidedByModule = {   // A-Z order
  "ESP32_SPI"				// Type-Name of module -> on Linux libfilename.so !
  ,9					// size of Type-Name

  ,NULL					// Add
  ,ESP32_SPI_Attribute			// Attribute
  ,ESP32_SPI_Define			// Define
  ,NULL					// Delete
  ,NULL					// DirectRead
  ,NULL					// DirectWrite
  ,NULL					// Except
  ,NULL					// Get
  ,ESP32_SPI_IdleCb			// IdleCb
  ,ESP32_SPI_Initialize			// Initialize
  ,NULL					// Notify
  ,NULL					// Parse
  ,NULL					// Read
  ,NULL					// Ready
  ,NULL					// Rename
  ,ESP32_SPI_Set			// Set
  ,ESP32_SPI_Shutdown			// Shutdown
  ,NULL					// State
  ,NULL					// Sub
  ,ESP32_SPI_Undefine			// Undefine
  ,ESP32_SPI_Write			// Write
  ,&ESP32_SPI_Fn			// FnProvided
  ,sizeof(ESP32_SPI_Definition_t)	// Modul specific Size (Common_Definition_t + X)
};



/* -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Attribute
 *  Desc: Informs an Definition of this Type for attribute activities (set/del)
 *  Info: 'attrCmd' is the command text for the activity: set, del
 *        'attrName' is the attribute name text
 *        'attrVal' is the attribute value text
 *        THE attrVal CAN BE MANIPULATED / CORRECTED
 *  Para: Common_Definition_t *Common_Definition -> the belonging definition for the attribute-activitie
 *	  const uint8_t *attrCmdText -> ptr to attribute-command text "attrCmd"
 *	  const size_t attrCmdTextLen -> length of attribute-command text "attrCmd"
 *	  const uint8_t *attrNameText -> ptr to attribute-name text "attrName"
 *	  const size_t attrNameTextLen -> length of attribute-name text "attrName"
 *	  uint8_t **attrValTextPtr -> ptr to ptr holding attribute-value text "attrValue" - manipulation possible
 *	  size_t *attrValLenTextPtr -> ptr to length of attribute-value text "attrValue" - manipulation possible
 *  Rets: strTextMultiple_t* -> veto = error-text-string in allocated mem, or NULL = OK - no veto
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_SPI_Attribute(Common_Definition_t *Common_Definition
		,const uint8_t *attrCmdText
		,const size_t attrCmdTextLen
		,const uint8_t *attrNameText
		,const size_t attrNameTextLen
		,uint8_t **attrValTextPtr
		,size_t *attrValTextLenPtr)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  uint8_t *attrValText = *attrValTextPtr;
  size_t attrValTextLen = *attrValTextLenPtr;

  printf("ESP32_SPI_AttributeFN for defName:%.*s -> attrCmd:%.*s attrName:%.*s attrVal:%.*s\n"
	,Common_Definition->nameLen
	,Common_Definition->name
	,attrCmdTextLen
	,attrCmdText
  	,attrNameTextLen
	,attrNameText
	,(int) attrValTextLen
	,attrValText);



/*
  // set start of possible def-Name
  const uint8_t *defName = args;
  // set start of possible attr-Name
  const uint8_t *attrName = args;
  // a seek-counter
  int i = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrName != ' ') ) {i++;attrName++;}
  // length of def-Name
  size_t defNameLen = i;
  // seek to start position of attr-Name '\32'
  while( (i < argsLen) && (*attrName == ' ') ) {i++;attrName++;}
  // set start of possible attr-Val
  const uint8_t *attrVal = attrName;
  // a 2nd seek-counter
  int j = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrVal != ' ') ) {i++,j++;attrVal++;}
  // length of attr-Name
  size_t attrNameLen = j;
  // start position of attr-Val
  while( (i < argsLen) && (*attrVal == ' ') ) {i++;attrVal++;}
  // length of attr-Val
  size_t attrValLen = argsLen - i;
  // veryfy lengths > 0, definition 0 allowed
  if ( (defNameLen == 0) || (attrNameLen == 0) )
		{
		// response with error text
		asprintf(&retMsg
				,"Could not interpret command ''! Usage: Attr <defname> <attrname> [<attrval>]");
		return retMsg;
	//	}
// -------------------------------------------------------------------------------------------------
*/

  return retMsg;
}







/*
#include "freertos/ringbuf.h"


#include "soc/i2c_struct.h"
#include "soc/i2c_reg.h"
#include "driver/periph_ctrl.h"

static const char* I2C_TAG = "i2c";

#define I2C_CHECK(a, str, ret)  if(!(a)) {                                             \
        ESP_LOGE(I2C_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);      \
        return (ret);                                                                   \
        }

*/







/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Define
 *  Desc: Finalizes the defines a new "device" of 'ESP32_S0' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_SPI_Define(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
		  (ESP32_SPI_Definition_t*) Common_Definition;

  // for Fn response msg
  strTextMultiple_t *retMsg = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if ESP32_SPI_Module_DBG >= 5
  SCDEFn_at_ESP32_SPI_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,5
	,"DefineFn of Module '%.*s' is called to continue creation of Definition '%.*s' with args '%.*s'."
	,ESP32_SPI_Definition->common.module->ProvidedByModule->typeNameLen
	,ESP32_SPI_Definition->common.module->ProvidedByModule->typeName
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name
	,ESP32_SPI_Definition->common.definitionLen
	,ESP32_SPI_Definition->common.definition);
  #endif

// ------------------------------------------------------------------------------------------------

  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Expected Args!");

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

//  xSemaphoreTake(ESP32_SPI_Definition->def_mux
//    ,portMAX_DELAY);

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  ESP32_SPI_Definition->common.fd = -1;

  // store table of function callbacks provided & made accessible for client modules
  ESP32_SPI_Definition->ESP32_SPI_Fn = &ESP32_SPI_Fn;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  ESP32_SPI_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn_at_ESP32_SPI_M->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (ESP32_SPI_Definition->WebIf_Provided.WebIf_FnProvided) {

	ESP32_SPI_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &ESP32_SPI_ActiveResourcesDataA_forWebIf;

	ESP32_SPI_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &ESP32_SPI_ActiveResourcesDataB_forWebIf;
  }

  else	{

	SCDEFn_at_ESP32_SPI_M->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,ESP32_SPI_Definition->common.nameLen
		,ESP32_SPI_Definition->common.name
		,ESP32_SPI_Definition->common.module->ProvidedByModule->typeNameLen
		,ESP32_SPI_Definition->common.module->ProvidedByModule->typeName);
  }

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_ESP32_SPI_M->ParseKVInputArgsFn(ESP32_SPI_SET_NUMBER_OF_IK		// Num Implementated KEYs MAX
	,ESP32_SPI_Set_ImplementedKeys					// Implementated Keys
	,defArgsText								// our args text
	,defArgsTextLen);							// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,defArgsTextLen
		,defArgsText);

	if (parsedKVInput) {

		free(parsedKVInput);
	}

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // try 1 - arguments for configuration as i2c master ?

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 	( (1 << ESP32_SPI_SET_I2C_NUM)
					| (1 << ESP32_SPI_SET_I2C_MODE)
					| (1 << ESP32_SPI_SET_SDA_IO)
					| (1 << ESP32_SPI_SET_SDA_IO_PULLUP)
					| (1 << ESP32_SPI_SET_SCL_IO)
					| (1 << ESP32_SPI_SET_SCL_IO_PULLUP)
					| (1 << ESP32_SPI_SET_MASTER_CLOCK)
					);

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 	( (1 << ESP32_SPI_SET_SLAVE_10BIT_ENA)
					| (1 << ESP32_SPI_SET_SLAVE_ADRESS)
 					);
/*
  // process the set-args (key=value@) protocol
  retMsg = ESP32_SPI_ProcessKVInputArgs(ESP32_SPI_Definition,
		parsedKVInput,		// KVInput parsed
		defArgsText,		// our args text
		defArgsTextLen);	// our args text len*/

  // processing reports an problem. Args not taken. Return with MSG
  if (retMsg != SCDE_OK) {

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------
















/*
// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_SPI_SET_I2C_NUM)
			        | (1 << ESP32_SPI_SET_I2C_MODE)
			        | (1 << ESP32_SPI_SET_SDA_IO)
			        | (1 << ESP32_SPI_SET_SDA_IO_PULLUP)
			        | (1 << ESP32_SPI_SET_SCL_IO)
			        | (1 << ESP32_SPI_SET_SCL_IO_PULLUP) );

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_SPI_ProcessKVInputArgs(ESP32_SPI_Definition
    ,parsedKVInput				// KVInput parsed
    ,defArgsText				// our args text
    ,defArgsTextLen) ) {			// our args text len

    // Processing reports an problem. Args not taken. Response with error text.

    // alloc mem for retMsg
    retMsg = malloc(sizeof(strTextMultiple_t));

    // response with error text
    retMsg->strTextLen = asprintf(&retMsg->strText
      ,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
      ,defArgsTextLen
      ,defArgsText);

    // free allocated memory for query result key-field
    free(parsedKVInput);

    return retMsg;
  }

// ------------------------------------------------------------------------------------------------
*/
  // set affected readings
 // ESP32_SPI_SetAffectedReadings(ESP32_SPI_Definition
  //  ,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  //free(parsedKVInput);


// ------------------------------------------------------------------------------------------------

  // set up 1st idle Callback
  ESP32_SPI_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

// alternative end in case of errors - free/destroy all allocated things and return SCDE_FAIL.
/* err:

  if (parsedKVInput) {

    free(parsedKVInput);

  }

*/
  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_DirectWrite
 *  Desc: for 2 stage designs - called to give write job to 1st stage (this stage)
 *  Info: 
 *  Para: ESP32_SPI_Definition_t *ESP32_SPI_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
/*
strTextMultiple_t *
ESP32_SPI_DirectWrite(
	 Common_Definition_t *Common_Definition_Stage1
	,Common_Definition_t *Common_Definition_Stage2
	,Common_StageXCHG_t *Common_StageXCHG)
{
  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;
  // to adress 1st stage definition - make common ptr to modul specific ptr
  ESP32_SPI_Definition_t *ESP32_SPI_Definition_Stage1 =
	(ESP32_SPI_Definition_t*) Common_Definition_Stage1;
  // make common ptr to modul specific ptr
  ESP32_SPI_StageXCHG_t *ESP32_SPI_StageXCHG =
	(ESP32_SPI_StageXCHG_t*) Common_StageXCHG;
// -------------------------------------------------------------------------------------------------
// check 4 matching modules
// -------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------
  #if ESP32_SPI_Module_DBG >= 5
  SCDEFn_at_ESP32_SPI_M->Log3Fn(
	 ESP32_SPI_Definition_Stage1->common.name
	,ESP32_SPI_Definition_Stage1->common.nameLen
	,5
	,"DirectWriteFn of Definition '%.*s' (Module '%.*s') is called "
  	 "from Definition '%.*s' (Module '%.*s') to exec write job."
	,ESP32_SPI_Definition_Stage1->common.nameLen
	,ESP32_SPI_Definition_Stage1->common.name
	,ESP32_SPI_Definition_Stage1->common.module->ProvidedByModule->typeNameLen
	,ESP32_SPI_Definition_Stage1->common.module->ProvidedByModule->typeName
	,Common_Definition_Stage2->nameLen
	,Common_Definition_Stage2->name
	,Common_Definition_Stage2->module->ProvidedByModule->typeNameLen
	,Common_Definition_Stage2->module->ProvidedByModule->typeName);
  #endif
// -------------------------------------------------------------------------------------------------
  return retMsg;
}
*/


/*
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int //feedModuleTask
ESP32_SPI_IdleCb(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
		  (ESP32_SPI_Definition_t*) Common_Definition;

  #if ESP32_SPI_Module_DBG >= 5
  printf("\n|ESP32_SPI_IdleCb, Def:%.*s>"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------




  // set up next idle Callback
  ESP32_SPI_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
ESP32_SPI_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot_at_ESP32_SPI_M = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn_at_ESP32_SPI_M = SCDERootptr->SCDEFn;

  SCDEFn_at_ESP32_SPI_M->Log3Fn(ESP32_SPI_ProvidedByModule.typeName
		  ,ESP32_SPI_ProvidedByModule.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,ESP32_SPI_ProvidedByModule.typeNameLen
		  ,ESP32_SPI_ProvidedByModule.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t *
ESP32_SPI_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
	(ESP32_SPI_Definition_t*) Common_Definition;

  #if ESP32_SPI_Module_DBG >= 5
  printf("\n|ESP32_SPI_Set, Name:%.*s, got args:%.*s>"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_ESP32_SPI_M->ParseKVInputArgsFn(ESP32_SPI_SET_NUMBER_OF_IK	// Num Implementated KEYs MAX for Set Fn
	,ESP32_SPI_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
//  parsedKVInput->forbiddenKVBF = ( (1 << ESP32_SPI_SET_CNT_UNIT) );
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_SPI_ProcessKVInputArgs(ESP32_SPI_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_SPI_SetAffectedReadings(ESP32_SPI_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine ESP32_SPI_Definition.common.Name'
 *  Para: ESP32_SPI_Definition_t *ESP32_SPI_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_SPI_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
	(ESP32_SPI_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if ESP32_SPI_Module_DBG >= 5
  printf("\n|ESP32_SPI_Shutdown, Name:%.*s>"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_SPI_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
	(ESP32_SPI_Definition_t*) Common_Definition;

  #if ESP32_SPI_Module_DBG >= 5
  printf("\n|ESP32_SPI_Undefine, Name:%.*s>"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name);

  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"ESP32_SPI_Undefine, Name:%.*s"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name);

  return retMsg;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_Write
 *  Desc: Is called to write data to an 'Definition' of 'ESP32_SPI' Module.
 *  Info: 
 *  Para: Common_Definition_t* Common_Definition -> the 'Definition' that should write the data 
 *                                                  (cast to ESP32_SPI_Definition_t*)
 *        xString_t data          -> data that should be written (characters in allocated mem + len) 
 *  Rets: xMultipleStringSLTQE_t* -> response: ptr to an singly linked tail queue element with return
 *                                   message in allocated memory, or NULL = OK / No message
 * -------------------------------------------------------------------------------------------------
 */
xMultipleStringSLTQE_t*
ESP32_SPI_Write(Common_Definition_t *Common_Definition,
		       xString_t data)
{

  // make common ptr to modul specific ptr
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
		  (ESP32_SPI_Definition_t*) Common_Definition;

  // for Fn response msg
  xMultipleStringSLTQE_t *retMsgMultipleStringSLTQE = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if ESP32_SPI_Module_DBG >= 7
  SCDEFn_at_ESP32_SPI_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,7
	,"WriteFn of Module '%.*s' is called for Definition '%.*s'. Got %d bytes raw data."
	,ESP32_SPI_Definition->common.module->ProvidedByModule->typeNameLen
	,ESP32_SPI_Definition->common.module->ProvidedByModule->typeName
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name
	,data.length);
  #endif

// -------------------------------------------------------------------------------------------------


  return retMsgMultipleStringSLTQE;
}


















/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: ESP32_SPI_Definition_t *ESP32_SPI_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: strTextMultiple_t* -> SCDE_OK, or error txts - for log
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_SPI_ProcessKVInputArgs(ESP32_SPI_Definition_t *ESP32_SPI_Definition,
	parsedKVInputArgs_t *parsedKVInput,
	uint8_t *argsText,
	size_t argsTextLen)
{
 printf("|0");
  // start without error
  strTextMultiple_t *retMsg = SCDE_OK;


 // remember the readings affected by the parsing process
  uint32_t affectedReadings = 0;

// -------------------------------------------------------------------------------------------------
// 1. Step: Create backup structures, if required mirror current effective values.
// -------------------------------------------------------------------------------------------------
/*
  // Block #01 Backup the current I2C-Block
  uint8_t new_i2c_num;
  new_i2c_num = ESP32_SPI_Definition->i2c_num;

// -------------------------------------------------------------------------------------------------

  // Block #02 Backup the current I2C mode
  i2c_mode_t new_i2c_mode;
  new_i2c_mode = ESP32_SPI_Definition->i2c_config.mode;

// -------------------------------------------------------------------------------------------------

  // Block #03 Backup the current SDA & SCL pin configuration used by I2C
  gpio_num_t new_sda_io_num;
  gpio_pullup_t new_sda_pullup_en;
  gpio_num_t new_scl_io_num;
  gpio_pullup_t new_scl_pullup_en;

  new_sda_io_num = ESP32_SPI_Definition->i2c_config.sda_io_num;
  new_sda_pullup_en = ESP32_SPI_Definition->i2c_config.sda_pullup_en;
  new_scl_io_num = ESP32_SPI_Definition->i2c_config.scl_io_num;
  new_scl_pullup_en = ESP32_SPI_Definition->i2c_config.scl_pullup_en;

// -------------------------------------------------------------------------------------------------

  // Block #04 Backup the current I2C clock speed
  uint32_t new_clk_speed;
  new_clk_speed = ESP32_SPI_Definition->i2c_config.master.clk_speed;

// -------------------------------------------------------------------------------------------------

  // Block #05 Backup the current setting for 10Bit adressing in slave mode
  uint8_t new_addr_10bit_en;
  new_addr_10bit_en = ESP32_SPI_Definition->i2c_config.slave.addr_10bit_en;

// -------------------------------------------------------------------------------------------------

  // Block #06 Backup the current I2C slave adress in slave
  uint8_t new_slave_addr;
  new_slave_addr = ESP32_SPI_Definition->i2c_config.slave.slave_addr;

// -------------------------------------------------------------------------------------------------
*/











// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'Block' KEY in advance here, because we need this information early
  // Block=High_Speed|Low_Speed
  // -> Setzt den Hardware-PWM-Block des ESP32 (0=HighSpeed / 1= LowSpeed) der verwendet werden soll
  // -> Sets the hardware-PWM-Block of the ESP32 (0=HighSpeed / 1= LowSpeed) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_BLOCK) ) {
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_BLOCK].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_BLOCK].len, &newBlock, ESP32_SPI_PWM_BLOCK)
		&& (newBlock <= 1) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
  /*
  // we need to process the 'CHANNEL' KEY in advance here, because we need this information early
  // CHANNEL=[0-7]
  // -> Setzt den Hardware-PWM-Kanal des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware-pwm-channel of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_CHANNEL) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_CHANNEL].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_CHANNEL].len, &newChannel) 
		&& (newChannel <= 7) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'TIMER' KEY in advance here, because we need this information early
  // TIMER=[0-3]
  // -> Setzt den Hardware-Timer f\FCr den gew\E4hlten PWM-Kanal des ESP32 (0-3) der verwendet werden soll
  // -> Sets the hardware-timer for the choosen pwm-channel of the ESP32 (0-3) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_TIMER) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_TIMER].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_TIMER].len, &newTimer) 
		&& (newTimer <= 3) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*
  // block #4 get current assigned / connected GPIO
  uint8_t newGPIO = ESP32_SPI_Definition->GPIO;
  // block #5 reserve for new ATT
  uint32_t newATTVal;
  // block #6 reserve for new AVU
  char newAverageUnit[3];	
  // block #7  get ESP32 PWM channel configuration from selected channel
  // this stores our temp values
  ESP32_PWM_Channel_t newPWM_Channel;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * newChannel));
  // access low speed channels (instead of high speed channels)?
  if (newBlock) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // move data to temp storage
  memcpy(&newPWM_Channel, pPWM_Channel, sizeof(ESP32_PWM_Channel_t));
  // block #8  get ESP32 PWM timer configuration from selected timer
  // this stores our temp values
  ESP32_PWM_Timer_t newPWM_Timer;
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * newTimer));
  // access low speed timers (instead of high speed timers)?
  if (newBlock) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
  // move data to temp storage
  memcpy(&newPWM_Timer, pPWM_Timer, sizeof(ESP32_PWM_Timer_t));
  // store choosen timer in choosen channel
  newPWM_Channel.TIMER_SEL = newTimer;
*/



// ------------------------------------------------------------------------------------------------
// 2. Step: Process the possible input keys



// -------------------------------------------------------------------------------------------------
// I2C_NUM=[0-9] -> Setzt den I2C-Block der verwendet werden soll (0-1) 
// I2C_NUM=[0-9] -> Set the I2C-Block that should be used (0-1) 
/*
  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_I2C_NUM) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_NUM].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_NUM].len
		,&number)) {

		if (number < I2C_NUM_MAX) {

			// valid, take it
			new_i2c_num = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_NUM].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_NUM");
		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// I2C_MODE=[Master|Slave] -> Setzt den I2C modus ()
// I2C_MODE=[Master|Slave] -> Set the I2C mode ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_I2C_MODE) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_MODE].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_MODE].len, &number, ESP32_SPI_I2C_MODE)) {

		// valid, take it
		new_i2c_mode = number;

		// mark affected readings for TX
		affectedReadings |= 
			parsedKVInput->keyData_t[ESP32_SPI_SET_I2C_MODE].affectedReadings;

//		// Push processed CMD to to Response ...
//		RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_MODE");
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO=[0-9] -> Setzt den SDA IO Pin für I2C (?)
// SDA_IO=[0-9] -> Set the SDA IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SDA_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO].len, &number)) {

		if (GPIO_IS_VALID_OUTPUT_GPIO(number)) {

			// valid, take it
			new_sda_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SDA IO Pin für I2C ()
// SDA_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SDA IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SDA_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO_PULLUP].len, &number, ESP32_SPI_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_sda_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_sda_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SDA_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO=[0-9] -> Setzt den SCL IO Pin für I2C (?)
// SCL_IO=[0-9] -> Set the SCL IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SCL_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO].len, &number)) {

		if ((GPIO_IS_VALID_OUTPUT_GPIO(number)) ||
    			(GPIO_IS_VALID_GPIO(number) && new_i2c_mode == I2C_MODE_SLAVE)) {

			// valid, take it
			new_scl_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SCL_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SCL IO Pin für I2C ()
// SCL_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SCL IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SCL_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO_PULLUP].len, &number, ESP32_SPI_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_scl_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_scl_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=CLA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// MASTER_CLOCK=[0-9] -> Setzt den I2C-Takt (0-1) 
// MASTER_CLOCK=[0-9] -> Set the I2C-Clock (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_MASTER_CLOCK) {

	uint32_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_MASTER_CLOCK].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_MASTER_CLOCK].len, &number)) {

//		if (number < 65000) { //?????????????????????????????

			// valid, take it
			new_clk_speed = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_MASTER_CLOCK].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=MASTER_CLOCK");
//		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Setzt 10Bit Adressierung - im Slave-Mode für I2C ()
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Set 10Bit adresing - in slave-mode for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SLAVE_10BIT_ENA) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_SPI_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SLAVE_10BIT_ENA].len, &number, ESP32_SPI_DisEna)) {

//		if (number < 65000) { //?????????????????????????????


			// valid, take it
			new_addr_10bit_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SLAVE_10BIT_ENA].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_10BIT_ENA");
//		}

		// invalid input detected ?
//		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// SLAVE_ADRESS=[0-9] -> Setzt die I2C-Slave-Adrsse (0-1) 
// SLAVE_ADRESS=[0-9] -> Set the I2C-Slave-Adress (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_SPI_SET_SLAVE_ADRESS) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_SLAVE_ADRESS].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_SLAVE_ADRESS].len
		,&number)) {

		if (number < 100) { //?????????????????????????????

			// valid, take it
			new_slave_addr = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_SPI_SET_SLAVE_ADRESS].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_ADRESS");
		}
	}

	// invalid input detected ?
	else return true;
  }










*/




















/*
//>Caps Bit 0---------------------------------------------------------------------------------------
  // on=[ ] -> Setze Kanal an (0-x)
  // on=[ ] -> Set channel on (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_on)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_on].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
//--------------------------------------------------------------------------------------------------
  // off=[ ] -> Setze Kanal aus (0-x)
  // off=[ ] -> Set channel off (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_off)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_off].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=off");
	}
//>Caps Bit 1---------------------------------------------------------------------------------------
  // max=[ ] -> Setze Kanal maximal (0-x)
  // max=[ ] -> Set channel maximum (0-x) 
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_max)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_max].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=max");
	}
//--------------------------------------------------------------------------------------------------
  // min=[ ] -> Setze Kanal minimal (0-x)
  // min=[ ] -> Set channel minimal (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_min)
	{
	// New Value = Min
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_min].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=min");
	}
//>Caps Bit 2---------------------------------------------------------------------------------------
  // val=[0-9] -> Setze Wert f\FCr Kanal (uint8) (0-x)
  // val=[0-9] -> Set value for channel (uint8) (0-x)
 else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_val)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_val].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_val].len, &NewVal))
		{
		// val input value clipping
		if (NewVal > SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax;
			}
		else if (NewVal < SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin;
			}
		// save mirror
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_val].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=val");
		}
	}
//>Caps Bit 3---------------------------------------------------------------------------------------
  // dim=[0-9] -> Setze dimmer f\FCr Kanal (uint8) (0-x)
  // dim=[0-9] -> Set dimming for channel (uint8) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_dim)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].len, &NewVal))
		
		{
		// dim input value clipping
		if (NewVal > 100) NewVal = 100;
		else if (NewVal < 0) NewVal = 0;
		// calculate val from dim
		NewVal = ( (NewVal *
			(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
			SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) /
			100 );
		// New Value = calculated from input
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// save mirror
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=dim");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_name].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) )
		{	
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_name].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_caps)
	{
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_caps].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
*/

/*
  // ATT=[0-9]
  // -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Z\E4hlerstand
  // -> Set alltime-total-tics meeting the currend meter-reading
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_ATT) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &newATTVal)) {
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= newATTVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------
  // AVU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Durchschnitts-Verbrauchs-Wert (char[3])
  // -> Set unit for average-consumption-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_AVU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &newAverageUnit
		,sizeof (newAverageUnit) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		,3) ) {
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1---------------------------------------------------------------------------------------
  // AVF=[0-9.]
  // -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // -> Set average consumption calculation factor (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_AVF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");
		}
	// invalid input detected ?
	else return true;
  }
//--------------------------------------------------------------------------------------------------
  // ATU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Allzeit-Gesamt-Wert (char[3])
  // -> Set unit for alltime-total-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_ATU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		 {
		// store the value to temp
		//befehl hier!;
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 2---------------------------------------------------------------------------------------
  // ATF=[0-9.]
  // -> Setze Umrechnungsfaktor f\FCr den Allzeit-Total-Wert (float)
  // -> Set factor for alltime total value (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_ATF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");
		}
	// invalid input detected ?
	else return true;
  }
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_SPI_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_SPI_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 3---------------------------------------------------------------------------------------
  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))
		{
		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
		{	
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{
	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;
//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");
	}
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_SPI_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_SPI_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_CH1_HCTRL_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_HCTRL_MODE].len, &NewMode, ESP32_SPI_CTRL_MODE) ) {
		// store ne value
		ESP32_SPI_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_SPI_SET_CH1_POS_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_SPI_SET_CH1_POS_MODE].len, &NewMode, ESP32_SPI_CH_MODE) ) {
		// store ne value
		ESP32_SPI_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/



// ------------------------------------------------------------------------------------------------
// 3. Step: check if all required Key=Value components for operation are included
//          -> if not, return with msg

  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! NOT all required Key=Value args found!");

	return retMsg;
  }



// ------------------------------------------------------------------------------------------------
// 4. Step: check if forbidden Key=Value components are included
//          -> if not, return with msg

  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! FORBIDDEN Key=Value args found!");

	return retMsg;
  }













// ------------------------------------------------------------------------------------------------
// 5. Step: Changes will happen, deinit old ...


/*
esp_err_t i2c_driver_delete(i2c_port_t i2c_num)
{

    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(p_i2c_obj[i2c_num] != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);
    i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

    uint32_t intr_mask = I2C_MASTER_TRAN_COMP_INT_ENA_M |
                         I2C_TIME_OUT_INT_ENA_M |
                         I2C_TRANS_COMPLETE_INT_ENA_M |
                         I2C_TRANS_START_INT_ENA_M |
                         I2C_TX_SEND_EMPTY_INT_ENA_M |
                         I2C_ARBITRATION_LOST_INT_ENA_M |
                         I2C_ACK_ERR_INT_ENA_M |
                         I2C_RXFIFO_OVF_INT_ENA_M |
                         I2C_RX_REC_FULL_INT_ENA_M |
                         I2C_SLAVE_TRAN_COMP_INT_ENA_M;

    CLEAR_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

    esp_intr_free(p_i2c->intr_handle);

    p_i2c->intr_handle = NULL;

    if (p_i2c->cmd_mux) {
        xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);
        vSemaphoreDelete(p_i2c->cmd_mux);
    }
    if (p_i2c->cmd_sem) {
        vSemaphoreDelete(p_i2c->cmd_sem);
    }
    if (p_i2c->slv_rx_mux) {
        vSemaphoreDelete(p_i2c->slv_rx_mux);
    }
    if (p_i2c->slv_tx_mux) {
        vSemaphoreDelete(p_i2c->slv_tx_mux);
    }
    if (p_i2c->rx_ring_buf) {
        vRingbufferDelete(p_i2c->rx_ring_buf);
        p_i2c->rx_ring_buf = NULL;
        p_i2c->rx_buf_length = 0;
    }
    if (p_i2c->tx_ring_buf) {
        vRingbufferDelete(p_i2c->tx_ring_buf);
        p_i2c->tx_ring_buf = NULL;
        p_i2c->tx_buf_length = 0;
    }

    free(p_i2c_obj[i2c_num]);
    p_i2c_obj[i2c_num] = NULL;

    return ESP_OK;
}
*/



// ------------------------------------------------------------------------------------------------
// 6. Step: Make the changes effective ...
/*
  // block #1 store/use I2C Block (0 / 1)
  if (parsedKVInput->keysFoundBF | (1 << ESP32_SPI_SET_I2C_NUM) ) {

	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 I2C_NUM=%d>"
		,new_i2c_num);	
  	#endif

	// enable i2c 0
	if (new_i2c_num == I2C_NUM_0) {

		periph_module_enable(PERIPH_I2C0_MODULE);
	}

	// enable i2c 1
	else if (new_i2c_num == I2C_NUM_1) {

		periph_module_enable(PERIPH_I2C1_MODULE);
	}

	// store assigned I2C Block
	ESP32_SPI_Definition->i2c_num = 
		new_i2c_num;
  }

// ------------------------------------------------------------------------------------------------

  // block #2 store/use I2C Mode (Master/Slave)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_SPI_SET_I2C_MODE) ) ) {

	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 I2C_MODE=%d>"
		,new_i2c_mode);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set rx data msb first
	I2C[new_i2c_num]->ctr.rx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// set tx data msb first
	I2C[new_i2c_num]->ctr.tx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// mode for master or slave
	I2C[new_i2c_num]->ctr.ms_mode = new_i2c_mode;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.sda_force_out = 1;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.scl_force_out = 1;

	// sample at high level of clock
	I2C[new_i2c_num]->ctr.sample_scl_level = 0;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;

		I2C[new_i2c_num]->fifo_conf.fifo_addr_cfg_en = 0;

		I2C[new_i2c_num]->fifo_conf.rx_fifo_full_thrhd =
			I2C_FIFO_FULL_THRESH_VAL;

		I2C[new_i2c_num]->fifo_conf.tx_fifo_empty_thrhd =
			I2C_FIFO_EMPTY_THRESH_VAL;

		I2C[new_i2c_num]->int_ena.rx_fifo_full = 1;

		I2C[new_i2c_num]->ctr.trans_start = 0;
	}

	// master mode ?
	else {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;
	}

	// ??
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Mode
	ESP32_SPI_Definition->i2c_config.mode
		= new_i2c_mode;
  }

// ------------------------------------------------------------------------------------------------

  // block #3 store/use I2C Pin connections
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_SPI_SET_SDA_IO)
			       		| (1 << ESP32_SPI_SET_SDA_IO_PULLUP)
			       		| (1 << ESP32_SPI_SET_SCL_IO)
			       		| (1 << ESP32_SPI_SET_SCL_IO_PULLUP) ) ) {

	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 I2C Pins SDA_IO=%d, SDA_IO_PULLUP=%d,SCL_IO=%d, SCL_IO_PULLUP=%d,>"
		,new_sda_io_num,new_sda_pullup_en,new_scl_io_num,new_scl_pullup_en);	
  	#endif



*/
/*


  SCDE_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR);
  SCDE_CHECK(((GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num))), I2C_SDA_IO_ERR_STR);
  SCDE_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
              (GPIO_IS_VALID_GPIO(scl_io_num) && mode == I2C_MODE_SLAVE),
              I2C_SCL_IO_ERR_STR);
  SCDE_CHECK((sda_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num)) ||
               sda_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
  SCDE_CHECK((scl_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
               scl_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
*/
/*
	int sda_in_sig, sda_out_sig, scl_in_sig, scl_out_sig;

	// prepare the i2c gpio settings according to used hardware 
	switch (new_i2c_num) {

		case I2C_NUM_1:
			sda_out_sig = I2CEXT1_SDA_OUT_IDX;
			sda_in_sig = I2CEXT1_SDA_IN_IDX;
			scl_out_sig = I2CEXT1_SCL_OUT_IDX;
			scl_in_sig = I2CEXT1_SCL_IN_IDX;
			break;

		case I2C_NUM_0:
			default:
			sda_out_sig = I2CEXT0_SDA_OUT_IDX;
			sda_in_sig = I2CEXT0_SDA_IN_IDX;
			scl_out_sig = I2CEXT0_SCL_OUT_IDX;
			scl_in_sig = I2CEXT0_SCL_IN_IDX;
			break;
	}

	// sda gpio configuration
	if (new_sda_io_num >= 0) {

		gpio_set_level(new_sda_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_sda_io_num], PIN_FUNC_GPIO);

		gpio_set_direction(new_sda_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

		if (new_sda_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_sda_io_num, GPIO_PULLUP_ONLY);
		 } 

		else {

			gpio_set_pull_mode(new_sda_io_num, GPIO_FLOATING);
 		}

		gpio_matrix_out(new_sda_io_num, sda_out_sig, 0, 0);

		gpio_matrix_in(new_sda_io_num, sda_in_sig, 0);
	}

	// scl gpio configuration
	if (new_scl_io_num >= 0) {

		gpio_set_level(new_scl_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_scl_io_num], PIN_FUNC_GPIO);

		if (new_i2c_mode == I2C_MODE_MASTER) {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

			gpio_matrix_out(new_scl_io_num, scl_out_sig, 0, 0);
		}

		else {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT);
		}

		if (new_scl_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_scl_io_num, GPIO_PULLUP_ONLY);
		}

		else {

			gpio_set_pull_mode(new_scl_io_num, GPIO_FLOATING);
		}

		gpio_matrix_in(new_scl_io_num, scl_in_sig, 0);
 	}

	// store assigned I2C Pin connections
	ESP32_SPI_Definition->i2c_config.sda_io_num
		= new_sda_io_num;

	ESP32_SPI_Definition->i2c_config.sda_pullup_en
		= new_sda_pullup_en;

	ESP32_SPI_Definition->i2c_config.scl_io_num
		= new_scl_io_num;

	ESP32_SPI_Definition->i2c_config.scl_pullup_en
		= new_scl_pullup_en;
  }

// ------------------------------------------------------------------------------------------------

  // block #4 store/use I2C clock speed (when use as master only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_SPI_SET_MASTER_CLOCK) ) ) {

	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 MASTER_CLOCK=%d>"
		,new_clk_speed);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set frequency
	int half_cycle = ( I2C_APB_CLK_FREQ / new_clk_speed ) / 2;
	I2C[new_i2c_num]->scl_low_period.period =
		 half_cycle - 1;
	I2C[new_i2c_num]->scl_high_period.period =
		( I2C_APB_CLK_FREQ / new_clk_speed ) - half_cycle - 1;

	// set timing for start signal
	I2C[new_i2c_num]->scl_start_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_rstart_setup.time = half_cycle;

	// set timing for stop signal
	I2C[new_i2c_num]->scl_stop_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_stop_setup.time = half_cycle;

	// set timing for data
	I2C[new_i2c_num]->sda_hold.time = half_cycle / 2;
	I2C[new_i2c_num]->sda_sample.time = half_cycle / 2;

	// set timeout of receving data
	I2C[new_i2c_num]->timeout.tout = 200000;

	// ???
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Pin connections
	ESP32_SPI_Definition->i2c_config.master.clk_speed =
		new_clk_speed;
  }

// ------------------------------------------------------------------------------------------------

  // block #5 store/use I2C 10bit enable (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_SPI_SET_SLAVE_10BIT_ENA) ) ) {
*/
/*	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/
/*
	// store assigned I2C Pin connections
	ESP32_SPI_Definition->i2c_config.slave.addr_10bit_en =
		new_addr_10bit_en;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.en_10bit =
			new_addr_10bit_en;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------

  // block #6 store/use I2C slave adress (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_SPI_SET_SLAVE_ADRESS) ) ) {
*/
/*	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/
/*
	// store assigned I2C Pin connections
	ESP32_SPI_Definition->i2c_config.slave.slave_addr =
		new_slave_addr;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.addr =
			new_slave_addr;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------






*/
/*
  // block #1 store assigned PWM-Block (low speed / high speed)
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_SPI_SET_BLOCK) ) ) {
	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif
	// store assigned PWM-Block
	ESP32_SPI_Definition->Block = newBlock;
  }
  // block #2 store assigned PWM Channel
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_SPI_SET_CHANNEL) ) ) {
	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#02 PWM_Channel=%d>"
		,newChannel);	
  	#endif
	// store assigned PWM Channel
	ESP32_SPI_Definition->Channel = newChannel;
  }
  // block #3 store assigned PWM Timer
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_SPI_SET_TIMER) ) ) {
	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#03 PWM_Timer=%d>"
		,newTimer);	
  	#endif
	// store assigned PWM Timer
	ESP32_SPI_Definition->Timer = newTimer;
  }
  // block #4 store assigned / connected GPIO
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_SPI_SET_GPIO) ) ) {
	#if ESP32_SPI_Module_DBG >= 5
	printf("|W B#04 PWM_GPIO=%d>"
		,newGPIO);	
  	#endif
	// store assigned GPIO
	ESP32_SPI_Definition->GPIO = newGPIO;
	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newGPIO], PIN_FUNC_GPIO);
	// set GPIO as output
	gpio_set_direction(newGPIO, GPIO_MODE_OUTPUT);
	// configure for high-speed or low-speed ?
	if (newBlock) {
		// setup gpio matrix for low speed
	}
	else {
		// setup gpio matrix for high speed
		gpio_matrix_out(newGPIO, LEDC_HS_SIG_OUT0_IDX + newChannel, 0, 0);
		
	}
  }
  // block #5 store ESP32 pwm configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_SPI_SET_TIMER)
				   | (1 << ESP32_SPI_SET_SIG_OUT_EN)
				   | (1 << ESP32_SPI_SET_IDLE_LV)
				   | (1 << ESP32_SPI_SET_HPOINT)
				   | (1 << ESP32_SPI_SET_DUTY) ) ) {
	// store ESP32 PWM configuration registers
	memcpy(pPWM_Channel, &newPWM_Channel, sizeof(ESP32_PWM_Channel_t));
	# if ESP32_SPI_Module_DBG >= 5
	printf("|ESP32_PWM_Channel_s addr=%p>"
		,pPWM_Channel);
	SCDEFn_at_ESP32_SPI_M->HexDumpOutFn ("dump"
		,pPWM_Channel
		, sizeof(ESP32_PWM_Channel_t) );
	# endif
  }
  // block #6 store ESP32 pwm-timer configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_SPI_SET_TIMER)
				   | (1 << ESP32_SPI_SET_RESOLUTION )
				   | (1 << ESP32_SPI_SET_TICK_SOURCE)
			   	   | (1 << ESP32_SPI_SET_FREQ_HZ) ) ) {
	// reset? It seems that a reset is needed to start timer
	newPWM_Timer.RESET = 0;
	// low speed timer? -> needs 'LOW_SPEED_UPDATE' bit set to take settings
	if (!newBlock) newPWM_Timer.LOW_SPEED_UPDATE = 1;
	// store ESP32 timer configuration registers
	memcpy(pPWM_Timer, &newPWM_Timer, sizeof(ESP32_PWM_Timer_t));
	# if ESP32_SPI_Module_DBG >= 5
	printf("|ESP32_PWM_Timer_s addr=%p>"
		,pPWM_Timer);
	SCDEFn_at_ESP32_SPI_M->HexDumpOutFn ("dump"
		,pPWM_Timer
		, sizeof(ESP32_PWM_Timer_t) );
	# endif
  }
*/


// ------------------------------------------------------------------------------------------------
// 7. Step:Set affected readings




  return retMsg;

}
















/*
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_val)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&val=%u",(uint) SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val);
	}
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_dim)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&dim=%u",(100 *
		(SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val -
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) / 
		(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) );
	}
//>Add Readings Bit 02 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += SwITCH_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=000F");						// 0b1111 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
//>always add Reading - state ----------------------------------------------------------------------
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	if (SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val == 0)
		RespArgsWPos += os_sprintf(RespArgsWPos, "state=off");
	else  RespArgsWPos += os_sprintf(RespArgsWPos, "state=on");
//--------------------------------------------------------------------------------------------------
*/
















/**
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_SPI_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: ESP32_SPI_Definition_t *ESP32_SPI_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_SPI_SetAffectedReadings(ESP32_SPI_Definition_t* ESP32_SPI_Definition
	,uint64_t affectedReadings)
{
/*
 affectedReadings = 0xfffffffffffffff;
  // do we have updates?
  if (affectedReadings) {
  SCDEFn_at_ESP32_SPI_M->readingsBeginUpdateFn((Common_Definition_t*) ESP32_SPI_Definition);
  }
  // we have no updates
  else return false;
// -----------------------------------------------------------------------------------------------
  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_SPI_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (ESP32_SPI_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_SPI_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (ESP32_SPI_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  // add reading 'Duty'
  if (affectedReadings & ESP32_SPI_R_DUTY) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Duty");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,pPWM_Channel->DUTY);
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  // add reading 'Resolution'
  if (affectedReadings & ESP32_SPI_R_RESOLUTION) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Resolution");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,(1 << pPWM_Timer->RESOLUTION) );
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_SPI_R_AV01_AV05_AV15) {
	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...
	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );
		}
	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );
		}
	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	
		}
	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Factor' //avf'
  if (affectedReadings & ESP32_SPI_R_AVF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) ESP32_SPI_Definition->IB01_AverageFactor	
		,(int) ( (ESP32_SPI_Definition->IB01_AverageFactor -
		(int) ESP32_SPI_Definition->IB01_AverageFactor) * 10000) );
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Unit' //avu'
  if (affectedReadings & ESP32_SPI_R_AVU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_SPI_Definition->IB01_AverageUnit);
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & ESP32_SPI_R_ATF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (ESP32_SPI_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (ESP32_SPI_Definition->IB01_AlltimeTotalFactor -
		(int) ESP32_SPI_Definition->IB01_AlltimeTotalFactor) * 10000) );
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & ESP32_SPI_R_ATU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_SPI_Definition->IB01_AlltimeTotalUnit);
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------
/*
  // add reading 'Debounce' //deb'
  if (affectedReadings & ESP32_SPI_R_DEB) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_SPI_Definition->IB01_Debounce);
	SCDEFn_at_ESP32_SPI_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_SPI_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_SPI_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
//  SCDEFn_at_ESP32_SPI_M->readingsEndUpdateFn((Common_Definition_t*) ESP32_SPI_Definition);


  return true;
}








































































/*
 Replace this include with
 #include "driver/spi_master_lobo.h"
 if the driver is located in esp-isf/components
*/
#include "freertos/FreeRTOS.h"
#include <string.h>
#include <stdio.h>
#include "soc/gpio_sig_map.h"
#include "soc/spi_reg.h"
#include "soc/dport_reg.h"
#include "soc/rtc_cntl_reg.h"
#include "rom/ets_sys.h"
#include "esp_types.h"
#include "esp_attr.h"
#include "esp_log.h"
#include "esp_err.h"
#include "freertos/semphr.h"
#include "freertos/xtensa_api.h"
#include "freertos/task.h"
#include "freertos/ringbuf.h"
#include "soc/soc.h"
#include "soc/dport_reg.h"
#include "soc/uart_struct.h"
#include "driver/uart.h"
#include "driver/gpio.h"
#include "driver/periph_ctrl.h"
#include "esp_heap_caps.h"
#include "driver/periph_ctrl.h"
//#include "spi_master_lobo.h"


static ESP32_SPI_Module_spi_host_t *spihost[3] = {NULL};


static const char *SPI_TAG = "spi_lobo_master";
#define SPI_CHECK(a, str, ret_val) \
    if (!(a)) { \
        ESP_LOGE(SPI_TAG,"%s(%d): %s", __FUNCTION__, __LINE__, str); \
        return (ret_val); \
    }

/*
 Stores a bunch of per-spi-peripheral data.
*/
typedef struct {
    const uint8_t spiclk_out;       //GPIO mux output signals
    const uint8_t spid_out;
    const uint8_t spiq_out;
    const uint8_t spiwp_out;
    const uint8_t spihd_out;
    const uint8_t spid_in;          //GPIO mux input signals
    const uint8_t spiq_in;
    const uint8_t spiwp_in;
    const uint8_t spihd_in;
    const uint8_t spics_out[3];     // /CS GPIO output mux signals
    const uint8_t spiclk_native;    //IO pins of IO_MUX muxed signals
    const uint8_t spid_native;
    const uint8_t spiq_native;
    const uint8_t spiwp_native;
    const uint8_t spihd_native;
    const uint8_t spics0_native;
    const uint8_t irq;              //irq source for interrupt mux
    const uint8_t irq_dma;          //dma irq source for interrupt mux
    const periph_module_t module;   //peripheral module, for enabling clock etc
    spi_dev_t *hw;                  //Pointer to the hardware registers
} spi_signal_conn_t;

/*
 Bunch of constants for every SPI peripheral: GPIO signals, irqs, hw addr of registers etc
*/
static const spi_signal_conn_t io_signal[3]={
    {
        .spiclk_out=SPICLK_OUT_IDX,
        .spid_out=SPID_OUT_IDX,
        .spiq_out=SPIQ_OUT_IDX,
        .spiwp_out=SPIWP_OUT_IDX,
        .spihd_out=SPIHD_OUT_IDX,
        .spid_in=SPID_IN_IDX,
        .spiq_in=SPIQ_IN_IDX,
        .spiwp_in=SPIWP_IN_IDX,
        .spihd_in=SPIHD_IN_IDX,
        .spics_out={SPICS0_OUT_IDX, SPICS1_OUT_IDX, SPICS2_OUT_IDX},
        .spiclk_native=6,
        .spid_native=8,
        .spiq_native=7,
        .spiwp_native=10,
        .spihd_native=9,
        .spics0_native=11,
        .irq=ETS_SPI1_INTR_SOURCE,
        .irq_dma=ETS_SPI1_DMA_INTR_SOURCE,
        .module=PERIPH_SPI_MODULE,
        .hw=&SPI1
    }, {
        .spiclk_out=HSPICLK_OUT_IDX,
        .spid_out=HSPID_OUT_IDX,
        .spiq_out=HSPIQ_OUT_IDX,
        .spiwp_out=HSPIWP_OUT_IDX,
        .spihd_out=HSPIHD_OUT_IDX,
        .spid_in=HSPID_IN_IDX,
        .spiq_in=HSPIQ_IN_IDX,
        .spiwp_in=HSPIWP_IN_IDX,
        .spihd_in=HSPIHD_IN_IDX,
        .spics_out={HSPICS0_OUT_IDX, HSPICS1_OUT_IDX, HSPICS2_OUT_IDX},
        .spiclk_native=14,
        .spid_native=13,
        .spiq_native=12,
        .spiwp_native=2,
        .spihd_native=4,
        .spics0_native=15,
        .irq=ETS_SPI2_INTR_SOURCE,
        .irq_dma=ETS_SPI2_DMA_INTR_SOURCE,
        .module=PERIPH_HSPI_MODULE,
        .hw=&SPI2
    }, {
        .spiclk_out=VSPICLK_OUT_IDX,
        .spid_out=VSPID_OUT_IDX,
        .spiq_out=VSPIQ_OUT_IDX,
        .spiwp_out=VSPIWP_OUT_IDX,
        .spihd_out=VSPIHD_OUT_IDX,
        .spid_in=VSPID_IN_IDX,
        .spiq_in=VSPIQ_IN_IDX,
        .spiwp_in=VSPIWP_IN_IDX,
        .spihd_in=VSPIHD_IN_IDX,
        .spics_out={VSPICS0_OUT_IDX, VSPICS1_OUT_IDX, VSPICS2_OUT_IDX},
        .spiclk_native=18,
        .spid_native=23,
        .spiq_native=19,
        .spiwp_native=22,
        .spihd_native=21,
        .spics0_native=5,
        .irq=ETS_SPI3_INTR_SOURCE,
        .irq_dma=ETS_SPI3_DMA_INTR_SOURCE,
        .module=PERIPH_VSPI_MODULE,
        .hw=&SPI3
    }
};


//======================================================================================================

#define DMA_CHANNEL_ENABLED(dma_chan)    (BIT(dma_chan-1))

typedef void(*dmaworkaround_cb_t)(void *arg);

//Set up a list of dma descriptors. dmadesc is an array of descriptors. Data is the buffer to point to.
//--------------------------------------------------------------------------------------------
void spi_lobo_setup_dma_desc_links(lldesc_t *dmadesc, int len, const uint8_t *data, bool isrx)
{
    int n = 0;
    while (len) {
        int dmachunklen = len;
        if (dmachunklen > SPI_MAX_DMA_LEN) dmachunklen = SPI_MAX_DMA_LEN;
        if (isrx) {
            //Receive needs DMA length rounded to next 32-bit boundary
            dmadesc[n].size = (dmachunklen + 3) & (~3);
            dmadesc[n].length = (dmachunklen + 3) & (~3);
        } else {
            dmadesc[n].size = dmachunklen;
            dmadesc[n].length = dmachunklen;
        }
        dmadesc[n].buf = (uint8_t *)data;
        dmadesc[n].eof = 0;
        dmadesc[n].sosf = 0;
        dmadesc[n].owner = 1;
        dmadesc[n].qe.stqe_next = &dmadesc[n + 1];
        len -= dmachunklen;
        data += dmachunklen;
        n++;
    }
    dmadesc[n - 1].eof = 1; //Mark last DMA desc as end of stream.
    dmadesc[n - 1].qe.stqe_next = NULL;
}


/*
Code for workaround for DMA issue in ESP32 v0/v1 silicon
*/


static volatile int dmaworkaround_channels_busy[2] = {0, 0};
static dmaworkaround_cb_t dmaworkaround_cb;
static void *dmaworkaround_cb_arg;
static portMUX_TYPE dmaworkaround_mux = portMUX_INITIALIZER_UNLOCKED;
static int dmaworkaround_waiting_for_chan = 0;
static bool spi_periph_claimed[3] = {true, false, false};
static uint8_t spi_dma_chan_enabled = 0;
static portMUX_TYPE spi_dma_spinlock = portMUX_INITIALIZER_UNLOCKED;

//--------------------------------------------------------------------------------------------
bool IRAM_ATTR spi_lobo_dmaworkaround_req_reset(int dmachan, dmaworkaround_cb_t cb, void *arg)
{
    int otherchan = (dmachan == 1) ? 2 : 1;
    bool ret;
    portENTER_CRITICAL(&dmaworkaround_mux);
    if (dmaworkaround_channels_busy[otherchan-1]) {
        //Other channel is busy. Call back when it's done.
        dmaworkaround_cb = cb;
        dmaworkaround_cb_arg = arg;
        dmaworkaround_waiting_for_chan = otherchan;
        ret = false;
    } else {
        //Reset DMA
        DPORT_SET_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_SPI_DMA_RST);
        DPORT_CLEAR_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_SPI_DMA_RST);
        ret = true;
    }
    portEXIT_CRITICAL(&dmaworkaround_mux);
    return ret;
}

//-------------------------------------------------------
bool IRAM_ATTR spi_lobo_dmaworkaround_reset_in_progress()
{
    return (dmaworkaround_waiting_for_chan != 0);
}

//-----------------------------------------------------
void IRAM_ATTR spi_lobo_dmaworkaround_idle(int dmachan)
{
    portENTER_CRITICAL(&dmaworkaround_mux);
    dmaworkaround_channels_busy[dmachan-1] = 0;
    if (dmaworkaround_waiting_for_chan == dmachan) {
        //Reset DMA
        DPORT_SET_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_SPI_DMA_RST);
        DPORT_CLEAR_PERI_REG_MASK(DPORT_PERIP_RST_EN_REG, DPORT_SPI_DMA_RST);
        dmaworkaround_waiting_for_chan = 0;
        //Call callback
        dmaworkaround_cb(dmaworkaround_cb_arg);

    }
    portEXIT_CRITICAL(&dmaworkaround_mux);
}

//----------------------------------------------------------------
void IRAM_ATTR spi_lobo_dmaworkaround_transfer_active(int dmachan)
{
    portENTER_CRITICAL(&dmaworkaround_mux);
    dmaworkaround_channels_busy[dmachan-1] = 1;
    portEXIT_CRITICAL(&dmaworkaround_mux);
}

//Returns true if this peripheral is successfully claimed, false if otherwise.
//-----------------------------------------------------
bool spi_lobo_periph_claim(ESP32_SPI_Module_spi_host_device_t host)
{
    bool ret = __sync_bool_compare_and_swap(&spi_periph_claimed[host], false, true);
    if (ret) periph_module_enable(io_signal[host].module);
    return ret;
}

//Returns true if this peripheral is successfully freed, false if otherwise.
//-----------------------------------------------
bool spi_lobo_periph_free(ESP32_SPI_Module_spi_host_device_t host)
{
    bool ret = __sync_bool_compare_and_swap(&spi_periph_claimed[host], true, false);
    if (ret) periph_module_disable(io_signal[host].module);
    return ret;
}

//-----------------------------------------
bool spi_lobo_dma_chan_claim (int dma_chan)
{
    bool ret = false;
    assert( dma_chan == 1 || dma_chan == 2 );

    portENTER_CRITICAL(&spi_dma_spinlock);
    if ( !(spi_dma_chan_enabled & DMA_CHANNEL_ENABLED(dma_chan)) ) {
        // get the channel only when it's not claimed yet.
        spi_dma_chan_enabled |= DMA_CHANNEL_ENABLED(dma_chan);
        ret = true;
    }
    periph_module_enable( PERIPH_SPI_DMA_MODULE );
    portEXIT_CRITICAL(&spi_dma_spinlock);

    return ret;
}

//---------------------------------------
bool spi_lobo_dma_chan_free(int dma_chan)
{
    assert( dma_chan == 1 || dma_chan == 2 );
    assert( spi_dma_chan_enabled & DMA_CHANNEL_ENABLED(dma_chan) );

    portENTER_CRITICAL(&spi_dma_spinlock);
    spi_dma_chan_enabled &= ~DMA_CHANNEL_ENABLED(dma_chan);
    if ( spi_dma_chan_enabled == 0 ) {
        //disable the DMA only when all the channels are freed.
        periph_module_disable( PERIPH_SPI_DMA_MODULE );
    }
    portEXIT_CRITICAL(&spi_dma_spinlock);

    return true;
}


//======================================================================================================


//----------------------------------------------------------------------------------------------------------------
static esp_err_t spi_lobo_bus_initialize(ESP32_SPI_Module_spi_host_device_t host, ESP32_SPI_Module_spi_bus_config_t *bus_config, int init)
{
    bool native=true, spi_chan_claimed, dma_chan_claimed;

    if (init > 0) {
        /* ToDo: remove this when we have flash operations cooperating with this */
        SPI_CHECK(host!=TFT_SPI_HOST, "SPI1 is not supported", ESP_ERR_NOT_SUPPORTED);

        SPI_CHECK(host>=TFT_SPI_HOST && host<=TFT_VSPI_HOST, "invalid host", ESP_ERR_INVALID_ARG);
        SPI_CHECK(spihost[host]==NULL, "host already in use", ESP_ERR_INVALID_STATE);
    }
    else {
        SPI_CHECK(spihost[host]!=NULL, "host not in use", ESP_ERR_INVALID_STATE);
    }
    
    SPI_CHECK(bus_config->mosi_io_num<0 || GPIO_IS_VALID_OUTPUT_GPIO(bus_config->mosi_io_num), "spid pin invalid", ESP_ERR_INVALID_ARG);
    SPI_CHECK(bus_config->sclk_io_num<0 || GPIO_IS_VALID_OUTPUT_GPIO(bus_config->sclk_io_num), "spiclk pin invalid", ESP_ERR_INVALID_ARG);
    SPI_CHECK(bus_config->miso_io_num<0 || GPIO_IS_VALID_GPIO(bus_config->miso_io_num), "spiq pin invalid", ESP_ERR_INVALID_ARG);
    SPI_CHECK(bus_config->quadwp_io_num<0 || GPIO_IS_VALID_OUTPUT_GPIO(bus_config->quadwp_io_num), "spiwp pin invalid", ESP_ERR_INVALID_ARG);
    SPI_CHECK(bus_config->quadhd_io_num<0 || GPIO_IS_VALID_OUTPUT_GPIO(bus_config->quadhd_io_num), "spihd pin invalid", ESP_ERR_INVALID_ARG);

    if (init > 0) {
        spi_chan_claimed=spi_lobo_periph_claim(host);
        SPI_CHECK(spi_chan_claimed, "host already in use", ESP_ERR_INVALID_STATE);

        //spihost[host]=malloc(sizeof(ESP32_SPI_Module_spi_host_t));
		spihost[host]=heap_caps_malloc(sizeof(ESP32_SPI_Module_spi_host_t), MALLOC_CAP_DMA);
		if (spihost[host]==NULL) return ESP_ERR_NO_MEM;
		memset(spihost[host], 0, sizeof(ESP32_SPI_Module_spi_host_t));
		// Create semaphore
		spihost[host]->ESP32_SPI_Module_spi_bus_mutex = xSemaphoreCreateMutex();
		if (!spihost[host]->ESP32_SPI_Module_spi_bus_mutex) return ESP_ERR_NO_MEM;
    }

    spihost[host]->cur_device = -1;
    memcpy(&spihost[host]->cur_bus_config, bus_config, sizeof(ESP32_SPI_Module_spi_bus_config_t));

    //Check if the selected pins correspond to the native pins of the peripheral
    if (bus_config->mosi_io_num >= 0 && bus_config->mosi_io_num!=io_signal[host].spid_native) native=false;
    if (bus_config->miso_io_num >= 0 && bus_config->miso_io_num!=io_signal[host].spiq_native) native=false;
    if (bus_config->sclk_io_num >= 0 && bus_config->sclk_io_num!=io_signal[host].spiclk_native) native=false;
    if (bus_config->quadwp_io_num >= 0 && bus_config->quadwp_io_num!=io_signal[host].spiwp_native) native=false;
    if (bus_config->quadhd_io_num >= 0 && bus_config->quadhd_io_num!=io_signal[host].spihd_native) native=false;
    
    spihost[host]->no_gpio_matrix=native;
    if (native) {
        //All SPI native pin selections resolve to 1, so we put that here instead of trying to figure
        //out which FUNC_GPIOx_xSPIxx to grab; they all are defined to 1 anyway.
        if (bus_config->mosi_io_num > 0) PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->mosi_io_num], 1);
        if (bus_config->miso_io_num > 0) PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->miso_io_num], 1);
        if (bus_config->quadwp_io_num > 0) PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->quadwp_io_num], 1);
        if (bus_config->quadhd_io_num > 0) PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->quadhd_io_num], 1);
        if (bus_config->sclk_io_num > 0) PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->sclk_io_num], 1);
    } else {
        //Use GPIO 
        if (bus_config->mosi_io_num>0) {
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->mosi_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(bus_config->mosi_io_num, GPIO_MODE_OUTPUT);
            gpio_matrix_out(bus_config->mosi_io_num, io_signal[host].spid_out, false, false);
            gpio_matrix_in(bus_config->mosi_io_num, io_signal[host].spid_in, false);
        }
        if (bus_config->miso_io_num>0) {
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->miso_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(bus_config->miso_io_num, GPIO_MODE_INPUT);
            gpio_matrix_out(bus_config->miso_io_num, io_signal[host].spiq_out, false, false);
            gpio_matrix_in(bus_config->miso_io_num, io_signal[host].spiq_in, false);
        }
        if (bus_config->quadwp_io_num>0) {
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->quadwp_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(bus_config->quadwp_io_num, GPIO_MODE_OUTPUT);
            gpio_matrix_out(bus_config->quadwp_io_num, io_signal[host].spiwp_out, false, false);
            gpio_matrix_in(bus_config->quadwp_io_num, io_signal[host].spiwp_in, false);
        }
        if (bus_config->quadhd_io_num>0) {
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->quadhd_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(bus_config->quadhd_io_num, GPIO_MODE_OUTPUT);
            gpio_matrix_out(bus_config->quadhd_io_num, io_signal[host].spihd_out, false, false);
            gpio_matrix_in(bus_config->quadhd_io_num, io_signal[host].spihd_in, false);
        }
        if (bus_config->sclk_io_num>0) {
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[bus_config->sclk_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(bus_config->sclk_io_num, GPIO_MODE_OUTPUT);
            gpio_matrix_out(bus_config->sclk_io_num, io_signal[host].spiclk_out, false, false);
        }
    }
	periph_module_enable(io_signal[host].module);
	spihost[host]->hw=io_signal[host].hw;

	if (init > 0) {
        dma_chan_claimed=spi_lobo_dma_chan_claim(init);
        if ( !dma_chan_claimed ) {
        	spi_lobo_periph_free( host );
            SPI_CHECK(dma_chan_claimed, "dma channel already in use", ESP_ERR_INVALID_STATE);
        }
	    spihost[host]->dma_chan = init;
        //See how many dma descriptors we need and allocate them
        int dma_desc_ct=(bus_config->max_transfer_sz+SPI_MAX_DMA_LEN-1)/SPI_MAX_DMA_LEN;
        if (dma_desc_ct==0) dma_desc_ct=1; //default to 4k when max is not given
        spihost[host]->max_transfer_sz = dma_desc_ct*SPI_MAX_DMA_LEN;

        spihost[host]->dmadesc_tx=heap_caps_malloc(sizeof(lldesc_t)*dma_desc_ct, MALLOC_CAP_DMA);
        spihost[host]->dmadesc_rx=heap_caps_malloc(sizeof(lldesc_t)*dma_desc_ct, MALLOC_CAP_DMA);
        if (!spihost[host]->dmadesc_tx || !spihost[host]->dmadesc_rx) goto nomem;

        //Tell common code DMA workaround that our DMA channel is idle. If needed, the code will do a DMA reset.
        spi_lobo_dmaworkaround_idle(spihost[host]->dma_chan);

        // Reset DMA
        spihost[host]->hw->dma_conf.val |= SPI_OUT_RST|SPI_IN_RST|SPI_AHBM_RST|SPI_AHBM_FIFO_RST;
        spihost[host]->hw->dma_out_link.start=0;
        spihost[host]->hw->dma_in_link.start=0;
        spihost[host]->hw->dma_conf.val &= ~(SPI_OUT_RST|SPI_IN_RST|SPI_AHBM_RST|SPI_AHBM_FIFO_RST);
        spihost[host]->hw->dma_conf.out_data_burst_en=1;

        //Reset timing
        spihost[host]->hw->ctrl2.val=0;

        //Disable unneeded ints
        spihost[host]->hw->slave.rd_buf_done=0;
        spihost[host]->hw->slave.wr_buf_done=0;
        spihost[host]->hw->slave.rd_sta_done=0;
        spihost[host]->hw->slave.wr_sta_done=0;
        spihost[host]->hw->slave.rd_buf_inten=0;
        spihost[host]->hw->slave.wr_buf_inten=0;
        spihost[host]->hw->slave.rd_sta_inten=0;
        spihost[host]->hw->slave.wr_sta_inten=0;

        //Force a transaction done interrupt. This interrupt won't fire yet because we initialized the SPI interrupt as
        //disabled.  This way, we can just enable the SPI interrupt and the interrupt handler will kick in, handling
        //any transactions that are queued.
        spihost[host]->hw->slave.trans_inten=1;
        spihost[host]->hw->slave.trans_done=1;

		//Select DMA channel.
		DPORT_SET_PERI_REG_BITS(DPORT_SPI_DMA_CHAN_SEL_REG, 3, init, (host * 2));
    }
    return ESP_OK;

nomem:
	if (spihost[host]) {
		free(spihost[host]->dmadesc_tx);
		free(spihost[host]->dmadesc_rx);
	}
	free(spihost[host]);
    spi_lobo_periph_free(host);
	return ESP_ERR_NO_MEM;
}



//---------------------------------------------------------------------------
static esp_err_t spi_lobo_bus_free(ESP32_SPI_Module_spi_host_device_t host, int dofree)
{
	if ((host == TFT_SPI_HOST) || (host > TFT_VSPI_HOST)) return ESP_ERR_NOT_SUPPORTED;  // invalid host

	if (spihost[host] == NULL) return ESP_ERR_INVALID_STATE;  // host not in use

    if (dofree) {
		for (int x=0; x<NO_DEV; x++) {
			if (spihost[host]->device[x] != NULL) return ESP_ERR_INVALID_STATE;  // not all devices freed
		}
    }
    if ( spihost[host]->dma_chan > 0 ) {
        spi_lobo_dma_chan_free ( spihost[host]->dma_chan );
    }
    spihost[host]->hw->slave.trans_inten=0;
    spihost[host]->hw->slave.trans_done=0;
    spi_lobo_periph_free(host);

    if (dofree) {
		vSemaphoreDelete(spihost[host]->ESP32_SPI_Module_spi_bus_mutex);
	    free(spihost[host]->dmadesc_tx);
	    free(spihost[host]->dmadesc_rx);
		free(spihost[host]);
		spihost[host] = NULL;
    }
    return ESP_OK;
}



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
esp_err_t 
spi_lobo_bus_add_device(ESP32_SPI_Module_spi_host_device_t host, ESP32_SPI_Module_spi_bus_config_t *bus_config, ESP32_SPI_Module_spi_device_interface_config_t *dev_config, ESP32_SPI_Module_spi_device_handle_t *handle)
{
	if ((host == TFT_SPI_HOST) || (host > TFT_VSPI_HOST)) return ESP_ERR_NOT_SUPPORTED;  // invalid host
	
	if (spihost[host] == NULL) {
		esp_err_t ret = spi_lobo_bus_initialize(host, bus_config, 1);
		if (ret) return ret;
	}
	
	int freecs, maxdev;
    int apbclk=APB_CLK_FREQ;

	if (spihost[host] == NULL) return ESP_ERR_INVALID_STATE;

    if (dev_config->spics_io_num >= 0) {
		if (!GPIO_IS_VALID_OUTPUT_GPIO(dev_config->spics_io_num)) return  ESP_ERR_INVALID_ARG;
		if (dev_config->spics_ext_io_num > 0) dev_config->spics_ext_io_num = -1;
	}
	else {
		//if ((dev_config->spics_ext_io_num <= 0) || (!GPIO_IS_VALID_OUTPUT_GPIO(dev_config->spics_ext_io_num))) return ESP_ERR_INVALID_ARG;
	}

    //ToDo: Check if some other device uses the same 'spics_ext_io_num'

    if (dev_config->clock_speed_hz == 0) return ESP_ERR_INVALID_ARG;
	if (dev_config->spics_io_num > 0) maxdev = NO_CS;
	else maxdev = NO_DEV;

    for (freecs=0; freecs<maxdev; freecs++) {
        //See if this slot is free; reserve if it is by putting a dummy pointer in the slot. We use an atomic compare&swap to make this thread-safe.
        if (__sync_bool_compare_and_swap(&spihost[host]->device[freecs], NULL, (ESP32_SPI_Module_spi_device_t *)1)) break;
    }
    if (freecs == maxdev) return ESP_ERR_NOT_FOUND;

    // The hardware looks like it would support this, but actually setting cs_ena_pretrans when transferring in full
    // duplex mode does absolutely nothing on the ESP32.
    if ((dev_config->cs_ena_pretrans != 0) && (dev_config->flags & LB_SPI_DEVICE_HALFDUPLEX)) return ESP_ERR_INVALID_ARG;

    // Speeds >=40MHz over GPIO matrix needs a dummy cycle, but these don't work for full-duplex connections.
    if (((dev_config->flags & LB_SPI_DEVICE_HALFDUPLEX)==0) && (dev_config->clock_speed_hz > ((apbclk*2)/5)) && (!spihost[host]->no_gpio_matrix)) return ESP_ERR_INVALID_ARG;

    //Allocate memory for device
    ESP32_SPI_Module_spi_device_t *dev=malloc(sizeof(ESP32_SPI_Module_spi_device_t ));
    if (dev==NULL) return ESP_ERR_NO_MEM;

    memset(dev, 0, sizeof(ESP32_SPI_Module_spi_device_t ));
    spihost[host]->device[freecs]=dev;

    if (dev_config->duty_cycle_pos==0) dev_config->duty_cycle_pos=128;
    dev->host=spihost[host];
	dev->host_dev = host;

    //We want to save a copy of the dev config in the dev struct.
    memcpy(&dev->cfg, dev_config, sizeof(ESP32_SPI_Module_spi_device_interface_config_t));
    //We want to save a copy of the bus config in the dev struct.
    memcpy(&dev->bus_config, bus_config, sizeof(ESP32_SPI_Module_spi_bus_config_t));

    //Set CS pin, CS options
    if (dev_config->spics_io_num > 0) {
        if (spihost[host]->no_gpio_matrix &&dev_config->spics_io_num == io_signal[host].spics0_native && freecs==0) {
            //Again, the cs0s for all SPI peripherals map to pin mux source 1, so we use that instead of a define.
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[dev_config->spics_io_num], 1);
        } else {
            //Use GPIO matrix
            PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[dev_config->spics_io_num], PIN_FUNC_GPIO);
            gpio_set_direction(dev_config->spics_io_num, GPIO_MODE_OUTPUT);
            gpio_matrix_out(dev_config->spics_io_num, io_signal[host].spics_out[freecs], false, false);
        }
    }
    else if (dev_config->spics_ext_io_num >= 0) {
		gpio_set_direction(dev_config->spics_ext_io_num, GPIO_MODE_OUTPUT);
		gpio_set_level(dev_config->spics_ext_io_num, 1);
	}
    if (dev_config->flags & LB_SPI_DEVICE_CLK_AS_CS) {
        spihost[host]->hw->pin.master_ck_sel |= (1<<freecs);
    } else {
        spihost[host]->hw->pin.master_ck_sel &= (1<<freecs);
    }
    if (dev_config->flags & LB_SPI_DEVICE_POSITIVE_CS) {
        spihost[host]->hw->pin.master_cs_pol |= (1<<freecs);
    } else {
        spihost[host]->hw->pin.master_cs_pol &= (1<<freecs);
    }

    *handle = dev;
    return ESP_OK;
}



//-------------------------------------------------------------------
esp_err_t spi_lobo_bus_remove_device(ESP32_SPI_Module_spi_device_handle_t handle)
{
    int x;
    if (handle == NULL) return ESP_ERR_INVALID_ARG;

    //Remove device from list of csses and free memory
    for (x=0; x<NO_DEV; x++) {
        if (handle->host->device[x] == handle) handle->host->device[x]=NULL;
    }
	
	// Check if all devices are removed from this host and free the bus if yes
	for (x=0; x<NO_DEV; x++) {
		if (spihost[handle->host_dev]->device[x] !=NULL) break;
	}
	if (x == NO_DEV) {
		free(handle);
		spi_lobo_bus_free(handle->host_dev, 1);
	}
	else free(handle);

	return ESP_OK;
}

//-----------------------------------------------------------------
static int IRAM_ATTR spi_freq_for_pre_n(int fapb, int pre, int n) {
    return (fapb / (pre * n));
}



/*
 * Set the SPI clock to a certain frequency. Returns the effective frequency set, which may be slightly
 * different from the requested frequency.
 */
//-----------------------------------------------------------------------------------
static int IRAM_ATTR spi_set_clock(spi_dev_t *hw, int fapb, int hz, int duty_cycle) {
   int pre, n, h, l, eff_clk;

    //In hw, n, h and l are 1-64, pre is 1-8K. Value written to register is one lower than used value.
    if (hz>((fapb/4)*3)) {
        //Using Fapb directly will give us the best result here.
        hw->clock.clkcnt_l=0;
        hw->clock.clkcnt_h=0;
        hw->clock.clkcnt_n=0;
        hw->clock.clkdiv_pre=0;
        hw->clock.clk_equ_sysclk=1;
        eff_clk=fapb;
    } else {
        //For best duty cycle resolution, we want n to be as close to 32 as possible, but
        //we also need a pre/n combo that gets us as close as possible to the intended freq.
        //To do this, we bruteforce n and calculate the best pre to go along with that.
        //If there's a choice between pre/n combos that give the same result, use the one
        //with the higher n.
        int bestn=-1;
        int bestpre=-1;
        int besterr=0;
        int errval;
        for (n=1; n<=64; n++) {
            //Effectively, this does pre=round((fapb/n)/hz).
            pre=((fapb/n)+(hz/2))/hz;
            if (pre<=0) pre=1;
            if (pre>8192) pre=8192;
            errval=abs(spi_freq_for_pre_n(fapb, pre, n)-hz);
            if (bestn==-1 || errval<=besterr) {
                besterr=errval;
                bestn=n;
                bestpre=pre;
            }
        }

        n=bestn;
        pre=bestpre;
        l=n;
        //This effectively does round((duty_cycle*n)/256)
        h=(duty_cycle*n+127)/256;
        if (h<=0) h=1;

        hw->clock.clk_equ_sysclk=0;
        hw->clock.clkcnt_n=n-1;
        hw->clock.clkdiv_pre=pre-1;
        hw->clock.clkcnt_h=h-1;
        hw->clock.clkcnt_l=l-1;
        eff_clk=spi_freq_for_pre_n(fapb, pre, n);
    }
    return eff_clk;
}



//------------------------------------------------------------------------------------
esp_err_t IRAM_ATTR spi_lobo_device_select(ESP32_SPI_Module_spi_device_handle_t handle, int force)
{
	if (handle == NULL) return ESP_ERR_INVALID_ARG;

	if ((handle->cfg.selected == 1) && (!force)) return ESP_OK;  // already selected

	int i;
	ESP32_SPI_Module_spi_host_t *host=(ESP32_SPI_Module_spi_host_t*)handle->host;

	// find device's host bus
	for (i=0; i<NO_DEV; i++) {
		if (host->device[i] == handle) break;
	}
	if (i == NO_DEV) return ESP_ERR_INVALID_ARG;

	if (!(xSemaphoreTake(host->ESP32_SPI_Module_spi_bus_mutex, SPI_SEMAPHORE_WAIT))) return ESP_ERR_INVALID_STATE;

	// Check if previously used device's bus device is the same
	if (memcmp(&host->cur_bus_config, &handle->bus_config, sizeof(ESP32_SPI_Module_spi_bus_config_t)) != 0) {
		// device has different bus configuration, we need to reconfigure the bus
		esp_err_t err = spi_lobo_bus_free(1, 0);
		if (err) {
			xSemaphoreGive(host->ESP32_SPI_Module_spi_bus_mutex);
			return err;
		}
		err = spi_lobo_bus_initialize(i, &handle->bus_config, -1);
		if (err) {
			xSemaphoreGive(host->ESP32_SPI_Module_spi_bus_mutex);
			return err;
		}
	}

	//Reconfigure according to device settings, but only if the device changed or forced.
	if ((force) || (host->device[host->cur_device] != handle)) {
	    //Assumes a hardcoded 80MHz Fapb for now. ToDo: figure out something better once we have clock scaling working.
		int apbclk=APB_CLK_FREQ;

	    //Speeds >=40MHz over GPIO matrix needs a dummy cycle, but these don't work for full-duplex connections.
	    if (((handle->cfg.flags & LB_SPI_DEVICE_HALFDUPLEX) == 0) && (handle->cfg.clock_speed_hz > ((apbclk*2)/5)) && (!host->no_gpio_matrix)) {
	    	// set speed to 32 MHz
	    	handle->cfg.clock_speed_hz = (apbclk*2)/5;
	    }

		int effclk=spi_set_clock(host->hw, apbclk, handle->cfg.clock_speed_hz, handle->cfg.duty_cycle_pos);
		//Configure bit order
		host->hw->ctrl.rd_bit_order=(handle->cfg.flags & LB_SPI_DEVICE_RXBIT_LSBFIRST)?1:0;
		host->hw->ctrl.wr_bit_order=(handle->cfg.flags & LB_SPI_DEVICE_TXBIT_LSBFIRST)?1:0;
		
		//Configure polarity
        //SPI iface needs to be configured for a delay in some cases.
		int nodelay=0;
        int extra_dummy=0;
        if (host->no_gpio_matrix) {
            if (effclk >= apbclk/2) {
                nodelay=1;
            }
        } else {
            if (effclk >= apbclk/2) {
                nodelay=1;
                extra_dummy=1;          //Note: This only works on half-duplex connections. spi_lobo_bus_add_device checks for this.
            } else if (effclk >= apbclk/4) {
                nodelay=1;
            }
        }
		if (handle->cfg.mode==0) {
			host->hw->pin.ck_idle_edge=0;
			host->hw->user.ck_out_edge=0;
			host->hw->ctrl2.miso_delay_mode=nodelay?0:2;
		} else if (handle->cfg.mode==1) {
			host->hw->pin.ck_idle_edge=0;
			host->hw->user.ck_out_edge=1;
			host->hw->ctrl2.miso_delay_mode=nodelay?0:1;
		} else if (handle->cfg.mode==2) {
			host->hw->pin.ck_idle_edge=1;
			host->hw->user.ck_out_edge=1;
			host->hw->ctrl2.miso_delay_mode=nodelay?0:1;
		} else if (handle->cfg.mode==3) {
			host->hw->pin.ck_idle_edge=1;
			host->hw->user.ck_out_edge=0;
			host->hw->ctrl2.miso_delay_mode=nodelay?0:2;
		}

		//Configure bit sizes, load addr and command
		host->hw->user.usr_dummy=(handle->cfg.dummy_bits+extra_dummy)?1:0;
		host->hw->user.usr_addr=(handle->cfg.address_bits)?1:0;
		host->hw->user.usr_command=(handle->cfg.command_bits)?1:0;
		host->hw->user1.usr_addr_bitlen=handle->cfg.address_bits-1;
		host->hw->user1.usr_dummy_cyclelen=handle->cfg.dummy_bits+extra_dummy-1;
		host->hw->user2.usr_command_bitlen=handle->cfg.command_bits-1;
		//Configure misc stuff
		host->hw->user.doutdin=(handle->cfg.flags & LB_SPI_DEVICE_HALFDUPLEX)?0:1;
		host->hw->user.sio=(handle->cfg.flags & LB_SPI_DEVICE_3WIRE)?1:0;

		host->hw->ctrl2.setup_time=handle->cfg.cs_ena_pretrans-1;
		host->hw->user.cs_setup=handle->cfg.cs_ena_pretrans?1:0;
		host->hw->ctrl2.hold_time=handle->cfg.cs_ena_posttrans-1;
		host->hw->user.cs_hold=(handle->cfg.cs_ena_posttrans)?1:0;

		//Configure CS pin
		host->hw->pin.cs0_dis=(i==0)?0:1;
		host->hw->pin.cs1_dis=(i==1)?0:1;
		host->hw->pin.cs2_dis=(i==2)?0:1;
		
		host->cur_device = i;
	}

	if ((handle->cfg.spics_io_num < 0) && (handle->cfg.spics_ext_io_num > 0)) {
		gpio_set_level(handle->cfg.spics_ext_io_num, 0);
	}

	handle->cfg.selected = 1;

	return ESP_OK;
}



//---------------------------------------------------------------------------
esp_err_t IRAM_ATTR spi_lobo_device_deselect(ESP32_SPI_Module_spi_device_handle_t handle)
{
	if (handle == NULL) return ESP_ERR_INVALID_ARG;

	if (handle->cfg.selected == 0) return ESP_OK;  // already deselected

	int i;
	ESP32_SPI_Module_spi_host_t *host=(ESP32_SPI_Module_spi_host_t*)handle->host;

	for (i=0; i<NO_DEV; i++) {
		if (host->device[i] == handle) break;
	}
	if (i == NO_DEV) return ESP_ERR_INVALID_ARG;
	
	if (host->device[host->cur_device] == handle) {
		if ((handle->cfg.spics_io_num < 0) && (handle->cfg.spics_ext_io_num > 0)) {
			gpio_set_level(handle->cfg.spics_ext_io_num, 1);
		}
	}

	handle->cfg.selected = 0;
	xSemaphoreGive(host->ESP32_SPI_Module_spi_bus_mutex);

	return ESP_OK;
}



//--------------------------------------------------------------------------------
esp_err_t IRAM_ATTR 
spi_lobo_device_takeSemaphore(ESP32_SPI_Module_spi_device_handle_t handle)
{
	if (!(xSemaphoreTake(handle->host->ESP32_SPI_Module_spi_bus_mutex, SPI_SEMAPHORE_WAIT))) return ESP_ERR_INVALID_STATE;
	else return ESP_OK;
}



//---------------------------------------------------------------------------
void IRAM_ATTR spi_lobo_device_GiveSemaphore(ESP32_SPI_Module_spi_device_handle_t handle)
{
	xSemaphoreTake(handle->host->ESP32_SPI_Module_spi_bus_mutex, portMAX_DELAY);
}



//----------------------------------------------------------
uint32_t spi_lobo_get_speed(ESP32_SPI_Module_spi_device_handle_t handle)
{
	ESP32_SPI_Module_spi_host_t *host=(ESP32_SPI_Module_spi_host_t*)handle->host;
	uint32_t speed = 0;
	if (spi_lobo_device_select(handle, 0) == ESP_OK) {
		if (host->hw->clock.clk_equ_sysclk == 1) speed = 80000000;
		else speed =  80000000/(host->hw->clock.clkdiv_pre+1)/(host->hw->clock.clkcnt_n+1);
	}
	spi_lobo_device_deselect(handle);
	return speed;
}



//--------------------------------------------------------------------------
uint32_t spi_lobo_set_speed(ESP32_SPI_Module_spi_device_handle_t handle, uint32_t speed)
{
	ESP32_SPI_Module_spi_host_t *host=(ESP32_SPI_Module_spi_host_t*)handle->host;
	uint32_t newspeed = 0;
	if (spi_lobo_device_select(handle, 0) == ESP_OK) {
		spi_lobo_device_deselect(handle);
		handle->cfg.clock_speed_hz = speed;
		if (spi_lobo_device_select(handle, 1) == ESP_OK) {
			if (host->hw->clock.clk_equ_sysclk == 1) newspeed = 80000000;
			else newspeed =  80000000/(host->hw->clock.clkdiv_pre+1)/(host->hw->clock.clkcnt_n+1);
		}
	}
	spi_lobo_device_deselect(handle);
	
	return newspeed;
}



//-------------------------------------------------------------
bool spi_lobo_uses_native_pins(ESP32_SPI_Module_spi_device_handle_t handle)
{
	return handle->host->no_gpio_matrix;
}



//-------------------------------------------------------------------
void spi_lobo_get_native_pins(int host, int *sdi, int *sdo, int *sck)
{
	*sdo = io_signal[host].spid_native;
	*sdi = io_signal[host].spiq_native;
	*sck = io_signal[host].spiclk_native;
}



/*
When using  'spi_lobo_transfer_data' function we can have several scenarios:

A: Send only      (trans->rxlength = 0)
B: Receive only   (trans->txlength = 0)
C: Send & receive (trans->txlength > 0 & trans->rxlength > 0)
D: No operation   (trans->txlength = 0 & trans->rxlength = 0)

*/
//----------------------------------------------------------------------------------------------------------
esp_err_t IRAM_ATTR
spi_lobo_transfer_data(ESP32_SPI_Module_spi_device_handle_t handle, ESP32_SPI_Module_spi_transaction_t *trans)
{
	if (!handle) return ESP_ERR_INVALID_ARG;

	// *** For now we can only handle 8-bit bytes transmission
	if (((trans->length % 8) != 0) || ((trans->rxlength % 8) != 0))
		return ESP_ERR_INVALID_ARG;

	ESP32_SPI_Module_spi_host_t* host = (ESP32_SPI_Module_spi_host_t*) handle->host;

	esp_err_t ret;

	uint8_t do_deselect = 0;

	const uint8_t *txbuffer = NULL;
	uint8_t *rxbuffer = NULL;

	if ( trans->flags & LB_SPI_TRANS_USE_TXDATA ) {

        // Send data from 'trans->tx_data'
		txbuffer=(uint8_t*)&trans->tx_data[0];

	} else {

        // Send data from 'trans->tx_buffer'
		txbuffer=(uint8_t*)trans->tx_buffer;

	}

	if (trans->flags & LB_SPI_TRANS_USE_RXDATA) {

        // Receive data to 'trans->rx_data'
		rxbuffer=(uint8_t*)&trans->rx_data[0];

	} else {

        // Receive data to 'trans->rx_buffer'
		rxbuffer=(uint8_t*)trans->rx_buffer;
	}

	// ** Set transmit & receive length in bytes
	uint32_t txlen = trans->length / 8;
	uint32_t rxlen = trans->rxlength / 8;

	if (txbuffer == NULL) txlen = 0;
	if (rxbuffer == NULL) rxlen = 0;

	if ((rxlen == 0) && (txlen == 0)) {

        	// ** NOTHING TO SEND or RECEIVE, return
        	return ESP_ERR_INVALID_ARG;
	}

	// If using 'trans->tx_data' and/or 'trans->rx_data', maximum 4 bytes can be sent/received
	if ((txbuffer == &trans->tx_data[0]) && (txlen > 4)) return ESP_ERR_INVALID_ARG;
	if ((rxbuffer == &trans->rx_data[0]) && (rxlen > 4)) return ESP_ERR_INVALID_ARG;

	// --- Wait for SPI bus ready ---
	while (host->hw->cmd.usr);

	// ** If the device was not selected, select it
	if (handle->cfg.selected == 0) {

		ret = spi_lobo_device_select(handle, 0);
		if (ret) return ret;
		do_deselect = 1;     // We will deselect the device after the operation !
	}

	// ** Call pre-transmission callback, if any
	if (handle->cfg.pre_cb) handle->cfg.pre_cb(trans);

	// Test if operating in full duplex mode
	uint8_t duplex = 1;
	if (handle->cfg.flags & LB_SPI_DEVICE_HALFDUPLEX) 
		duplex = 0; // Half duplex mode !

	uint32_t bits, rdbits;
	uint32_t wd;
	uint8_t bc, rdidx;
	uint32_t rdcount = rxlen;	// Total number of bytes to read
	uint32_t count = 0;		// number of bytes transmitted
	uint32_t rd_read = 0;		// Number of bytes read so far

	host->hw->user.usr_mosi_highpart = 0; // use the whole spi buffer

	// ** Check if address phase will be used
	host->hw->user2.usr_command_value=trans->command;

	if (handle->cfg.address_bits>32) {

		host->hw->addr=trans->address >> 32;
		host->hw->slv_wr_status=trans->address & 0xffffffff;

	} else {

		host->hw->addr=trans->address & 0xffffffff;
	}

	// Check if we have to transmit some data
	if (txlen > 0) {

		host->hw->user.usr_mosi = 1;
		uint8_t idx;
		bits = 0;				// remaining bits to send
		idx = 0;				// index to spi hw data_buf (16 32-bit words, 64 bytes, 512 bits)

        	// ** Transmit 'txlen' bytes
		while (count < txlen) {

			wd = 0;

			for (bc=0;bc<32;bc+=8) {

				wd |= (uint32_t)txbuffer[count] << bc;
				count++;                    // Increment sent data count
				bits += 8;                  // Increment bits count
				if (count == txlen) break;  // If all transmit data pushed to hw spi buffer break from the loop
			}

			host->hw->data_buf[idx] = wd;

			idx++;

			if (idx == 16) {

				// hw SPI buffer full (all 64 bytes filled, START THE TRANSSACTION
				host->hw->mosi_dlen.usr_mosi_dbitlen=bits-1;            // Set mosi dbitlen

				if ((duplex) && (rdcount > 0)) {

                   			// In full duplex mode we are receiving while sending !
					host->hw->miso_dlen.usr_miso_dbitlen = bits-1;      // Set miso dbitlen
					host->hw->user.usr_miso = 1;
				}

				else {

					host->hw->miso_dlen.usr_miso_dbitlen = 0;           // In half duplex mode nothing will be received
					host->hw->user.usr_miso = 0;
				}

				// ** Start the transaction ***
				host->hw->cmd.usr=1;

               			// Wait the transaction to finish
				while (host->hw->cmd.usr);

				if ((duplex) && (rdcount > 0)) {

					// *** in full duplex mode transfer received data to input buffer ***
					rdidx = 0;

			    		while (bits > 0) {

						wd = host->hw->data_buf[rdidx];

						rdidx++;

						for (bc=0;bc<32;bc+=8) { // get max 4 bytes

							rxbuffer[rd_read++] = (uint8_t)((wd >> bc) & 0xFF);
							rdcount--;
							bits -= 8;
							if (rdcount == 0) {

								bits = 0;
								break; // Finished reading data
							}
						}
			    		}
				}

				bits = 0;   // nothing in hw spi buffer yet
				idx = 0;    // start from the beginning of the hw spi buffer
			}
		}

		// *** All transmit data are sent or pushed to hw spi buffer
		// bits > 0  IF THERE ARE SOME DATA STILL WAITING IN THE HW SPI TRANSMIT BUFFER
		if (bits > 0) {

			// ** WE HAVE SOME DATA IN THE HW SPI TRANSMIT BUFFER
			host->hw->mosi_dlen.usr_mosi_dbitlen = bits-1;          // Set mosi dbitlen

			if ((duplex) && (rdcount > 0)) {

                		// In full duplex mode we are receiving while sending !
				host->hw->miso_dlen.usr_miso_dbitlen = bits-1;      // Set miso dbitlen
				host->hw->user.usr_miso = 1;
			}

			else {

				host->hw->miso_dlen.usr_miso_dbitlen = 0;           // In half duplex mode nothing will be received
				host->hw->user.usr_miso = 0;
			}

			// ** Start the transaction ***
			host->hw->cmd.usr=1;

            		// Wait the transaction to finish
			while (host->hw->cmd.usr);

			if ((duplex) && (rdcount > 0)) {

               			// *** in full duplex mode transfer received data to input buffer ***
				rdidx = 0;

		    		while (bits > 0) {

					wd = host->hw->data_buf[rdidx];

					rdidx++;

					for (bc=0;bc<32;bc+=8) { // get max 4 bytes

						rxbuffer[rd_read++] = (uint8_t)((wd >> bc) & 0xFF);
						rdcount--;
						bits -= 8;

						if (bits == 0) break;

						if (rdcount == 0) {
							bits = 0;
							break; // Finished reading data
						}
					}
		    		}
			}
		}
		//if (duplex) rdcount = 0;  // In duplex mode receive only as many bytes as was transmitted
	}

	// ------------------------------------------------------------------------
	// *** If rdcount = 0 we have nothing to receive and we exit the function
   	//     This is true if no data receive was requested,
   	//     or all the data was received in Full duplex mode during the transmission
	// ------------------------------------------------------------------------
	if (rdcount > 0) {

		// ----------------------------------------------------------------------------------------------------------------
		// *** rdcount > 0, we have to receive some data
		//     This is true if we operate in Half duplex mode when receiving after transmission is done,
		//     or not all data was received in Full duplex mode during the transmission (trans->rxlength > trans->txlength)
		// ----------------------------------------------------------------------------------------------------------------

		host->hw->user.usr_mosi = 0;  // do not send
		host->hw->user.usr_miso = 1;  // do receive

		while (rdcount > 0) {

			if (rdcount <= 64) rdbits = rdcount * 8;

			else rdbits = 64 * 8;

			// Load receive buffer
			host->hw->mosi_dlen.usr_mosi_dbitlen=0;
			host->hw->miso_dlen.usr_miso_dbitlen=rdbits-1;

			// ** Start the transaction ***
			host->hw->cmd.usr=1;

			// Wait the transaction to finish
			while (host->hw->cmd.usr);

			// *** transfer received data to input buffer ***
			rdidx = 0;
			while (rdbits > 0) {

				wd = host->hw->data_buf[rdidx];

				rdidx++;

				for (bc=0;bc<32;bc+=8) {

					rxbuffer[rd_read++] = (uint8_t)((wd >> bc) & 0xFF);
					rdcount--;
					rdbits -= 8;

					if (rdcount == 0) {
						rdbits = 0;
						break;
					}
				}
			}
		}
	}

	// ** Call post-transmission callback, if any
	if (handle->cfg.post_cb) handle->cfg.post_cb(trans);

	if (do_deselect) {

		// Spi device was selected in this function, we have to deselect it now
		ret = spi_lobo_device_deselect(handle);
		if (ret) return ret;
	}

  return ESP_OK;
}





















