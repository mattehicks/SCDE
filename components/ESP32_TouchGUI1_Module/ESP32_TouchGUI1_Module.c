/* #################################################################################################
 *
 *      Name: ESP32_SPI Module
 *  Function: This is used to set up GPIOs as a switch with the goal to control switching hardware
 *            (relay, ...). The GPIO switching is Hardware PWM driven (for ESP32 SOC only). 
 *            Module for use with SCDE (Smart Connected Device Engine) only !
 *
 *  ESP 8266EX & ESP32 SoC Activities ...
 *  HoME CoNTROL & Smart Connected Device Engine Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 *
 *
 */


//define mySPI ESP32_SPI KEY=ARG
#include "stdatomic.h"

#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>

// the Smart-Connected-Device-Engine structures & types ..
#include <SCDE_s.h>

// provides WebIf, need the structures & types ...
#include "WebIf_Module.h"

// this Modules structures & types ...
#include "ESP32_TouchGUI1_Module_s.h"
#include "ESP32_TouchGUI1_Module.h"


#include "tft.h"
//#include "SCDE_Main.h"
//#include "driver/gpio.h"



// ptr zur Fehlermeldung in allokierter strTextMultiple_t WENN NOCH KEIN FEHLER WAR
#define SCDE_OK  NULL

/*
static const char* I2S_TAG = "I2S";
#define SCDE_CHECK(a, str, ret) if (!(a)) {                                              \
        ESP_LOGE(I2S_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);       \
        return (ret);                                                                   \
        }
//  I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
*/



// SCDE_CHECK MAKRO: Prüft Bedingung und gibt Fehler in allokierter strTextMultiple_t zurück
#define SCDE_CHECK(a, str) if (!(a)) {							\
	retMsg = malloc(sizeof(strTextMultiple_t));					\
	retMsg->strTextLen = asprintf(&retMsg->strText					\
		,"Error! '%s'"								\
		,str);									\
	return retMsg;									\
	}






// -------------------------------------------------------------------------------------------------

// set default build verbose - if no external override
#ifndef ESP32_TouchGUI1_Module_DBG  
#define ESP32_TouchGUI1_Module_DBG  5	// 5 is default
#endif 

// -------------------------------------------------------------------------------------------------



#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------



/*
 * Implemented Values for Keys
 */

// ESP32_TouchGUI1_SET_DISENA -> 'SDA_IO_PULLUP' -> Disabled|Enabled
//                             -> 'SCL_IO_PULLUP' -> Disabled|Enabled
SelectAData ESP32_TouchGUI1_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// ESP32_TouchGUI1_SET_I2C_MODE -> 'I2C_MODE' -> Master|Slave
SelectAData ESP32_TouchGUI1_I2C_MODE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Master"},
  {1,"Slave"}, 
  {0, NULL}
  };

/*
// ESP32_TouchGUI1_SET_IDLE_LV -> 'IDLE_LV' -> Low|High
SelectAData ESP32_TouchGUI1_LoHi[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Low"},
  {1,"High"}, 
  {0, NULL}
  };
// ESP32_TouchGUI1_SET_BLOCK -> 'PWM_BLOCK'-> High_Speed|Low_Speed
SelectAData ESP32_TouchGUI1_PWM_BLOCK[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"High_Speed"},
  {1,"Low_Speed"},
  {0, NULL}
  };
// ESP32_TouchGUI1_SET_TICK_SOURCE -> 'TICK_SOURCE'-> REF|APB_SLOW
SelectAData ESP32_TouchGUI1_TICK_SOURCE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"REF"},
  {1,"APB_SLOW"}, 
  {0, NULL}
  };
*/



/**
 * For Type: ESP32_SPI
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in ESP32_TouchGUI1_parsedKVInput_t
 */
enum ESP32_TouchGUI1_SET_IK {				// Bit #XX for debugging

  // Block #1 I2C Block to use
    ESP32_TouchGUI1_SET_I2C_NUM			// Bit #01 'I2C_NUM' -> 

  // Block #2 I2C Master/Slave ?
  , ESP32_TouchGUI1_SET_I2C_MODE			// Bit #02 'I2C_MODE' -> 

  // Block #3 I2C Pin connections
  , ESP32_TouchGUI1_SET_SDA_IO				// Bit #03 'SDA_IO' -> 
  , ESP32_TouchGUI1_SET_SDA_IO_PULLUP			// Bit #04 'SDA_IO_PULLUP' -> 
  , ESP32_TouchGUI1_SET_SCL_IO				// Bit #05 'SCL_IO' ->
  , ESP32_TouchGUI1_SET_SCL_IO_PULLUP			// Bit #06 'SCL_IO_PULLUP' ->

  // Block #4 I2C Pin connections
  , ESP32_TouchGUI1_SET_MASTER_CLOCK			// Bit #07 'MASTER_CLOCK' ->

  // Block #5 I2C Pin connections
  , ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA		// Bit #08 'SLAVE_10BIT_ENA' ->

  // Block #6 I2C Pin connections
  , ESP32_TouchGUI1_SET_SLAVE_ADRESS			// Bit #09 'SLAVE_ADRESS' ->

// end marker
  , ESP32_TouchGUI1_SET_NUMBER_OF_IK			// Bit #10 MAX 64 IMPLEMENTED !

};

 

/**
 * For Type: ESP32_SPI
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum ESP32_TouchGUI1_Readings {			// Bit #XX for debugging

   ESP32_TouchGUI1_R_DUTY		= (1<<0)	// Bit #00 'Duty'  -> 

  ,ESP32_TouchGUI1_R_RESOLUTION	= (1<<1)	// Bit #01 'Resolution' -> 

  ,ESP32_TouchGUI1_R_NAME		= (1<<2)	// Bit #02 'name' + caps + ufid -> 

};



/**
 * For Type: ESP32_SPI
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()
 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t ESP32_TouchGUI1_Set_ImplementedKeys[] = {
// |                     affectedreadings						       	|  CMD

// for usage

// for configuration
   { 0												,"I2C_NUM" }		// #01
  ,{ 0												,"I2C_MODE" }		// #02
  ,{ 0												,"SDA_IO" }		// #03
  ,{ 0												,"SDA_IO_PULLUP" }	// #04
  ,{ 0												,"SCL_IO" }		// #05
  ,{ 0												,"SCL_IO_PULLUP" }	// #06
  ,{ 0												,"MASTER_CLOCK" }	// #07
  ,{ 0												,"SLAVE_10BIT_ENA" }	// #08
  ,{ 0												,"SLAVE_ADRESS" }	// #09
 
}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_TouchGUI1_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t ESP32_TouchGUI1_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_TouchGUI1_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t ESP32_TouchGUI1_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



// -------------------------------------------------------------------------------------------------



/*
 * DName: ESP32_TouchGUI1_Fn (SCDE Functions)
 * Desc: Stores function callbacks provided & made accessible for client modules using this module,
 *       for operation and helpers
 * Data: 
 */
/*
ESP32_TouchGUI1_Fn_t ESP32_TouchGUI1_Fn = {
  ESP32_TouchGUI1_Module_TouchGUI1_bus_add_device,
  ESP32_TouchGUI1_Module_TouchGUI1_bus_remove_device
};
*/



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: ESP32_TouchGUI1_provided_Fn
 *  Desc: Assigns common + custom functions this Module provides to the SCDE (and client Modules)
 *  Data: ESP32_TouchGUI1_provided_fn_t
 * -------------------------------------------------------------------------------------------------
 */
ESP32_TouchGUI1_ProvidedByModule_t ESP32_TouchGUI1_ProvidedByModule = {   // A-Z order
{
// --- first the common module functions ---
  "ESP32_TouchGUI1"	// Type-Name of module -> on Linux libfilename.so !
  ,15					// size of Type-Name

  ,NULL					// Add
  ,ESP32_TouchGUI1_Attribute		// Attribute
  ,ESP32_TouchGUI1_Define		// Define
  ,NULL					// Delete
  ,NULL					// DirectRead
  ,NULL					// DirectWrite
  ,NULL					// Except
  ,NULL					// Get
  ,ESP32_TouchGUI1_IdleCb		// IdleCb
  ,ESP32_TouchGUI1_Initialize		// Initialize
  ,NULL					// Notify
  ,NULL					// Parse
  ,NULL					// Read
  ,NULL					// Ready
  ,NULL					// Rename
  ,ESP32_TouchGUI1_Set			// Set
  ,ESP32_TouchGUI1_Shutdown		// Shutdown
  ,NULL					// State
  ,NULL					// Sub
  ,ESP32_TouchGUI1_Undefine		// Undefine
  ,ESP32_TouchGUI1_Write		// Write
  ,NULL					// FnProvided
  ,sizeof(ESP32_TouchGUI1_Definition_t)	// Modul specific Size (Common_Definition_t + X)
},
// --- now the custom module fuctions ---
  // NONE				// ?
};



/* -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Attribute
 *  Desc: Informs an Definition of this Type for attribute activities (set/del)
 *  Info: 'attrCmd' is the command text for the activity: set, del
 *        'attrName' is the attribute name text
 *        'attrVal' is the attribute value text
 *        THE attrVal CAN BE MANIPULATED / CORRECTED
 *  Para: Common_Definition_t *Common_Definition -> the belonging definition for the attribute-activitie
 *	  const uint8_t *attrCmdText -> ptr to attribute-command text "attrCmd"
 *	  const size_t attrCmdTextLen -> length of attribute-command text "attrCmd"
 *	  const uint8_t *attrNameText -> ptr to attribute-name text "attrName"
 *	  const size_t attrNameTextLen -> length of attribute-name text "attrName"
 *	  uint8_t **attrValTextPtr -> ptr to ptr holding attribute-value text "attrValue" - manipulation possible
 *	  size_t *attrValLenTextPtr -> ptr to length of attribute-value text "attrValue" - manipulation possible
 *  Rets: strTextMultiple_t* -> veto = error-text-string in allocated mem, or NULL = OK - no veto
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_TouchGUI1_Attribute(Common_Definition_t *Common_Definition
		,const uint8_t *attrCmdText
		,const size_t attrCmdTextLen
		,const uint8_t *attrNameText
		,const size_t attrNameTextLen
		,uint8_t **attrValTextPtr
		,size_t *attrValTextLenPtr)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  uint8_t *attrValText = *attrValTextPtr;
  size_t attrValTextLen = *attrValTextLenPtr;

  printf("ESP32_TouchGUI1_AttributeFN for defName:%.*s -> attrCmd:%.*s attrName:%.*s attrVal:%.*s\n"
	,Common_Definition->nameLen
	,Common_Definition->name
	,attrCmdTextLen
	,attrCmdText
  	,attrNameTextLen
	,attrNameText
	,(int) attrValTextLen
	,attrValText);



/*
  // set start of possible def-Name
  const uint8_t *defName = args;
  // set start of possible attr-Name
  const uint8_t *attrName = args;
  // a seek-counter
  int i = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrName != ' ') ) {i++;attrName++;}
  // length of def-Name
  size_t defNameLen = i;
  // seek to start position of attr-Name '\32'
  while( (i < argsLen) && (*attrName == ' ') ) {i++;attrName++;}
  // set start of possible attr-Val
  const uint8_t *attrVal = attrName;
  // a 2nd seek-counter
  int j = 0;
  // seek to next space !'\32'
  while( (i < argsLen) && (*attrVal != ' ') ) {i++,j++;attrVal++;}
  // length of attr-Name
  size_t attrNameLen = j;
  // start position of attr-Val
  while( (i < argsLen) && (*attrVal == ' ') ) {i++;attrVal++;}
  // length of attr-Val
  size_t attrValLen = argsLen - i;
  // veryfy lengths > 0, definition 0 allowed
  if ( (defNameLen == 0) || (attrNameLen == 0) )
		{
		// response with error text
		asprintf(&retMsg
				,"Could not interpret command ''! Usage: Attr <defname> <attrname> [<attrval>]");
		return retMsg;
	//	}
// -------------------------------------------------------------------------------------------------
*/

  return retMsg;
}







/*
#include "freertos/ringbuf.h"


#include "soc/i2c_struct.h"
#include "soc/i2c_reg.h"
#include "driver/periph_ctrl.h"

static const char* I2C_TAG = "i2c";

#define I2C_CHECK(a, str, ret)  if(!(a)) {                                             \
        ESP_LOGE(I2C_TAG,"%s:%d (%s):%s", __FILE__, __LINE__, __FUNCTION__, str);      \
        return (ret);                                                                   \
        }

*/






// to device
#define PIN_NUM_CS   5		// Display CS pin
#define PIN_NUM_DC   26		// Display command/data pin

//This function is called (in irq context!) just before a transmission starts. It will
//set the D/C line to the value indicated in the user field.
void 
lcd_spi_pre_transfer_callback(ESP32_SPI_transaction_t* t)
{
  printf("pre.\r\n");
  int dc = (int) t->user;
  gpio_set_level(PIN_NUM_DC, dc);
}

void 
lcd_spi_post_transfer_callback(ESP32_SPI_transaction_t* t)
{
 printf("post.\r\n");
//    int dc = (int) t->user;
//    gpio_set_level(PIN_NUM_DC, dc);
}


/*
uint32_t 
lcd_get_id(ESP32_SPI_device_handle_t spi)
{
  // get_id cmd
  lcd_cmd(spi, 0x04);

  ESP32_SPI_transaction_t t;
  memset(&t, 0, sizeof(t));
  t.length=8*3;
  t.flags = SPI_TRANS_USE_RXDATA;
  t.user = (void*)1;

  esp_err_t ret = ESP32_SPI_device_polling_transmit(spi, &t);
  assert( ret == ESP_OK );

  return *(uint32_t*)t.rx_data;
}
*/



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Define
 *  Desc: Finalizes the defines a new "device" of 'ESP32_S0' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_TouchGUI1_Define(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
		  (ESP32_TouchGUI1_Definition_t*) Common_Definition;

  // for Fn response msg
  strTextMultiple_t *retMsg = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if ESP32_TouchGUI1_Module_DBG >= 5
  SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,5
	,"DefineFn of Module '%.*s' is called to continue creation of Definition '%.*s' with args '%.*s'."
	,ESP32_TouchGUI1_Definition->common.module->provided->typeNameLen
	,ESP32_TouchGUI1_Definition->common.module->provided->typeName
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name
	,ESP32_TouchGUI1_Definition->common.definitionLen
	,ESP32_TouchGUI1_Definition->common.definition);
  #endif

// ------------------------------------------------------------------------------------------------

  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Expected Args!");

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

//  xSemaphoreTake(ESP32_TouchGUI1_Definition->def_mux
//    ,portMAX_DELAY);

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  ESP32_TouchGUI1_Definition->common.fd = -1;

  // store table of function callbacks provided & made accessible for client modules
 // ESP32_TouchGUI1_Definition->ESP32_TouchGUI1_Fn = &ESP32_TouchGUI1_Fn;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  ESP32_TouchGUI1_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn_at_ESP32_TouchGUI1_M->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (ESP32_TouchGUI1_Definition->WebIf_Provided.WebIf_FnProvided) {

	ESP32_TouchGUI1_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &ESP32_TouchGUI1_ActiveResourcesDataA_forWebIf;

	ESP32_TouchGUI1_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &ESP32_TouchGUI1_ActiveResourcesDataB_forWebIf;
  }

  else	{

	SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,ESP32_TouchGUI1_Definition->common.nameLen
		,ESP32_TouchGUI1_Definition->common.name
		,ESP32_TouchGUI1_Definition->common.module->provided->typeNameLen
		,ESP32_TouchGUI1_Definition->common.module->provided->typeName);
  }

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_ESP32_TouchGUI1_M->ParseKVInputArgsFn(ESP32_TouchGUI1_SET_NUMBER_OF_IK		// Num Implementated KEYs MAX
	,ESP32_TouchGUI1_Set_ImplementedKeys					// Implementated Keys
	,defArgsText								// our args text
	,defArgsTextLen);							// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,defArgsTextLen
		,defArgsText);

	if (parsedKVInput) {

		free(parsedKVInput);
	}

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // try 1 - arguments for configuration as i2c master ?

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 	( (1 << ESP32_TouchGUI1_SET_I2C_NUM)
					| (1 << ESP32_TouchGUI1_SET_I2C_MODE)
					| (1 << ESP32_TouchGUI1_SET_SDA_IO)
					| (1 << ESP32_TouchGUI1_SET_SDA_IO_PULLUP)
					| (1 << ESP32_TouchGUI1_SET_SCL_IO)
					| (1 << ESP32_TouchGUI1_SET_SCL_IO_PULLUP)
					| (1 << ESP32_TouchGUI1_SET_MASTER_CLOCK)
					);

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 	( (1 << ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA)
					| (1 << ESP32_TouchGUI1_SET_SLAVE_ADRESS)
 					);
/*
  // process the set-args (key=value@) protocol
  if (ESP32_TouchGUI1_ProcessKVInputArgs(ESP32_TouchGUI1_Definition
	,parsedKVInput				// KVInput parsed
	,defArgsText				// our args text
	,defArgsTextLen) ) {			// our args text len

	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,defArgsTextLen
		,defArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;

  }
*/
// ------------------------------------------------------------------------------------------------

  // set affected readings
 // ESP32_TouchGUI1_SetAffectedReadings(ESP32_TouchGUI1_Definition
//	,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

// ------------------------------------------------------------------------------------------------

//play here
/*
#define REFERENCE_PRESSUREx 103800l
  // replace by key=value init
  BMP180_Definition->oversampling = BMP180_ULTRA_HIGH_RES;
  BMP180_Definition->reference_pressure = REFERENCE_PRESSUREx;
  // + poll intervall*/

  // temp build 'ESP32_TouchGUI1'
	ESP32_TouchGUI1_Definition->stage1definitionNameLen = 
		asprintf(&ESP32_TouchGUI1_Definition->stage1definitionName,"SPI");

// ------------------------------------------------------------------------------------------------

  // get pointer to 1st stage modul (we developing for...)
  ESP32_SPI_Definition_t* ESP32_SPI_Definition =
		(ESP32_SPI_Definition_t*) SCDEFn_at_ESP32_TouchGUI1_M->GetDefinitionPtrByNameFn(
		ESP32_TouchGUI1_Definition->stage1definitionNameLen,
		ESP32_TouchGUI1_Definition->stage1definitionName);

  // not found - retMsg & define-veto
  if (!ESP32_SPI_Definition) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Stage 1 Module '%.*s' not found! Stopping define!"
		,ESP32_TouchGUI1_Definition->stage1definitionNameLen
		,ESP32_TouchGUI1_Definition->stage1definitionName);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  #if BMP180_Module_DBG >= 7
  SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,7
	,"Found an first Stage defined as name '%.*s'. Its Type '%.*s' !"
	,ESP32_SPI_Definition->common.nameLen
	,ESP32_SPI_Definition->common.name
	,ESP32_SPI_Definition->common.module->provided->typeNameLen
	,ESP32_SPI_Definition->common.module->provided->typeName);
  #endif

// ------------------------------------------------------------------------------------------------

  // store link to stage 1
  ESP32_TouchGUI1_Definition->ESP32_SPI_Definition = 
	ESP32_SPI_Definition;

  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

// ------------------------------------------------------------------------------------------------




// Play here...

/* we need:
REQ:
Blocka: (spi<-> display)
clock_speed
mode ?
PIN_NUM_CS


BlockB: (display)
TFT_DISP_TYPE
DISPLAY_WIDTH
DISPLAY_HEIGHT



opt:
Blocka: (spi<-> display)


BlockB: (display)
GREY_SCALE
*/







  // Set display type
  ESP32_TouchGUI1_Definition->display_config.tft_disp_type = DEFAULT_DISP_TYPE;
	//tft_disp_type = DISP_TYPE_ILI9341;
	//tft_disp_type = DISP_TYPE_ILI9488;
	//tft_disp_type = DISP_TYPE_ST7735B;

  // Set display resolution
  ESP32_TouchGUI1_Definition->_width = DEFAULT_TFT_DISPLAY_WIDTH;  // smaller dimension
  ESP32_TouchGUI1_Definition->_height = DEFAULT_TFT_DISPLAY_HEIGHT; // larger dimension

  // Converts colors to grayscale if set to 1
  ESP32_TouchGUI1_Definition->gray_scale = 0;


  // Pins MUST be initialized before SPI interface initialization
//  TFT_PinsInit(ESP32_TouchGUI1_Definition);


printf("pre:%p.\r\n", ESP32_TouchGUI1_Definition->disp_interface_config.pre_cb);
printf("post:%p.\r\n", ESP32_TouchGUI1_Definition->disp_interface_config.post_cb);


  // test fill cfg
//      .clock_speed_hz = 26*1000*1000,         // Clock out at 26 MHz (overclock)
  ESP32_TouchGUI1_Definition->disp_interface_config.clock_speed_hz = 10*1000*1000;        	// Clock out at 10 MHz
  ESP32_TouchGUI1_Definition->disp_interface_config.mode = 0;                             	// SPI mode 0
  ESP32_TouchGUI1_Definition->disp_interface_config.spics_io_num = PIN_NUM_CS;             	// CS pin
  ESP32_TouchGUI1_Definition->disp_interface_config.queue_size = 7;                       	// We want to be able to queue 7 transactions at a time
  ESP32_TouchGUI1_Definition->disp_interface_config.pre_cb = lcd_spi_pre_transfer_callback;	//Specify pre-transfer callback to handle D/C line

  ESP32_TouchGUI1_Definition->disp_interface_config.post_cb = lcd_spi_post_transfer_callback;




  // Attach this Definitions display (SPI device) to given Definition (ESP32_SPI_Module!) SPI bus host
  retMsg = ESP32_SPI_provided_fn->ESP32_SPI_bus_add_deviceFn(ESP32_SPI_Definition,
	&ESP32_TouchGUI1_Definition->disp_interface_config,	// spi interface cfg. for display
	&ESP32_TouchGUI1_Definition->disp_handle);		// the handle will be stored here
  // error occured ? We have message -> deinit
  if ( retMsg ) goto error;

  printf("GUI: display device connected to spi Module, we have handle (host %d) at %p\r\n",
	ESP32_SPI_Definition->host.host_device,
	ESP32_TouchGUI1_Definition->disp_handle);


  // Init this Definitions display (SPI device). It is connected now.
  retMsg = TFT_display_init(ESP32_TouchGUI1_Definition,
	ESP32_TouchGUI1_Definition->disp_handle,
	ESP32_TouchGUI1_Definition->display_config);
  // error occured ? We have message -> deinit
  if ( retMsg ) goto error;

   printf("SPI: display init done.\r\n");



 



  font_rotate = 0;
  text_wrap = 0;
  font_transparent = 0;
  font_forceFixed = 0;
  ESP32_TouchGUI1_Definition->gray_scale = 0;


  TFT_setGammaCurve(ESP32_TouchGUI1_Definition->disp_handle, DEFAULT_GAMMA_CURVE);

  TFT_setRotation(ESP32_TouchGUI1_Definition, PORTRAIT);


  TFT_setFont(DEFAULT_FONT, NULL);

  TFT_resetclipwin(ESP32_TouchGUI1_Definition);

  TFT_print(ESP32_TouchGUI1_Definition, "Time is not set yet", CENTER, CENTER);







/*

// ==========================================================
// Define which spi bus to use TFT_VSPI_HOST or TFT_HSPI_HOST
#define SPI_BUS HSPI_HOST
// ==========================================================


    // ========  PREPARE DISPLAY INITIALIZATION  =========

    esp_err_t ret;

    // === SET GLOBAL VARIABLES ==========================



  // Init Spi device handles for display and touch screen
  ESP32_TouchGUI1_Definition->disp_handle = NULL;
  ESP32_TouchGUI1_Definition->ts_spi = NULL;




    // ===================================================

    // ==== Set display type                         =====
    ESP32_TouchGUI1_Definition->tft_disp_type = DEFAULT_DISP_TYPE;
	//tft_disp_type = DISP_TYPE_ILI9341;
	//tft_disp_type = DISP_TYPE_ILI9488;
	//tft_disp_type = DISP_TYPE_ST7735B;
    // ===================================================

	// ===================================================
	// === Set display resolution if NOT using default ===
	// === DEFAULT_TFT_DISPLAY_WIDTH &                 ===
    // === DEFAULT_TFT_DISPLAY_HEIGHT                  ===
	ESP32_TouchGUI1_Definition->_width = DEFAULT_TFT_DISPLAY_WIDTH;  // smaller dimension
	ESP32_TouchGUI1_Definition->_height = DEFAULT_TFT_DISPLAY_HEIGHT; // larger dimension
	//_width = 128;  // smaller dimension
	//_height = 160; // larger dimension
	// ===================================================

	// Converts colors to grayscale if set to 1
	ESP32_TouchGUI1_Definition->gray_scale = 0;

	// ===================================================
	// ==== Set maximum spi clock for display read    ====
	//      operations, function 'find_rd_speed()'    ====
	//      can be used after display initialization  ====
	max_rdclock = 8000000;
	// ===================================================

    // ====================================================================
    // === Pins MUST be initialized before SPI interface initialization ===
    // ====================================================================
    TFT_PinsInit(ESP32_TouchGUI1_Definition);

    // ====  CONFIGURE SPI DEVICES(s)  ====================================================================================

    ESP32_SPI_Module_spi_device_handle_t disp_handle;
	
    ESP32_SPI_bus_config_t buscfg = {
        .miso_io_num = PIN_NUM_MISO,				// set SPI MISO pin
        .mosi_io_num = PIN_NUM_MOSI,				// set SPI MOSI pin
        .sclk_io_num = PIN_NUM_CLK,				// set SPI CLK pin
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
	.max_transfer_sz = 6 * 1024,
    };

    ESP32_SPI_Module_spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 8000000,              // Initial clock out at 8 MHz
        .mode = 0,                              // SPI mode 0
        .spics_io_num = -1,                     // we will use external CS pin
	.spics_ext_io_num = PIN_NUM_CS,         // external CS pin
	.flags = LB_SPI_DEVICE_HALFDUPLEX,	// ALWAYS SET to HALF DUPLEX MODE!! for display spi
    };


  vTaskDelay(500 / portTICK_RATE_MS);

  printf("\r\n==============================\r\n");
  printf("TFT display DEMO, LoBo 11/2017\r\n");
  printf("==============================\r\n");
  printf("Pins used: miso=%d, mosi=%d, sck=%d, cs=%d, d/c=%d, Tcs=%d\r\n",
	PIN_NUM_MISO,
	PIN_NUM_MOSI,
	PIN_NUM_CLK,
	PIN_NUM_CS,
	PIN_NUM_DC,
	PIN_NUM_TCS);

#if USE_TOUCH > TOUCH_TYPE_NONE
    printf(" Touch CS: %d\r\n", PIN_NUM_TCS);
#endif

	printf("==============================\r\n\r\n");

	// ==================================================================
	// ==== Initialize the SPI bus and attach the LCD to the SPI bus ====


  ret = ESP32_SPI_provided_fn->ESP32_SPI_bus_add_deviceFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, SPI_BUS,
	//&buscfg,
	&devcfg,
	&disp_handle);

  assert(ret==ESP_OK);

  printf("SPI: display device added to spi bus (%d)\r\n", SPI_BUS);

  // save display spi handle
  ESP32_TouchGUI1_Definition->disp_handle = disp_spi;

  // ==== Test select/deselect ====
  ret = ESP32_SPI_provided_fn->ESP32_SPI_device_acquire_busFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, disp_spi, 1);

  assert(ret==ESP_OK);

  printf("Err?1 (%d)\r\n", ret);

  ret = ESP32_SPI_provided_fn->ESP32_SPI_device_release_busFn(disp_spi);

  assert(ret==ESP_OK);

  printf("Err?2 (%d)\r\n", ret);


  printf("SPI: attached display device, speed=%u\r\n",
	 ESP32_SPI_provided_fn->ESP32_SPI_spi_get_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, disp_spi));
  printf("SPI: bus uses native pins: %s\r\n", 
	ESP32_SPI_provided_fn->ESP32_SPI_spi_uses_native_pinsFn(disp_spi) ? "true" : "false");



	// ================================
	// ==== Initialize the Display ====

	printf("SPI: display init...\r\n");
	TFT_display_init(ESP32_TouchGUI1_Definition);
    printf("OK\r\n");



	// ---- Detect maximum read speed ----
	max_rdclock = find_rd_speed(ESP32_TouchGUI1_Definition);
	printf("SPI: Max rd speed = %u\r\n", max_rdclock);

    // ==== Set SPI clock used for display operations ====
	ESP32_SPI_provided_fn->ESP32_SPI_spi_set_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, disp_spi, DEFAULT_SPI_CLOCK);
	printf("SPI: Changed speed to %u\r\n", 
		ESP32_SPI_provided_fn->ESP32_SPI_spi_get_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, disp_spi));

    printf("\r\n---------------------\r\n");
	printf("Graphics demo started\r\n");
	printf("---------------------\r\n");




	font_rotate = 0;
	text_wrap = 0;
	font_transparent = 0;
	font_forceFixed = 0;
	ESP32_TouchGUI1_Definition->gray_scale = 0;

  TFT_setGammaCurve(disp_spi, DEFAULT_GAMMA_CURVE);

  TFT_setRotation(ESP32_TouchGUI1_Definition, PORTRAIT);

  TFT_setFont(DEFAULT_FONT, NULL);

  TFT_resetclipwin(ESP32_TouchGUI1_Definition);

  TFT_print(ESP32_TouchGUI1_Definition, "Time is not set yet", CENTER, CENTER);




*/































/*
// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << ESP32_TouchGUI1_SET_I2C_NUM)
			        | (1 << ESP32_TouchGUI1_SET_I2C_MODE)
			        | (1 << ESP32_TouchGUI1_SET_SDA_IO)
			        | (1 << ESP32_TouchGUI1_SET_SDA_IO_PULLUP)
			        | (1 << ESP32_TouchGUI1_SET_SCL_IO)
			        | (1 << ESP32_TouchGUI1_SET_SCL_IO_PULLUP) );

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_TouchGUI1_ProcessKVInputArgs(ESP32_TouchGUI1_Definition
    ,parsedKVInput				// KVInput parsed
    ,defArgsText				// our args text
    ,defArgsTextLen) ) {			// our args text len

    // Processing reports an problem. Args not taken. Response with error text.

    // alloc mem for retMsg
    retMsg = malloc(sizeof(strTextMultiple_t));

    // response with error text
    retMsg->strTextLen = asprintf(&retMsg->strText
      ,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
      ,defArgsTextLen
      ,defArgsText);

    // free allocated memory for query result key-field
    free(parsedKVInput);

    return retMsg;
  }

// ------------------------------------------------------------------------------------------------
*/
  // set affected readings
 // ESP32_TouchGUI1_SetAffectedReadings(ESP32_TouchGUI1_Definition
  //  ,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  //free(parsedKVInput);


// ------------------------------------------------------------------------------------------------

  // set up 1st idle Callback
  ESP32_TouchGUI1_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

// alternative end in case of errors - free / destroy all allocated things and return with msg.
error:
/*
  if (parsedKVInput) {

    free(parsedKVInput);

  }

*/
  return retMsg;
}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_DirectWrite
 *  Desc: for 2 stage designs - called to give write job to 1st stage (this stage)
 *  Info: 
 *  Para: ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
/*
strTextMultiple_t *
ESP32_TouchGUI1_DirectWrite(
	 Common_Definition_t *Common_Definition_Stage1
	,Common_Definition_t *Common_Definition_Stage2
	,Common_StageXCHG_t *Common_StageXCHG)
{
  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;
  // to adress 1st stage definition - make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition_Stage1 =
	(ESP32_TouchGUI1_Definition_t*) Common_Definition_Stage1;
  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_StageXCHG_t *ESP32_TouchGUI1_StageXCHG =
	(ESP32_TouchGUI1_StageXCHG_t*) Common_StageXCHG;
// -------------------------------------------------------------------------------------------------
// check 4 matching modules
// -------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------
  #if ESP32_TouchGUI1_Module_DBG >= 5
  SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(
	 ESP32_TouchGUI1_Definition_Stage1->common.name
	,ESP32_TouchGUI1_Definition_Stage1->common.nameLen
	,5
	,"DirectWriteFn of Definition '%.*s' (Module '%.*s') is called "
  	 "from Definition '%.*s' (Module '%.*s') to exec write job."
	,ESP32_TouchGUI1_Definition_Stage1->common.nameLen
	,ESP32_TouchGUI1_Definition_Stage1->common.name
	,ESP32_TouchGUI1_Definition_Stage1->common.module->provided->typeNameLen
	,ESP32_TouchGUI1_Definition_Stage1->common.module->provided->typeName
	,Common_Definition_Stage2->nameLen
	,Common_Definition_Stage2->name
	,Common_Definition_Stage2->module->provided->typeNameLen
	,Common_Definition_Stage2->module->provided->typeName);
  #endif
// -------------------------------------------------------------------------------------------------
  return retMsg;
}
*/





void
Redraw_Time(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
  time_t time_now;
  struct tm* tm_info;
  char tmp_buff[64];

  // redraw time
  time(&time_now);

  if (time_now > ESP32_TouchGUI1_Definition->time_last) {

	color_t last_fg, last_bg;

	ESP32_TouchGUI1_Definition->time_last = time_now;

	tm_info = localtime(&time_now);

	sprintf(tmp_buff, "%02d:%02d:%02d",
		tm_info->tm_hour,
		tm_info->tm_min,
		tm_info->tm_sec);

	TFT_saveClipWin();
	TFT_resetclipwin(ESP32_TouchGUI1_Definition);

	Font curr_font = cfont;

	last_bg = _bg;
	last_fg = _fg;

	_fg = TFT_YELLOW;

	_bg = (color_t){ 64, 64, 64 };

	TFT_setFont(DEFAULT_FONT, NULL);

	TFT_fillRect(ESP32_TouchGUI1_Definition,
		1,
		ESP32_TouchGUI1_Definition->_height-TFT_getfontheight()-8,
		ESP32_TouchGUI1_Definition->_width-3,
		TFT_getfontheight()+6,
		_bg);

	TFT_print(ESP32_TouchGUI1_Definition,
		tmp_buff,
		RIGHT,//CENTER,
		ESP32_TouchGUI1_Definition->_height-TFT_getfontheight()-5);

	cfont = curr_font;
	_fg = last_fg;
	_bg = last_bg;

	TFT_restoreClipWin();
  }

  return;
}











/*
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int //feedModuleTask
ESP32_TouchGUI1_IdleCb(Common_Definition_t *Common_Definition)
{

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
		  (ESP32_TouchGUI1_Definition_t*) Common_Definition;

  #if ESP32_TouchGUI1_Module_DBG >= 5
  printf("\n|ESP32_TouchGUI1_IdleCb, Def:%.*s>"
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------



  // redraw the time at bottom, if changed
  Redraw_Time(ESP32_TouchGUI1_Definition);


  // set up next idle Callback
  ESP32_TouchGUI1_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0;

}















/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
ESP32_TouchGUI1_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot_at_ESP32_TouchGUI1_M = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn_at_ESP32_TouchGUI1_M = SCDERootptr->SCDEFn;

  SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(ESP32_TouchGUI1_ProvidedByModule.common.typeName
		  ,ESP32_TouchGUI1_ProvidedByModule.common.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,ESP32_TouchGUI1_ProvidedByModule.common.typeNameLen
		  ,ESP32_TouchGUI1_ProvidedByModule.common.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t *
ESP32_TouchGUI1_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
	(ESP32_TouchGUI1_Definition_t*) Common_Definition;

  #if ESP32_TouchGUI1_Module_DBG >= 5
  printf("\n|ESP32_TouchGUI1_Set, Name:%.*s, got args:%.*s>"
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_ESP32_TouchGUI1_M->ParseKVInputArgsFn(ESP32_TouchGUI1_SET_NUMBER_OF_IK	// Num Implementated KEYs MAX for Set Fn
	,ESP32_TouchGUI1_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
//  parsedKVInput->forbiddenKVBF = ( (1 << ESP32_TouchGUI1_SET_CNT_UNIT) );
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (ESP32_TouchGUI1_ProcessKVInputArgs(ESP32_TouchGUI1_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  ESP32_TouchGUI1_SetAffectedReadings(ESP32_TouchGUI1_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine ESP32_TouchGUI1_Definition.common.Name'
 *  Para: ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_TouchGUI1_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
	(ESP32_TouchGUI1_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if ESP32_TouchGUI1_Module_DBG >= 5
  printf("\n|ESP32_TouchGUI1_Shutdown, Name:%.*s>"
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
ESP32_TouchGUI1_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
	(ESP32_TouchGUI1_Definition_t*) Common_Definition;

  #if ESP32_TouchGUI1_Module_DBG >= 5
  printf("\n|ESP32_TouchGUI1_Undefine, Name:%.*s>"
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name);

  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"ESP32_TouchGUI1_Undefine, Name:%.*s"
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name);

  return retMsg;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_Write
 *  Desc: Is called to write data to an 'Definition' of 'ESP32_SPI' Module.
 *  Info: 
 *  Para: Common_Definition_t* Common_Definition -> the 'Definition' that should write the data 
 *                                                  (cast to ESP32_TouchGUI1_Definition_t*)
 *        xString_t data          -> data that should be written (characters in allocated mem + len) 
 *  Rets: xMultipleStringSLTQE_t* -> response: ptr to an singly linked tail queue element with return
 *                                   message in allocated memory, or NULL = OK / No message
 * -------------------------------------------------------------------------------------------------
 */
xMultipleStringSLTQE_t*
ESP32_TouchGUI1_Write(Common_Definition_t *Common_Definition,
		       xString_t data)
{

  // make common ptr to modul specific ptr
  ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition =
		  (ESP32_TouchGUI1_Definition_t*) Common_Definition;

  // for Fn response msg
  xMultipleStringSLTQE_t *retMsgMultipleStringSLTQE = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if ESP32_TouchGUI1_Module_DBG >= 7
  SCDEFn_at_ESP32_TouchGUI1_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,7
	,"WriteFn of Module '%.*s' is called for Definition '%.*s'. Got %d bytes raw data."
	,ESP32_TouchGUI1_Definition->common.module->ESP32_TouchGUI1_provided_fn->typeNameLen
	,ESP32_TouchGUI1_Definition->common.module->ESP32_TouchGUI1_provided_fn->typeName
	,ESP32_TouchGUI1_Definition->common.nameLen
	,ESP32_TouchGUI1_Definition->common.name
	,data.length);
  #endif

// -------------------------------------------------------------------------------------------------


  return retMsgMultipleStringSLTQE;
}


















/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: strTextMultiple_t* -> SCDE_OK, or error txts - for log
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
ESP32_TouchGUI1_ProcessKVInputArgs(ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition,
	parsedKVInputArgs_t *parsedKVInput,
	uint8_t *argsText,
	size_t argsTextLen)
{
 printf("|0");
  // start without error
  strTextMultiple_t *retMsg = SCDE_OK;


 // remember the readings affected by the parsing process
  uint32_t affectedReadings = 0;

// -------------------------------------------------------------------------------------------------
// 1. Step: Create backup structures, if required mirror current effective values.
// -------------------------------------------------------------------------------------------------
/*
  // Block #01 Backup the current I2C-Block
  uint8_t new_i2c_num;
  new_i2c_num = ESP32_TouchGUI1_Definition->i2c_num;

// -------------------------------------------------------------------------------------------------

  // Block #02 Backup the current I2C mode
  i2c_mode_t new_i2c_mode;
  new_i2c_mode = ESP32_TouchGUI1_Definition->i2c_config.mode;

// -------------------------------------------------------------------------------------------------

  // Block #03 Backup the current SDA & SCL pin configuration used by I2C
  gpio_num_t new_sda_io_num;
  gpio_pullup_t new_sda_pullup_en;
  gpio_num_t new_scl_io_num;
  gpio_pullup_t new_scl_pullup_en;

  new_sda_io_num = ESP32_TouchGUI1_Definition->i2c_config.sda_io_num;
  new_sda_pullup_en = ESP32_TouchGUI1_Definition->i2c_config.sda_pullup_en;
  new_scl_io_num = ESP32_TouchGUI1_Definition->i2c_config.scl_io_num;
  new_scl_pullup_en = ESP32_TouchGUI1_Definition->i2c_config.scl_pullup_en;

// -------------------------------------------------------------------------------------------------

  // Block #04 Backup the current I2C clock speed
  uint32_t new_clk_speed;
  new_clk_speed = ESP32_TouchGUI1_Definition->i2c_config.master.clk_speed;

// -------------------------------------------------------------------------------------------------

  // Block #05 Backup the current setting for 10Bit adressing in slave mode
  uint8_t new_addr_10bit_en;
  new_addr_10bit_en = ESP32_TouchGUI1_Definition->i2c_config.slave.addr_10bit_en;

// -------------------------------------------------------------------------------------------------

  // Block #06 Backup the current I2C slave adress in slave
  uint8_t new_slave_addr;
  new_slave_addr = ESP32_TouchGUI1_Definition->i2c_config.slave.slave_addr;

// -------------------------------------------------------------------------------------------------
*/











// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'Block' KEY in advance here, because we need this information early
  // Block=High_Speed|Low_Speed
  // -> Setzt den Hardware-PWM-Block des ESP32 (0=HighSpeed / 1= LowSpeed) der verwendet werden soll
  // -> Sets the hardware-PWM-Block of the ESP32 (0=HighSpeed / 1= LowSpeed) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_BLOCK) ) {
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_BLOCK].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_BLOCK].len, &newBlock, ESP32_TouchGUI1_PWM_BLOCK)
		&& (newBlock <= 1) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
  /*
  // we need to process the 'CHANNEL' KEY in advance here, because we need this information early
  // CHANNEL=[0-7]
  // -> Setzt den Hardware-PWM-Kanal des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware-pwm-channel of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_CHANNEL) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CHANNEL].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CHANNEL].len, &newChannel) 
		&& (newChannel <= 7) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'TIMER' KEY in advance here, because we need this information early
  // TIMER=[0-3]
  // -> Setzt den Hardware-Timer f\FCr den gew\E4hlten PWM-Kanal des ESP32 (0-3) der verwendet werden soll
  // -> Sets the hardware-timer for the choosen pwm-channel of the ESP32 (0-3) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_TIMER) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_TIMER].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_TIMER].len, &newTimer) 
		&& (newTimer <= 3) ) {
*/
/*
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
*/
/*
		}
	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*
  // block #4 get current assigned / connected GPIO
  uint8_t newGPIO = ESP32_TouchGUI1_Definition->GPIO;
  // block #5 reserve for new ATT
  uint32_t newATTVal;
  // block #6 reserve for new AVU
  char newAverageUnit[3];	
  // block #7  get ESP32 PWM channel configuration from selected channel
  // this stores our temp values
  ESP32_PWM_Channel_t newPWM_Channel;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * newChannel));
  // access low speed channels (instead of high speed channels)?
  if (newBlock) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // move data to temp storage
  memcpy(&newPWM_Channel, pPWM_Channel, sizeof(ESP32_PWM_Channel_t));
  // block #8  get ESP32 PWM timer configuration from selected timer
  // this stores our temp values
  ESP32_PWM_Timer_t newPWM_Timer;
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * newTimer));
  // access low speed timers (instead of high speed timers)?
  if (newBlock) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
  // move data to temp storage
  memcpy(&newPWM_Timer, pPWM_Timer, sizeof(ESP32_PWM_Timer_t));
  // store choosen timer in choosen channel
  newPWM_Channel.TIMER_SEL = newTimer;
*/



// ------------------------------------------------------------------------------------------------
// 2. Step: Process the possible input keys



// -------------------------------------------------------------------------------------------------
// I2C_NUM=[0-9] -> Setzt den I2C-Block der verwendet werden soll (0-1) 
// I2C_NUM=[0-9] -> Set the I2C-Block that should be used (0-1) 
/*
  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_I2C_NUM) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_NUM].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_NUM].len
		,&number)) {

		if (number < I2C_NUM_MAX) {

			// valid, take it
			new_i2c_num = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_NUM].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_NUM");
		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// I2C_MODE=[Master|Slave] -> Setzt den I2C modus ()
// I2C_MODE=[Master|Slave] -> Set the I2C mode ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_I2C_MODE) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_MODE].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_MODE].len, &number, ESP32_TouchGUI1_I2C_MODE)) {

		// valid, take it
		new_i2c_mode = number;

		// mark affected readings for TX
		affectedReadings |= 
			parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_I2C_MODE].affectedReadings;

//		// Push processed CMD to to Response ...
//		RespArgsWPos += sprintf( RespArgsWPos,"cmd=I2C_MODE");
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO=[0-9] -> Setzt den SDA IO Pin für I2C (?)
// SDA_IO=[0-9] -> Set the SDA IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SDA_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO].len, &number)) {

		if (GPIO_IS_VALID_OUTPUT_GPIO(number)) {

			// valid, take it
			new_sda_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SDA_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SDA IO Pin für I2C ()
// SDA_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SDA IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SDA_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO_PULLUP].len, &number, ESP32_TouchGUI1_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_sda_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_sda_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SDA_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SDA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO=[0-9] -> Setzt den SCL IO Pin für I2C (?)
// SCL_IO=[0-9] -> Set the SCL IO Pin for I2C (?)

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SCL_IO) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO].len, &number)) {

		if ((GPIO_IS_VALID_OUTPUT_GPIO(number)) ||
    			(GPIO_IS_VALID_GPIO(number) && new_i2c_mode == I2C_MODE_SLAVE)) {

			// valid, take it
			new_scl_io_num = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SCL_IO");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SCL_IO_PULLUP=[Disabled|Enabled] -> Setzt einen Pullup-Widerstand am SCL IO Pin für I2C ()
// SCL_IO_PULLUP=[Disabled|Enabled] -> Set an pullup-resistor at SCL IO Pin for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SCL_IO_PULLUP) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO_PULLUP].len, &number, ESP32_TouchGUI1_DisEna)) {

		if ((number == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(new_scl_io_num)) ||
			number == GPIO_PULLUP_DISABLE) {

			// valid, take it
			new_scl_pullup_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO_PULLUP].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=CLA_IO_PULLUP");
		}

		// invalid input detected ?
		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// MASTER_CLOCK=[0-9] -> Setzt den I2C-Takt (0-1) 
// MASTER_CLOCK=[0-9] -> Set the I2C-Clock (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_MASTER_CLOCK) {

	uint32_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val(argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_MASTER_CLOCK].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_MASTER_CLOCK].len, &number)) {

//		if (number < 65000) { //?????????????????????????????

			// valid, take it
			new_clk_speed = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_MASTER_CLOCK].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=MASTER_CLOCK");
//		}
	}

	// invalid input detected ?
	else return true;
  }

// --------------------------------------------------------------------------------------------------
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Setzt 10Bit Adressierung - im Slave-Mode für I2C ()
// SLAVE_10BIT_ENA=[Disabled|Enabled] -> Set 10Bit adresing - in slave-mode for I2C ()

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID(argsText+parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SCL_IO_PULLUP].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA].len, &number, ESP32_TouchGUI1_DisEna)) {

//		if (number < 65000) { //?????????????????????????????


			// valid, take it
			new_addr_10bit_en = number;

			// mark affected readings for TX
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_10BIT_ENA");
//		}

		// invalid input detected ?
//		else return true;
	}

	// invalid input detected ?
	else return true;
  }

// -------------------------------------------------------------------------------------------------
// SLAVE_ADRESS=[0-9] -> Setzt die I2C-Slave-Adrsse (0-1) 
// SLAVE_ADRESS=[0-9] -> Set the I2C-Slave-Adress (0-1) 

  if (parsedKVInput->keysFoundBF & (uint64_t) 1 << ESP32_TouchGUI1_SET_SLAVE_ADRESS) {

	uint8_t number;

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val(argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SLAVE_ADRESS].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SLAVE_ADRESS].len
		,&number)) {

		if (number < 100) { //?????????????????????????????

			// valid, take it
			new_slave_addr = number;

			// set affected reading
			affectedReadings |= 
				parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_SLAVE_ADRESS].affectedReadings;

//			// Push processed CMD to to Response ...
//			RespArgsWPos += sprintf( RespArgsWPos,"cmd=SLAVE_ADRESS");
		}
	}

	// invalid input detected ?
	else return true;
  }










*/




















/*
//>Caps Bit 0---------------------------------------------------------------------------------------
  // on=[ ] -> Setze Kanal an (0-x)
  // on=[ ] -> Set channel on (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_on)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_on].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
//--------------------------------------------------------------------------------------------------
  // off=[ ] -> Setze Kanal aus (0-x)
  // off=[ ] -> Set channel off (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_off)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_off].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=off");
	}
//>Caps Bit 1---------------------------------------------------------------------------------------
  // max=[ ] -> Setze Kanal maximal (0-x)
  // max=[ ] -> Set channel maximum (0-x) 
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_max)
	{
	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_max].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=max");
	}
//--------------------------------------------------------------------------------------------------
  // min=[ ] -> Setze Kanal minimal (0-x)
  // min=[ ] -> Set channel minimal (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_min)
	{
	// New Value = Min
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_min].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=min");
	}
//>Caps Bit 2---------------------------------------------------------------------------------------
  // val=[0-9] -> Setze Wert f\FCr Kanal (uint8) (0-x)
  // val=[0-9] -> Set value for channel (uint8) (0-x)
 else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_val)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_val].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_val].len, &NewVal))
		{
		// val input value clipping
		if (NewVal > SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax;
			}
		else if (NewVal < SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin)
			{
			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin;
			}
		// save mirror
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_val].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=val");
		}
	}
//>Caps Bit 3---------------------------------------------------------------------------------------
  // dim=[0-9] -> Setze dimmer f\FCr Kanal (uint8) (0-x)
  // dim=[0-9] -> Set dimming for channel (uint8) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_dim)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].len, &NewVal))
		
		{
		// dim input value clipping
		if (NewVal > 100) NewVal = 100;
		else if (NewVal < 0) NewVal = 0;
		// calculate val from dim
		NewVal = ( (NewVal *
			(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
			SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) /
			100 );
		// New Value = calculated from input
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);
		// save mirror
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=dim");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_name].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) )
		{	
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_name].AffectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_caps)
	{
	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_caps].AffectedReadings;
	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
		GetUniqueTIST();
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");
	}
*/

/*
  // ATT=[0-9]
  // -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Z\E4hlerstand
  // -> Set alltime-total-tics meeting the currend meter-reading
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_ATT) ) {
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &newATTVal)) {
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= newATTVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------
  // AVU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Durchschnitts-Verbrauchs-Wert (char[3])
  // -> Set unit for average-consumption-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_AVU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &newAverageUnit
		,sizeof (newAverageUnit) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		,3) ) {
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 1---------------------------------------------------------------------------------------
  // AVF=[0-9.]
  // -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // -> Set average consumption calculation factor (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_AVF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");
		}
	// invalid input detected ?
	else return true;
  }
//--------------------------------------------------------------------------------------------------
  // ATU=[a-zA-Z0-9_.]
  // -> Setze Einheit f\FCr den Allzeit-Gesamt-Wert (char[3])
  // -> Set unit for alltime-total-value (char[3])
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_ATU) ) {
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"\B3") for Unit Name
		 {
		// store the value to temp
		//befehl hier!;
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 2---------------------------------------------------------------------------------------
  // ATF=[0-9.]
  // -> Setze Umrechnungsfaktor f\FCr den Allzeit-Total-Wert (float)
  // -> Set factor for alltime total value (float)
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_ATF) ) {
	double NewVal;
	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal)) {
		// store the value to temp
		//befehl hier!;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");
		}
	// invalid input detected ?
	else return true;
  }
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_TouchGUI1_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_TouchGUI1_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
//>Caps Bit 3---------------------------------------------------------------------------------------
  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)
	{
	uint32_t NewVal;
	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))
		{
		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)
	{
	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)
		{	
		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");
		}
	}
//>Caps Bit n.a.------------------------------------------------------------------------------------
  // caps=[ ] -> Fragt nach den F\E4higkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)
 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{
	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;
//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());
	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");
	}
//> ------------------------------------------------------------------------------------------------
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_CH1_LCTRL_MODE) ) {
	uint8_t newMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_LCTRL_MODE].len, &newMode, &ESP32_TouchGUI1_CTRL_MODE)
		&& (newMode <= 3) ) {
		// store the value to temp
		ESP32_TouchGUI1_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_CH1_HCTRL_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_HCTRL_MODE].len, &NewMode, ESP32_TouchGUI1_CTRL_MODE) ) {
		// store ne value
		ESP32_TouchGUI1_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << ESP32_TouchGUI1_SET_CH1_POS_MODE) ) {
	uint8_t NewMode;
	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[ESP32_TouchGUI1_SET_CH1_POS_MODE].len, &NewMode, ESP32_TouchGUI1_CH_MODE) ) {
		// store ne value
		ESP32_TouchGUI1_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;
		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;
		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();
		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;
		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();
		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");
		}
	// invalid input detected ?
	else return true;
  }
*/



// ------------------------------------------------------------------------------------------------
// 3. Step: check if all required Key=Value components for operation are included
//          -> if not, return with msg

  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! NOT all required Key=Value args found!");

	return retMsg;
  }



// ------------------------------------------------------------------------------------------------
// 4. Step: check if forbidden Key=Value components are included
//          -> if not, return with msg

  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! FORBIDDEN Key=Value args found!");

	return retMsg;
  }













// ------------------------------------------------------------------------------------------------
// 5. Step: Changes will happen, deinit old ...


/*
esp_err_t i2c_driver_delete(i2c_port_t i2c_num)
{

    I2C_CHECK(i2c_num < I2C_NUM_MAX, I2C_NUM_ERROR_STR, ESP_ERR_INVALID_ARG);
    I2C_CHECK(p_i2c_obj[i2c_num] != NULL, I2C_DRIVER_ERR_STR, ESP_FAIL);
    i2c_obj_t* p_i2c = p_i2c_obj[i2c_num];

    uint32_t intr_mask = I2C_MASTER_TRAN_COMP_INT_ENA_M |
                         I2C_TIME_OUT_INT_ENA_M |
                         I2C_TRANS_COMPLETE_INT_ENA_M |
                         I2C_TRANS_START_INT_ENA_M |
                         I2C_TX_SEND_EMPTY_INT_ENA_M |
                         I2C_ARBITRATION_LOST_INT_ENA_M |
                         I2C_ACK_ERR_INT_ENA_M |
                         I2C_RXFIFO_OVF_INT_ENA_M |
                         I2C_RX_REC_FULL_INT_ENA_M |
                         I2C_SLAVE_TRAN_COMP_INT_ENA_M;

    CLEAR_PERI_REG_MASK(I2C_INT_ENA_REG(i2c_num), intr_mask);

    esp_intr_free(p_i2c->intr_handle);

    p_i2c->intr_handle = NULL;

    if (p_i2c->cmd_mux) {
        xSemaphoreTake(p_i2c->cmd_mux, portMAX_DELAY);
        vSemaphoreDelete(p_i2c->cmd_mux);
    }
    if (p_i2c->cmd_sem) {
        vSemaphoreDelete(p_i2c->cmd_sem);
    }
    if (p_i2c->slv_rx_mux) {
        vSemaphoreDelete(p_i2c->slv_rx_mux);
    }
    if (p_i2c->slv_tx_mux) {
        vSemaphoreDelete(p_i2c->slv_tx_mux);
    }
    if (p_i2c->rx_ring_buf) {
        vRingbufferDelete(p_i2c->rx_ring_buf);
        p_i2c->rx_ring_buf = NULL;
        p_i2c->rx_buf_length = 0;
    }
    if (p_i2c->tx_ring_buf) {
        vRingbufferDelete(p_i2c->tx_ring_buf);
        p_i2c->tx_ring_buf = NULL;
        p_i2c->tx_buf_length = 0;
    }

    free(p_i2c_obj[i2c_num]);
    p_i2c_obj[i2c_num] = NULL;

    return ESP_OK;
}
*/



// ------------------------------------------------------------------------------------------------
// 6. Step: Make the changes effective ...
/*
  // block #1 store/use I2C Block (0 / 1)
  if (parsedKVInput->keysFoundBF | (1 << ESP32_TouchGUI1_SET_I2C_NUM) ) {

	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 I2C_NUM=%d>"
		,new_i2c_num);	
  	#endif

	// enable i2c 0
	if (new_i2c_num == I2C_NUM_0) {

		periph_module_enable(PERIPH_I2C0_MODULE);
	}

	// enable i2c 1
	else if (new_i2c_num == I2C_NUM_1) {

		periph_module_enable(PERIPH_I2C1_MODULE);
	}

	// store assigned I2C Block
	ESP32_TouchGUI1_Definition->i2c_num = 
		new_i2c_num;
  }

// ------------------------------------------------------------------------------------------------

  // block #2 store/use I2C Mode (Master/Slave)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_TouchGUI1_SET_I2C_MODE) ) ) {

	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 I2C_MODE=%d>"
		,new_i2c_mode);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set rx data msb first
	I2C[new_i2c_num]->ctr.rx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// set tx data msb first
	I2C[new_i2c_num]->ctr.tx_lsb_first = I2C_DATA_MODE_MSB_FIRST;

	// mode for master or slave
	I2C[new_i2c_num]->ctr.ms_mode = new_i2c_mode;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.sda_force_out = 1;

	// set open-drain output mode
	I2C[new_i2c_num]->ctr.scl_force_out = 1;

	// sample at high level of clock
	I2C[new_i2c_num]->ctr.sample_scl_level = 0;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;

		I2C[new_i2c_num]->fifo_conf.fifo_addr_cfg_en = 0;

		I2C[new_i2c_num]->fifo_conf.rx_fifo_full_thrhd =
			I2C_FIFO_FULL_THRESH_VAL;

		I2C[new_i2c_num]->fifo_conf.tx_fifo_empty_thrhd =
			I2C_FIFO_EMPTY_THRESH_VAL;

		I2C[new_i2c_num]->int_ena.rx_fifo_full = 1;

		I2C[new_i2c_num]->ctr.trans_start = 0;
	}

	// master mode ?
	else {

		I2C[new_i2c_num]->fifo_conf.nonfifo_en = 0;
	}

	// ??
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Mode
	ESP32_TouchGUI1_Definition->i2c_config.mode
		= new_i2c_mode;
  }

// ------------------------------------------------------------------------------------------------

  // block #3 store/use I2C Pin connections
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_TouchGUI1_SET_SDA_IO)
			       		| (1 << ESP32_TouchGUI1_SET_SDA_IO_PULLUP)
			       		| (1 << ESP32_TouchGUI1_SET_SCL_IO)
			       		| (1 << ESP32_TouchGUI1_SET_SCL_IO_PULLUP) ) ) {

	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 I2C Pins SDA_IO=%d, SDA_IO_PULLUP=%d,SCL_IO=%d, SCL_IO_PULLUP=%d,>"
		,new_sda_io_num,new_sda_pullup_en,new_scl_io_num,new_scl_pullup_en);	
  	#endif



*/
/*


  SCDE_CHECK(( i2c_num < I2C_NUM_MAX ), I2C_NUM_ERROR_STR);
  SCDE_CHECK(((GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num))), I2C_SDA_IO_ERR_STR);
  SCDE_CHECK((GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
              (GPIO_IS_VALID_GPIO(scl_io_num) && mode == I2C_MODE_SLAVE),
              I2C_SCL_IO_ERR_STR);
  SCDE_CHECK((sda_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(sda_io_num)) ||
               sda_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
  SCDE_CHECK((scl_pullup_en == GPIO_PULLUP_ENABLE && GPIO_IS_VALID_OUTPUT_GPIO(scl_io_num)) ||
               scl_pullup_en == GPIO_PULLUP_DISABLE, I2C_GPIO_PULLUP_ERR_STR);
*/
/*
	int sda_in_sig, sda_out_sig, scl_in_sig, scl_out_sig;

	// prepare the i2c gpio settings according to used hardware 
	switch (new_i2c_num) {

		case I2C_NUM_1:
			sda_out_sig = I2CEXT1_SDA_OUT_IDX;
			sda_in_sig = I2CEXT1_SDA_IN_IDX;
			scl_out_sig = I2CEXT1_SCL_OUT_IDX;
			scl_in_sig = I2CEXT1_SCL_IN_IDX;
			break;

		case I2C_NUM_0:
			default:
			sda_out_sig = I2CEXT0_SDA_OUT_IDX;
			sda_in_sig = I2CEXT0_SDA_IN_IDX;
			scl_out_sig = I2CEXT0_SCL_OUT_IDX;
			scl_in_sig = I2CEXT0_SCL_IN_IDX;
			break;
	}

	// sda gpio configuration
	if (new_sda_io_num >= 0) {

		gpio_set_level(new_sda_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_sda_io_num], PIN_FUNC_GPIO);

		gpio_set_direction(new_sda_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

		if (new_sda_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_sda_io_num, GPIO_PULLUP_ONLY);
		 } 

		else {

			gpio_set_pull_mode(new_sda_io_num, GPIO_FLOATING);
 		}

		gpio_matrix_out(new_sda_io_num, sda_out_sig, 0, 0);

		gpio_matrix_in(new_sda_io_num, sda_in_sig, 0);
	}

	// scl gpio configuration
	if (new_scl_io_num >= 0) {

		gpio_set_level(new_scl_io_num, I2C_IO_INIT_LEVEL);

		PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[new_scl_io_num], PIN_FUNC_GPIO);

		if (new_i2c_mode == I2C_MODE_MASTER) {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT_OUTPUT_OD);

			gpio_matrix_out(new_scl_io_num, scl_out_sig, 0, 0);
		}

		else {

			gpio_set_direction(new_scl_io_num, GPIO_MODE_INPUT);
		}

		if (new_scl_pullup_en == GPIO_PULLUP_ENABLE) {

			gpio_set_pull_mode(new_scl_io_num, GPIO_PULLUP_ONLY);
		}

		else {

			gpio_set_pull_mode(new_scl_io_num, GPIO_FLOATING);
		}

		gpio_matrix_in(new_scl_io_num, scl_in_sig, 0);
 	}

	// store assigned I2C Pin connections
	ESP32_TouchGUI1_Definition->i2c_config.sda_io_num
		= new_sda_io_num;

	ESP32_TouchGUI1_Definition->i2c_config.sda_pullup_en
		= new_sda_pullup_en;

	ESP32_TouchGUI1_Definition->i2c_config.scl_io_num
		= new_scl_io_num;

	ESP32_TouchGUI1_Definition->i2c_config.scl_pullup_en
		= new_scl_pullup_en;
  }

// ------------------------------------------------------------------------------------------------

  // block #4 store/use I2C clock speed (when use as master only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_TouchGUI1_SET_MASTER_CLOCK) ) ) {

	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 MASTER_CLOCK=%d>"
		,new_clk_speed);	
  	#endif

	// ??
	I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// set frequency
	int half_cycle = ( I2C_APB_CLK_FREQ / new_clk_speed ) / 2;
	I2C[new_i2c_num]->scl_low_period.period =
		 half_cycle - 1;
	I2C[new_i2c_num]->scl_high_period.period =
		( I2C_APB_CLK_FREQ / new_clk_speed ) - half_cycle - 1;

	// set timing for start signal
	I2C[new_i2c_num]->scl_start_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_rstart_setup.time = half_cycle;

	// set timing for stop signal
	I2C[new_i2c_num]->scl_stop_hold.time = half_cycle;
	I2C[new_i2c_num]->scl_stop_setup.time = half_cycle;

	// set timing for data
	I2C[new_i2c_num]->sda_hold.time = half_cycle / 2;
	I2C[new_i2c_num]->sda_sample.time = half_cycle / 2;

	// set timeout of receving data
	I2C[new_i2c_num]->timeout.tout = 200000;

	// ???
	I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);

	// store assigned I2C Pin connections
	ESP32_TouchGUI1_Definition->i2c_config.master.clk_speed =
		new_clk_speed;
  }

// ------------------------------------------------------------------------------------------------

  // block #5 store/use I2C 10bit enable (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_TouchGUI1_SET_SLAVE_10BIT_ENA) ) ) {
*/
/*	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/
/*
	// store assigned I2C Pin connections
	ESP32_TouchGUI1_Definition->i2c_config.slave.addr_10bit_en =
		new_addr_10bit_en;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.en_10bit =
			new_addr_10bit_en;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------

  // block #6 store/use I2C slave adress (when use as slave only!)
  if (parsedKVInput->keysFoundBF |   	( (1 << ESP32_TouchGUI1_SET_SLAVE_ADRESS) ) ) {
*/
/*	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif*/
/*
	// store assigned I2C Pin connections
	ESP32_TouchGUI1_Definition->i2c_config.slave.slave_addr =
		new_slave_addr;

	// slave mode ?
	if (new_i2c_mode == I2C_MODE_SLAVE) {

		// ??
		I2C_ENTER_CRITICAL(&i2c_spinlock[new_i2c_num]);

		I2C[new_i2c_num]->slave_addr.addr =
			new_slave_addr;

		// ???
		I2C_EXIT_CRITICAL(&i2c_spinlock[new_i2c_num]);
	}
  }

// ------------------------------------------------------------------------------------------------






*/
/*
  // block #1 store assigned PWM-Block (low speed / high speed)
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_TouchGUI1_SET_BLOCK) ) ) {
	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif
	// store assigned PWM-Block
	ESP32_TouchGUI1_Definition->Block = newBlock;
  }
  // block #2 store assigned PWM Channel
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_TouchGUI1_SET_CHANNEL) ) ) {
	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#02 PWM_Channel=%d>"
		,newChannel);	
  	#endif
	// store assigned PWM Channel
	ESP32_TouchGUI1_Definition->Channel = newChannel;
  }
  // block #3 store assigned PWM Timer
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_TouchGUI1_SET_TIMER) ) ) {
	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#03 PWM_Timer=%d>"
		,newTimer);	
  	#endif
	// store assigned PWM Timer
	ESP32_TouchGUI1_Definition->Timer = newTimer;
  }
  // block #4 store assigned / connected GPIO
  if (parsedKVInput->keysFoundBF | ( (1 << ESP32_TouchGUI1_SET_GPIO) ) ) {
	#if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|W B#04 PWM_GPIO=%d>"
		,newGPIO);	
  	#endif
	// store assigned GPIO
	ESP32_TouchGUI1_Definition->GPIO = newGPIO;
	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newGPIO], PIN_FUNC_GPIO);
	// set GPIO as output
	gpio_set_direction(newGPIO, GPIO_MODE_OUTPUT);
	// configure for high-speed or low-speed ?
	if (newBlock) {
		// setup gpio matrix for low speed
	}
	else {
		// setup gpio matrix for high speed
		gpio_matrix_out(newGPIO, LEDC_HS_SIG_OUT0_IDX + newChannel, 0, 0);
		
	}
  }
  // block #5 store ESP32 pwm configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_TouchGUI1_SET_TIMER)
				   | (1 << ESP32_TouchGUI1_SET_SIG_OUT_EN)
				   | (1 << ESP32_TouchGUI1_SET_IDLE_LV)
				   | (1 << ESP32_TouchGUI1_SET_HPOINT)
				   | (1 << ESP32_TouchGUI1_SET_DUTY) ) ) {
	// store ESP32 PWM configuration registers
	memcpy(pPWM_Channel, &newPWM_Channel, sizeof(ESP32_PWM_Channel_t));
	# if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|ESP32_PWM_Channel_s addr=%p>"
		,pPWM_Channel);
	SCDEFn_at_ESP32_TouchGUI1_M->HexDumpOutFn ("dump"
		,pPWM_Channel
		, sizeof(ESP32_PWM_Channel_t) );
	# endif
  }
  // block #6 store ESP32 pwm-timer configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << ESP32_TouchGUI1_SET_TIMER)
				   | (1 << ESP32_TouchGUI1_SET_RESOLUTION )
				   | (1 << ESP32_TouchGUI1_SET_TICK_SOURCE)
			   	   | (1 << ESP32_TouchGUI1_SET_FREQ_HZ) ) ) {
	// reset? It seems that a reset is needed to start timer
	newPWM_Timer.RESET = 0;
	// low speed timer? -> needs 'LOW_SPEED_UPDATE' bit set to take settings
	if (!newBlock) newPWM_Timer.LOW_SPEED_UPDATE = 1;
	// store ESP32 timer configuration registers
	memcpy(pPWM_Timer, &newPWM_Timer, sizeof(ESP32_PWM_Timer_t));
	# if ESP32_TouchGUI1_Module_DBG >= 5
	printf("|ESP32_PWM_Timer_s addr=%p>"
		,pPWM_Timer);
	SCDEFn_at_ESP32_TouchGUI1_M->HexDumpOutFn ("dump"
		,pPWM_Timer
		, sizeof(ESP32_PWM_Timer_t) );
	# endif
  }
*/


// ------------------------------------------------------------------------------------------------
// 7. Step:Set affected readings




  return retMsg;

}
















/*
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_val)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&val=%u",(uint) SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val);
	}
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_dim)
	{
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&dim=%u",(100 *
		(SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val -
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) / 
		(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) );
	}
//>Add Readings Bit 02 -----------------------------------------------------------------------------
  if (AffectedReadings & SwITCH_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += SwITCH_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=000F");						// 0b1111 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
//>always add Reading - state ----------------------------------------------------------------------
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	if (SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val == 0)
		RespArgsWPos += os_sprintf(RespArgsWPos, "state=off");
	else  RespArgsWPos += os_sprintf(RespArgsWPos, "state=on");
//--------------------------------------------------------------------------------------------------
*/
















/**
 * ------------------------------------------------------------------------------------------------
 *  FName: ESP32_TouchGUI1_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: ESP32_TouchGUI1_Definition_t *ESP32_TouchGUI1_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
ESP32_TouchGUI1_SetAffectedReadings(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition
	,uint64_t affectedReadings)
{
/*
 affectedReadings = 0xfffffffffffffff;
  // do we have updates?
  if (affectedReadings) {
  SCDEFn_at_ESP32_TouchGUI1_M->readingsBeginUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition);
  }
  // we have no updates
  else return false;
// -----------------------------------------------------------------------------------------------
  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * ESP32_TouchGUI1_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (ESP32_TouchGUI1_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * ESP32_TouchGUI1_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (ESP32_TouchGUI1_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
//>Add Readings Bit 00 -----------------------------------------------------------------------------
  // add reading 'Duty'
  if (affectedReadings & ESP32_TouchGUI1_R_DUTY) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Duty");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,pPWM_Channel->DUTY);
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
//>Add Readings Bit 01 -----------------------------------------------------------------------------
  // add reading 'Resolution'
  if (affectedReadings & ESP32_TouchGUI1_R_RESOLUTION) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Resolution");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,(1 << pPWM_Timer->RESOLUTION) );
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_TouchGUI1_R_AV01_AV05_AV15) {
	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...
	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );
		}
	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );
		}
	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?
		{
		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	
		}
	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Factor' //avf'
  if (affectedReadings & ESP32_TouchGUI1_R_AVF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) ESP32_TouchGUI1_Definition->IB01_AverageFactor	
		,(int) ( (ESP32_TouchGUI1_Definition->IB01_AverageFactor -
		(int) ESP32_TouchGUI1_Definition->IB01_AverageFactor) * 10000) );
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Unit' //avu'
  if (affectedReadings & ESP32_TouchGUI1_R_AVU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_TouchGUI1_Definition->IB01_AverageUnit);
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & ESP32_TouchGUI1_R_ATF) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (ESP32_TouchGUI1_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (ESP32_TouchGUI1_Definition->IB01_AlltimeTotalFactor -
		(int) ESP32_TouchGUI1_Definition->IB01_AlltimeTotalFactor) * 10000) );
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & ESP32_TouchGUI1_R_ATU) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,ESP32_TouchGUI1_Definition->IB01_AlltimeTotalUnit);
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------
/*
  // add reading 'Debounce' //deb'
  if (affectedReadings & ESP32_TouchGUI1_R_DEB) {
	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");
	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,ESP32_TouchGUI1_Definition->IB01_Debounce);
	SCDEFn_at_ESP32_TouchGUI1_M->readingsBulkUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & ESP32_TouchGUI1_R_name)
	{
	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);
	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX
	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);
	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");
	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
//  SCDEFn_at_ESP32_TouchGUI1_M->readingsEndUpdateFn((Common_Definition_t*) ESP32_TouchGUI1_Definition);


  return true;
}












































































































/*
 *  Author: LoBo (loboris@gmail.com, loboris.github)
 *
 *  Module supporting SPI TFT displays based on ILI9341 & ILI9488 controllers
 * 
 * HIGH SPEED LOW LEVEL DISPLAY FUNCTIONS
 * USING DIRECT or DMA SPI TRANSFER MODEs
 *
*/

#include <string.h>
//#include "tftspi.h"
#include "esp_system.h"
#include "freertos/task.h"
#include "esp_heap_caps.h"
#include "soc/spi_reg.h"


// ====================================================
// ==== Global variables, default values ==============

// Converts colors to grayscale if set to 1
//uint8_t gray_scale = 0;
// Spi clock for reading data from display memory in Hz
uint32_t max_rdclock = 8000000;

// Default display dimensions
//int _width = DEFAULT_TFT_DISPLAY_WIDTH;
//int _height = DEFAULT_TFT_DISPLAY_HEIGHT;

// Display type, DISP_TYPE_ILI9488 or DISP_TYPE_ILI9341
//uint8_t tft_disp_type = DEFAULT_DISP_TYPE;

// Spi device handles for display and touch screen
//ESP32_SPI_Module_spi_device_handle_t disp_spi = NULL;
//ESP32_SPI_Module_spi_device_handle_t ts_spi = NULL;

// ====================================================


static color_t *trans_cline = NULL;
static uint8_t _dma_sending = 0;

// RGB to GRAYSCALE constants
// 0.2989  0.5870  0.1140
#define GS_FACT_R 0.2989
#define GS_FACT_G 0.4870
#define GS_FACT_B 0.2140



// ==== Functions =====================


/*

//------------------------------------------------------
esp_err_t IRAM_ATTR 
wait_trans_finish(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	 uint8_t free_line) {

  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

  // Wait for SPI bus ready
  while (ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr);

  if ((free_line) && (trans_cline)) {

	free(trans_cline);
	trans_cline = NULL;
  }

  if (_dma_sending) {

  //Tell common code DMA workaround that our DMA channel is idle. If needed, the code will do a DMA reset.
	if (ESP32_TouchGUI1_Definition->disp_handle->host->dma_chan) 
		ESP32_SPI_provided_fn->ESP32_SPI_spi_dmaworkaround_idleFn(ESP32_TouchGUI1_Definition->disp_handle->host->dma_chan);

	// Reset DMA
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_conf.val |= SPI_OUT_RST|SPI_IN_RST|SPI_AHBM_RST|SPI_AHBM_FIFO_RST;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_out_link.start=0;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_in_link.start=0;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_conf.val &= ~(SPI_OUT_RST|SPI_IN_RST|SPI_AHBM_RST|SPI_AHBM_FIFO_RST);
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_conf.out_data_burst_en=1;
	_dma_sending = 0;
  }

  return ESP_OK;
}


*/
//-------------------------------
esp_err_t IRAM_ATTR 
disp_select(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;
/*
  wait_trans_finish(ESP32_TouchGUI1_Definition, 1);
  return ESP32_SPI_provided_fn->ESP32_SPI_spi_device_selectFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle, 0);*/
 return ESP_OK;
}



//---------------------------------
esp_err_t IRAM_ATTR 
disp_deselect(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

//  wait_trans_finish(ESP32_TouchGUI1_Definition, 1);

//  return ESP32_SPI_provided_fn->ESP32_SPI_spi_device_deselectFn(ESP32_TouchGUI1_Definition->disp_handle);
return ESP_OK;
}

/*

// verschieben zu ESP32_SPI_Module 
// _ private Fn to start spi transfer
//---------------------------------------------------------------------------------------------------
static void IRAM_ATTR 
_spi_transfer_start(ESP32_SPI_Module_spi_device_handle_t spi_dev,
	int wrbits,
	int rdbits)
{
  // Load send buffer
  spi_dev->host->hw->user.usr_mosi_highpart = 0;
  spi_dev->host->hw->mosi_dlen.usr_mosi_dbitlen = wrbits-1;
  spi_dev->host->hw->user.usr_mosi = 1;

  if (rdbits) {

	spi_dev->host->hw->miso_dlen.usr_miso_dbitlen = rdbits;
	spi_dev->host->hw->user.usr_miso = 1;
  }

  else {

	spi_dev->host->hw->miso_dlen.usr_miso_dbitlen = 0;
	spi_dev->host->hw->user.usr_miso = 0;
  }

  // Start transfer
  spi_dev->host->hw->cmd.usr = 1;

  // Wait for SPI bus ready
  while (spi_dev->host->hw->cmd.usr);
}

*/



// Send command (1 byte) to spi device
//------------------------------------------------
void IRAM_ATTR 
ESP32_SPI_transfer_only_cmd(ESP32_SPI_device_handle_t spi_device_handle,
	const int8_t cmd)
{
  esp_err_t ret;

  ESP32_SPI_transaction_t t;

  memset(&t, 0, sizeof(t));	// Zero out the transaction

  t.length = 8;			// Command is 8 bits
  t.tx_buffer = &cmd;		// The data is the cmd itself
  t.user = (void*) 0;		// D/C needs to be set to 0 for cmd

  ret = ESP32_SPI_device_polling_transmit(spi_device_handle, &t);

  assert(ret == ESP_OK);	// Should have had no issues.
}



// Send data (len byte) to spi device
//------------------------------------------------
void IRAM_ATTR 
ESP32_SPI_transfer_only_data(ESP32_SPI_device_handle_t spi_device_handle,
	const uint8_t *data,
	int len)
{
  esp_err_t ret;

  if ( len == 0 ) return;	// no need to send anything

  ESP32_SPI_transaction_t t;

  memset(&t, 0, sizeof(t));	// Zero out the transaction

  t.length = len * 8;		// Data is len * 8 bits
  t.tx_buffer = data;		// The data is the cmd itself
  t.user = (void*) 1;		// D/C needs to be set to 1 for data

  ret = ESP32_SPI_device_polling_transmit(spi_device_handle, &t);

  assert(ret == ESP_OK);	// Should have had no issues.
}



// unklare funktion, setzt auch andere register? PIN_NUM_DC? Daten queuen?
// Set the address window for display write & read commands, display must be selected
//---------------------------------------------------------------------------------------------------
static void IRAM_ATTR 
//TFT_set_spitransfer_addrwin
disp_spi_transfer_addrwin(ESP32_SPI_device_handle_t spi_device_handle,
	uint16_t x1,
	uint16_t x2,
	uint16_t y1,
	uint16_t y2)
{
  // width x data temp
  uint32_t xwd;

  // calculate width data
  xwd  = (uint32_t) (x1 >> 8);
  xwd |= (uint32_t) (x1 & 0xff) << 8;
  xwd |= (uint32_t) (x2 >> 8) << 16;
  xwd |= (uint32_t) (x2 & 0xff) << 24;

  ESP32_SPI_polling_transmit_cmd_and_data(spi_device_handle,
	TFT_CASET,
	&xwd,
	4);

 // width y data temp
  uint32_t ywd;

 // calculate width data
  ywd  = (uint32_t) (y1 >> 8);
  ywd |= (uint32_t) (y1 & 0xff) << 8;
  ywd |= (uint32_t) (y2 >> 8) << 16;
  ywd |= (uint32_t) (y2 & 0xff) << 24;

  ESP32_SPI_polling_transmit_cmd_and_data(spi_device_handle,
	TFT_PASET,
	&ywd,
	4);
}



// Convert color to gray scale
//----------------------------------------------
static color_t IRAM_ATTR 
color2gs(color_t color)
{
  color_t _color;

  float gs_clr = GS_FACT_R * color.r + GS_FACT_G * color.g + GS_FACT_B * color.b;

  if (gs_clr > 255) gs_clr = 255;

  _color.r = (uint8_t)gs_clr;
  _color.g = (uint8_t)gs_clr;
  _color.b = (uint8_t)gs_clr;

  return _color;
}



// Set display pixel at given coordinates to given color
//------------------------------------------------------------------------
void IRAM_ATTR 
drawPixel(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	int16_t x,
	int16_t y,
	color_t color,
	uint8_t sel)
{
/*
	if (!(ESP32_TouchGUI1_Definition->disp_handle->cfg.flags & LB_SPI_DEVICE_HALFDUPLEX)) return;

	if (sel) {
		if (disp_select(ESP32_TouchGUI1_Definition)) return;
	}
	else wait_trans_finish(ESP32_TouchGUI1_Definition, 1);

	uint32_t wd = 0;
    color_t _color = color;
	if (ESP32_TouchGUI1_Definition->gray_scale) _color = color2gs(color);

    taskDISABLE_INTERRUPTS();
	disp_spi_transfer_addrwin(ESP32_TouchGUI1_Definition->disp_handle, x, x+1, y, y+1);

	// Send RAM WRITE command
    gpio_set_level(PIN_NUM_DC, 0);
    ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[0] = (uint32_t)TFT_RAMWR;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->mosi_dlen.usr_mosi_dbitlen = 7;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr = 1;		// Start transfer
	while (ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr);	// Wait for SPI bus ready

	wd = (uint32_t)_color.r;
	wd |= (uint32_t)_color.g << 8;
	wd |= (uint32_t)_color.b << 16;

    // Set DC to 1 (data mode);
	gpio_set_level(PIN_NUM_DC, 1);

	ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[0] = wd;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->mosi_dlen.usr_mosi_dbitlen = 23;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr = 1;		// Start transfer
	while (ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr);	// Wait for SPI bus ready

    taskENABLE_INTERRUPTS();
   if (sel) disp_deselect(ESP32_TouchGUI1_Definition);
*/
}

/*

//-----------------------------------------------------------
static void IRAM_ATTR 
_dma_send(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint8_t *data,
	uint32_t size)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

    //Fill DMA descriptors
    ESP32_SPI_provided_fn->ESP32_SPI_spi_dmaworkaround_transfer_activeFn(ESP32_TouchGUI1_Definition->disp_handle->host->dma_chan); //mark channel as active
    ESP32_SPI_provided_fn->ESP32_SPI_spi_setup_dma_desc_linksFn(ESP32_TouchGUI1_Definition->disp_handle->host->dmadesc_tx, size, data, false);

    ESP32_TouchGUI1_Definition->disp_handle->host->hw->user.usr_mosi_highpart=0;
    ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_out_link.addr=(int)(&ESP32_TouchGUI1_Definition->disp_handle->host->dmadesc_tx[0]) & 0xFFFFF;
    ESP32_TouchGUI1_Definition->disp_handle->host->hw->dma_out_link.start=1;
    ESP32_TouchGUI1_Definition->disp_handle->host->hw->user.usr_mosi_highpart=0;

	ESP32_TouchGUI1_Definition->disp_handle->host->hw->mosi_dlen.usr_mosi_dbitlen = (size * 8) - 1;

	_dma_sending = 1;
	// Start transfer
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr = 1;
}



//---------------------------------------------------------------------------
static void IRAM_ATTR 
_direct_send(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition, color_t *color, uint32_t len, uint8_t rep)
{
	uint32_t cidx = 0;	// color buffer index
	uint32_t wd = 0;
	int idx = 0;
	int bits = 0;
	int wbits = 0;

    taskDISABLE_INTERRUPTS();

	color_t _color = color[0];

	if ((rep) && (ESP32_TouchGUI1_Definition->gray_scale)) _color = color2gs(color[0]);

	while (len) {
		// ** Get color data from color buffer **
		if (rep == 0) {
			if (ESP32_TouchGUI1_Definition->gray_scale) _color = color2gs(color[cidx]);
			else _color = color[cidx];
		}

		wd |= (uint32_t)_color.r << wbits;
		wbits += 8;
		if (wbits == 32) {
			bits += wbits;
			wbits = 0;
			ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[idx++] = wd;
			wd = 0;
		}
		wd |= (uint32_t)_color.g << wbits;
		wbits += 8;
		if (wbits == 32) {
			bits += wbits;
			wbits = 0;
			ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[idx++] = wd;
			wd = 0;
		}
		wd |= (uint32_t)_color.b << wbits;
		wbits += 8;
		if (wbits == 32) {
			bits += wbits;
			wbits = 0;
			ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[idx++] = wd;
			wd = 0;
		}
    	len--;					// Decrement colors counter
        if (rep == 0) cidx++;	// if not repeating color, increment color buffer index
    }
	if (bits) {
		while (ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr);						// Wait for SPI bus ready
		ESP32_TouchGUI1_Definition->disp_handle->host->hw->mosi_dlen.usr_mosi_dbitlen = bits-1;	// set number of bits to be sent
        ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr = 1;							// Start transfer
	}
    taskENABLE_INTERRUPTS();
}

*/

// ================================================================
// === Main function to send data to display ======================
// If  rep==true:  repeat sending color data to display 'len' times
// If rep==false:  send 'len' color data from color buffer to display
// ** Device must already be selected and address window set **
// ================================================================
//----------------------------------------------------------------------------------------------
static void IRAM_ATTR 
_TFT_pushColorRep(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	color_t *color,
	uint32_t len, // len in pixel! (3 bytes?)
	uint8_t rep,
	uint8_t wait)
{
  if (len == 0) return;

  // send cmd: write to disp. ram
  ESP32_SPI_transfer_only_cmd(ESP32_TouchGUI1_Definition->disp_handle, (const int8_t) TFT_RAMWR);

  // short transfer? helper does the job
  if ( (len * 24 ) <= 512 ) {

	//ESP32_SPI_transfer_only_data(ESP32_TouchGUI1_Definition->disp_handle, int8_t TFT_RAMWR)
	//_direct_send(ESP32_TouchGUI1_Definition, color, len, rep);
  }

  // false: we send len color data
  else if (rep == 0)  {

	// repare data (rgb - gs conversion)
	if (ESP32_TouchGUI1_Definition->gray_scale) {

		for ( int n = 0 ; n < len ; n++ ) {

			color[n] = color2gs(color[n]);
		}
	}

	ESP32_SPI_transfer_only_data(ESP32_TouchGUI1_Definition->disp_handle,
		(uint8_t*) color,
		len * 3);

	//_dma_send(ESP32_TouchGUI1_Definition, (uint8_t *)color, len * 3);
  }

  // Repeat color, more than 512 bits total
  else {

	color_t _color;
	uint32_t buf_colors;
	int buf_bytes, to_send;

	buf_colors = (( len > (ESP32_TouchGUI1_Definition->_width * 2 )) ? ( ESP32_TouchGUI1_Definition->_width * 2) : len);

	buf_bytes = buf_colors * 3;

	// Prepare color buffer of maximum 2 color lines
	trans_cline = heap_caps_malloc(buf_bytes, MALLOC_CAP_DMA);
	if (trans_cline == NULL) return;

	// Prepare fill color
	if (ESP32_TouchGUI1_Definition->gray_scale) _color = color2gs(color[0]);
	else _color = color[0];

	// Fill color buffer with fill color
	for ( uint32_t i = 0 ; i < buf_colors ; i++ ) {

		trans_cline[i] = _color;
	}

	// Send 'len' colors
	to_send = len;

	while (to_send > 0) {

		ESP32_SPI_transfer_only_data(ESP32_TouchGUI1_Definition->disp_handle,
			(uint8_t*) trans_cline,
			( (to_send > buf_colors) ? buf_bytes : (to_send * 3) ) );

			to_send -= buf_colors;
	}
  }





/*
	if (len == 0) return;
	if (!(ESP32_TouchGUI1_Definition->disp_handle->cfg.flags & LB_SPI_DEVICE_HALFDUPLEX)) return;

	// Send RAM WRITE command
    gpio_set_level(PIN_NUM_DC, 0);
    ESP32_TouchGUI1_Definition->disp_handle->host->hw->data_buf[0] = (uint32_t)TFT_RAMWR;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->mosi_dlen.usr_mosi_dbitlen = 7;
	ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr = 1;		// Start transfer
	while (ESP32_TouchGUI1_Definition->disp_handle->host->hw->cmd.usr);	// Wait for SPI bus ready

	gpio_set_level(PIN_NUM_DC, 1);								// Set DC to 1 (data mode);

	if ((len*24) <= 512) {

		_direct_send(ESP32_TouchGUI1_Definition, color, len, rep);

	}
	else if (rep == 0)  {
		// ==== use DMA transfer ====
		// ** Prepare data
		if (ESP32_TouchGUI1_Definition->gray_scale) {
			for (int n=0; n<len; n++) {
				color[n] = color2gs(color[n]);
			}
	    }

	    _dma_send(ESP32_TouchGUI1_Definition, (uint8_t *)color, len*3);
	}
	else {
		// ==== Repeat color, more than 512 bits total ====

		color_t _color;
		uint32_t buf_colors;
		int buf_bytes, to_send;

		
//		to_send = len;
//		while (to_send > 0) {
//			wait_trans_finish(0);
//			_direct_send(color, ((to_send > 21) ? 21 : to_send), rep);
//			to_send -= 21;
//		}
		

		buf_colors = ((len > (ESP32_TouchGUI1_Definition->_width*2)) ? (ESP32_TouchGUI1_Definition->_width*2) : len);
		buf_bytes = buf_colors * 3;

		// Prepare color buffer of maximum 2 color lines
		trans_cline = heap_caps_malloc(buf_bytes, MALLOC_CAP_DMA);
		if (trans_cline == NULL) return;

		// Prepare fill color
		if (ESP32_TouchGUI1_Definition->gray_scale) _color = color2gs(color[0]);
		else _color = color[0];

		// Fill color buffer with fill color
		for (uint32_t i=0; i<buf_colors; i++) {
			trans_cline[i] = _color;
		}

		// Send 'len' colors
		to_send = len;
		while (to_send > 0) {
			wait_trans_finish(ESP32_TouchGUI1_Definition, 0);
			_dma_send(ESP32_TouchGUI1_Definition, (uint8_t *)trans_cline, ((to_send > buf_colors) ? buf_bytes : (to_send*3)));
			to_send -= buf_colors;
		}
	}

	if (wait) wait_trans_finish(ESP32_TouchGUI1_Definition, 1);
*/
}



// Write 'len' repeated color data to TFT 'window' (x1,y2),(x2,y2)
//-------------------------------------------------------------------------------------------
void IRAM_ATTR 
TFT_pushColorRep(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
int x1,
	int y1,
	int x2,
	int y2,
	color_t color,
	uint32_t len)
{
  // set address window
  disp_spi_transfer_addrwin(ESP32_TouchGUI1_Definition->disp_handle, x1, x2, y1, y2);

  // send data
  _TFT_pushColorRep(ESP32_TouchGUI1_Definition, &color, len, 1, 1);
}



// Write 'len' color data to TFT 'window' (x1,y2),(x2,y2) from given buffer
//-----------------------------------------------------------------------------------
void IRAM_ATTR 
send_data(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	int x1,
	int y1,
	int x2,
	int y2,
	uint32_t len,
 	color_t *buf)
{
  // set address window
  disp_spi_transfer_addrwin(ESP32_TouchGUI1_Definition->disp_handle, x1, x2, y1, y2);

  // send data
  _TFT_pushColorRep(ESP32_TouchGUI1_Definition, buf, len, 0, 0);
}



/*

// Reads 'len' pixels/colors from the TFT's GRAM 'window'
// 'buf' is an array of bytes with 1st byte reserved for reading 1 dummy byte
// and the rest is actually an array of color_t values
//--------------------------------------------------------------------------------------------
int IRAM_ATTR 
read_data(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	int x1,
	int y1,
	int x2,
	int y2,
	int len,
	uint8_t *buf,
	uint8_t set_sp)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

	ESP32_SPI_Module_spi_transaction_t t;
	uint32_t current_clock = 0;

    memset(&t, 0, sizeof(t));  //Zero out the transaction
	memset(buf, 0, len*sizeof(color_t));

	if (set_sp) {
		if (disp_deselect(ESP32_TouchGUI1_Definition) != ESP_OK) return -1;
		// Change spi clock if needed
		current_clock = ESP32_SPI_provided_fn->ESP32_SPI_spi_get_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle);
		if (max_rdclock < current_clock) ESP32_SPI_provided_fn->ESP32_SPI_spi_set_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle, max_rdclock);
	}

	if (disp_select(ESP32_TouchGUI1_Definition) != ESP_OK) return -2;

	// ** Send address window **
	disp_spi_transfer_addrwin(ESP32_TouchGUI1_Definition->disp_handle, x1, x2, y1, y2);

    // ** GET pixels/colors **
	ESP32_SPI_transfer_only_cmd(ESP32_TouchGUI1_Definition->disp_handle, TFT_RAMRD);

    t.length=0;                //Send nothing
    t.tx_buffer=NULL;
    t.rxlength=8*((len*3)+1);  //Receive size in bits
    t.rx_buffer=buf;
    //t.user = (void*)1;

	esp_err_t res = 
	ESP32_SPI_provided_fn->ESP32_SPI_spi_transfer_dataFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle, &t); // Receive using direct mode

	disp_deselect(ESP32_TouchGUI1_Definition);

	if (set_sp) {
		// Restore spi clock if needed
		if (max_rdclock < current_clock) ESP32_SPI_provided_fn->ESP32_SPI_spi_set_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition,  ESP32_TouchGUI1_Definition->disp_handle, current_clock);
	}

    return res;
}



// Reads one pixel/color from the TFT's GRAM at position (x,y)
//-----------------------------------------------
color_t 
IRAM_ATTR 
readPixel(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	int16_t x,
	int16_t y)
{
    uint8_t color_buf[sizeof(color_t)+1] = {0};

    read_data(ESP32_TouchGUI1_Definition, x, y, x+1, y+1, 1, color_buf, 1);

    color_t color;
	color.r = color_buf[1];
	color.g = color_buf[2];
	color.b = color_buf[3];
	return color;
}



// get 16-bit data from touch controller for specified type
// ** Touch device must already be selected **
//----------------------------------------


int IRAM_ATTR 
touch_get_data(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint8_t type)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

    
//    esp_err_t ret;
//    spi_lobo_transaction_t t;
//    memset(&t, 0, sizeof(t));            //Zero out the transaction
//    uint8_t rxdata[2] = {0};

//    // send command byte & receive 2 byte response
//    t.rxlength=8*2;
//    t.rx_buffer=&rxdata;
//    t.command = type;

//    ret = spi_lobo_transfer_data(ts_spi, &t);    // Transmit using direct mode

//    if (ret != ESP_OK) return -1;
//    return (((int)(rxdata[0] << 8) | (int)(rxdata[1])) >> 4);
    
    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_selectFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->ts_spi, 0);

    ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] = type;
    _spi_transfer_start(ESP32_TouchGUI1_Definition->ts_spi, 24, 24);
    uint16_t res = (uint16_t)(ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] >> 8);

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_deselectFn(ESP32_TouchGUI1_Definition->ts_spi);

    return res;
}




// ==== STMPE610 ===============================================================




// ----- STMPE610 --------------------------------------------------------------------------



// Send 1 byte display command, display must be selected
//---------------------------------------------------------
static void IRAM_ATTR 
stmpe610_write_reg(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint8_t reg,
	uint8_t val)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_selectFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->ts_spi, 0);

    ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] = (val << 8) | reg;
    _spi_transfer_start(ESP32_TouchGUI1_Definition->ts_spi, 16, 0);

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_deselectFn(ESP32_TouchGUI1_Definition->ts_spi);
}



//-----------------------------------------------



static uint8_t IRAM_ATTR 
stmpe610_read_byte(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint8_t reg)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_selectFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->ts_spi, 0);

    ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] = (reg << 8) | (reg | 0x80);
    _spi_transfer_start(ESP32_TouchGUI1_Definition->ts_spi, 16, 16);
    uint8_t res = ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] >> 8;

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_deselectFn(ESP32_TouchGUI1_Definition->ts_spi);
    return res;
}



//-----------------------------------------
static uint16_t IRAM_ATTR
stmpe610_read_word(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition, 
	uint8_t reg)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;

    ESP32_SPI_provided_fn->ESP32_SPI_spi_device_selectFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->ts_spi, 0);

    ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] = ((((reg+1) << 8) | ((reg+1) | 0x80)) << 16) | (reg << 8) | (reg | 0x80);
    _spi_transfer_start(ESP32_TouchGUI1_Definition->ts_spi, 32, 32);
    uint16_t res = (uint16_t)(ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] & 0xFF00);
    res |= (uint16_t)(ESP32_TouchGUI1_Definition->ts_spi->host->hw->data_buf[0] >> 24);

     ESP32_SPI_provided_fn->ESP32_SPI_spi_device_deselectFn(ESP32_TouchGUI1_Definition->ts_spi);
    return res;
}



//-----------------------



uint32_t stmpe610_getID(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
    uint16_t tid = stmpe610_read_word(ESP32_TouchGUI1_Definition, 0);
    uint8_t tver = stmpe610_read_byte(ESP32_TouchGUI1_Definition, 2);
    return (tid << 8) | tver;
}



//==================



void 
stmpe610_Init(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_SYS_CTRL1, 0x02);        // Software chip reset

    vTaskDelay(10 / portTICK_RATE_MS);

    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_SYS_CTRL2, 0x04);        // Temperature sensor clock off, GPIO clock off, touch clock on, ADC clock on

    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_INT_EN, 0x00);           // Don't Interrupt on INT pin

    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_ADC_CTRL1, 0x48);        // ADC conversion time = 80 clock ticks, 12-bit ADC, internal voltage refernce

    vTaskDelay(2 / portTICK_RATE_MS);

    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_ADC_CTRL2, 0x01);        // ADC speed 3.25MHz
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_GPIO_AF, 0x00);          // GPIO alternate function - OFF
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CFG, 0xE3);          // Averaging 8, touch detect delay 1ms, panel driver settling time 1ms
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_TH, 0x01);          // FIFO threshold = 1
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_STA, 0x01);         // FIFO reset enable
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_STA, 0x00);         // FIFO reset disable
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_FRACT_XYZ, 0x07);    // Z axis data format
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_I_DRIVE, 0x01);      // max 50mA touchscreen line current
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CTRL, 0x30);         // X&Y&Z, 16 reading window
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CTRL, 0x31);         // X&Y&Z, 16 reading window, TSC enable
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_INT_STA, 0xFF);          // Clear all interrupts
    stmpe610_write_reg(ESP32_TouchGUI1_Definition, STMPE610_REG_INT_CTRL, 0x00);         // Level interrupt, disable interrupts
}



//===========================================================



int 
stmpe610_get_touch(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint16_t *x,
	uint16_t *y,
	uint16_t *z)
{
	if (!(stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CTRL) & 0x80)) return 0;

    // Get touch data
    uint8_t fifo_size = stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_SIZE);
    while (fifo_size < 2) {
    	if (!(stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CTRL) & 0x80)) return 0;
        fifo_size = stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_SIZE);
    }
    while (fifo_size > 120) {
    	if (!(stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_CTRL) & 0x80)) return 0;
        *x = stmpe610_read_word(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_X);
        *y = stmpe610_read_word(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_Y);
        *z = stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_Z);
        fifo_size = stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_FIFO_SIZE);
    }
    for (uint8_t i=0; i < (fifo_size-1); i++) {
        *x = stmpe610_read_word(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_X);
        *y = stmpe610_read_word(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_Y);
        *z = stmpe610_read_byte(ESP32_TouchGUI1_Definition, STMPE610_REG_TSC_DATA_Z);
    }

    *x = 4096 - *x;
    
    // Clear the rest of the fifo
//    {
//        stmpe610_write_reg(STMPE610_REG_FIFO_STA, 0x01);		// FIFO reset enable
//        stmpe610_write_reg(STMPE610_REG_FIFO_STA, 0x00);		// FIFO reset disable
//    }
    
	return 1;
}




// ==== STMPE610 ===========================================================================



// Find maximum spi clock for successful read from display RAM
// ** Must be used AFTER the display is initialized **
//======================
uint32_t 
find_rd_speed(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition)
{
  // get table of function callbacks provided & made accessible from stage 1 Module
  ESP32_SPI_ProvidedByModule_t* ESP32_SPI_provided_fn = (ESP32_SPI_ProvidedByModule_t*)
	ESP32_TouchGUI1_Definition->ESP32_SPI_Definition->common.module->provided;
 
	esp_err_t ret;
	color_t color;
	uint32_t max_speed = 1000000;
    uint32_t change_speed, cur_speed;
    int line_check;
    color_t *color_line = NULL;
    uint8_t *line_rdbuf = NULL;
    uint8_t gs = ESP32_TouchGUI1_Definition->gray_scale;

    ESP32_TouchGUI1_Definition->gray_scale = 0;
    cur_speed = ESP32_SPI_provided_fn->ESP32_SPI_spi_get_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle);

	color_line = malloc(ESP32_TouchGUI1_Definition->_width*3);
    if (color_line == NULL) goto exit;

    line_rdbuf = malloc((ESP32_TouchGUI1_Definition->_width*3)+1);
	if (line_rdbuf == NULL) goto exit;

	color_t *rdline = (color_t *)(line_rdbuf+1);

	// Fill test line with colors
	color = (color_t){0xEC,0xA8,0x74};
	for (int x=0; x<ESP32_TouchGUI1_Definition->_width; x++) {
		color_line[x] = color;
	}

	// Find maximum read spi clock
	for (uint32_t speed=2000000; speed<=cur_speed; speed += 1000000) {
		change_speed = ESP32_SPI_provided_fn->ESP32_SPI_spi_set_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle, speed);
		if (change_speed == 0) goto exit;

		memset(line_rdbuf, 0, ESP32_TouchGUI1_Definition->_width*sizeof(color_t)+1);

		if (disp_select(ESP32_TouchGUI1_Definition)) goto exit;
		// Write color line
		send_data(ESP32_TouchGUI1_Definition, 0, ESP32_TouchGUI1_Definition->_height/2, ESP32_TouchGUI1_Definition->_width-1, ESP32_TouchGUI1_Definition->_height/2, ESP32_TouchGUI1_Definition->_width, color_line);
		if (disp_deselect(ESP32_TouchGUI1_Definition)) goto exit;

		// Read color line
		ret = read_data(ESP32_TouchGUI1_Definition, 0, ESP32_TouchGUI1_Definition->_height/2, ESP32_TouchGUI1_Definition->_width-1, ESP32_TouchGUI1_Definition->_height/2, ESP32_TouchGUI1_Definition->_width, line_rdbuf, 0);

		// Compare
		line_check = 0;
		if (ret == ESP_OK) {
			for (int y=0; y<ESP32_TouchGUI1_Definition->_width; y++) {
				if ((color_line[y].r & 0xFC) != (rdline[y].r & 0xFC)) line_check = 1;
				else if ((color_line[y].g & 0xFC) != (rdline[y].g & 0xFC)) line_check = 1;
				else if ((color_line[y].b & 0xFC) != (rdline[y].b & 0xFC)) line_check =  1;
				if (line_check) break;
			}
		}
		else line_check = ret;

		if (line_check) break;
		max_speed = speed;
	}

exit:
    ESP32_TouchGUI1_Definition->gray_scale = gs;
	if (line_rdbuf) free(line_rdbuf);
	if (color_line) free(color_line);

	// restore spi clk
	change_speed = ESP32_SPI_provided_fn->ESP32_SPI_spi_set_speedFn(ESP32_TouchGUI1_Definition->ESP32_SPI_Definition, ESP32_TouchGUI1_Definition->disp_handle, cur_speed);

	return max_speed;
}



*/

//==================================
void 
_tft_setRotation(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	uint8_t rot)
{
  uint8_t rotation = rot & 3; // can't be higher than 3
  uint8_t send = 1;
  uint8_t madctl = 0;
  uint16_t tmp;

  if ((rotation & 1)) {

	// in landscape modes must be width > height
	if (ESP32_TouchGUI1_Definition->_width < ESP32_TouchGUI1_Definition->_height) {

		tmp = ESP32_TouchGUI1_Definition->_width;
            	ESP32_TouchGUI1_Definition->_width  = ESP32_TouchGUI1_Definition->_height;
           	ESP32_TouchGUI1_Definition->_height = tmp;
	}
  }

  else {

	// in portrait modes must be width < height
        if (ESP32_TouchGUI1_Definition->_width > ESP32_TouchGUI1_Definition->_height) {

		tmp = ESP32_TouchGUI1_Definition->_width;

		ESP32_TouchGUI1_Definition->_width  = ESP32_TouchGUI1_Definition->_height;

		ESP32_TouchGUI1_Definition->_height = tmp;
        }
    }

    #if TFT_INVERT_ROTATION
    switch (rotation) {
        case PORTRAIT:
        madctl = (MADCTL_MV | TFT_RGB_BGR);
        break;
        case LANDSCAPE:
        madctl = (MADCTL_MX | TFT_RGB_BGR);
        break;
        case PORTRAIT_FLIP:
        madctl = (MADCTL_MV | TFT_RGB_BGR);
        break;
        case LANDSCAPE_FLIP:
        madctl = (MADCTL_MY | TFT_RGB_BGR);
        break;
    }
    #elif TFT_INVERT_ROTATION1
    switch (rotation) {
        case PORTRAIT:
        madctl = (MADCTL_MY | MADCTL_MX | TFT_RGB_BGR);
        break;
        case LANDSCAPE:
        madctl = (MADCTL_MY | MADCTL_MV | TFT_RGB_BGR);
        break;
        case PORTRAIT_FLIP:
        madctl = (TFT_RGB_BGR);
        break;
        case LANDSCAPE_FLIP:
        madctl = (MADCTL_MX | MADCTL_MV | TFT_RGB_BGR);
        break;
    }
    #elif TFT_INVERT_ROTATION2
    switch (rotation) {
        case PORTRAIT:
        madctl = (MADCTL_MX | MADCTL_MV | TFT_RGB_BGR);
        break;
        case LANDSCAPE:
        madctl = (TFT_RGB_BGR);
        break;
        case PORTRAIT_FLIP:
        madctl = (MADCTL_MY | MADCTL_MV | TFT_RGB_BGR);
        break;
        case LANDSCAPE_FLIP:
        madctl = (MADCTL_MY | MADCTL_MX | TFT_RGB_BGR);
        break;
    }
    #else
    switch (rotation) {
        case PORTRAIT:
        madctl = (MADCTL_MX | TFT_RGB_BGR);
        break;
        case LANDSCAPE:
        madctl = (MADCTL_MV | TFT_RGB_BGR);
        break;
        case PORTRAIT_FLIP:
        madctl = (MADCTL_MY | TFT_RGB_BGR);
        break;
        case LANDSCAPE_FLIP:
        madctl = (MADCTL_MX | MADCTL_MY | MADCTL_MV | TFT_RGB_BGR);
        break;
    }
    #endif

  if (send) {

	ESP32_SPI_polling_transmit_cmd_and_data(ESP32_TouchGUI1_Definition->disp_handle,
		TFT_MADCTL,
		&madctl,
		1);
  }
}







/**
 * --------------------------------------------------------------------------------------------------
 *  FName: TFT_display_init (Write an Command List)
 *  Desc: Initialize the display + set orientation + clear
 *  Info: 
 *  Para: ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition -> current_Definition handle
 *        ESP32_SPI_Module_spi_device_handle_t spi -> the spi device that should receive the cmds
 *	  const uint8_t *addr -> the Command List Table, including delays
 *  Rets: -/-
 * --------------------------------------------------------------------------------------------------
 */
// Initialize the display
// ====================
strTextMultiple_t*
TFT_display_init(ESP32_TouchGUI1_Definition_t* ESP32_TouchGUI1_Definition,
	ESP32_SPI_device_handle_t disp_handle,
	DisplayConfig_t display_config)
{
  // for Fn response msg
  strTextMultiple_t* retMsg = SCDE_OK;

  // display needs D/C -> setup
  gpio_pad_select_gpio(PIN_NUM_DC);
  gpio_set_direction(PIN_NUM_DC, GPIO_MODE_OUTPUT);
  gpio_set_level(PIN_NUM_DC, 0);



  #if USE_TOUCH
//  gpio_pad_select_gpio(PIN_NUM_TCS);
//  gpio_set_direction(PIN_NUM_TCS, GPIO_MODE_OUTPUT);
  #endif  
  
#if PIN_NUM_BCKL
  gpio_pad_select_gpio(PIN_NUM_BCKL);
  gpio_set_direction(PIN_NUM_BCKL, GPIO_MODE_OUTPUT);
  gpio_set_level(PIN_NUM_BCKL, PIN_BCKL_OFF);
#endif

#if PIN_NUM_RST
  gpio_pad_select_gpio(PIN_NUM_RST);
  gpio_set_direction(PIN_NUM_RST, GPIO_MODE_OUTPUT);
  gpio_set_level(PIN_NUM_RST, 0);
#endif



  esp_err_t ret;

  #if PIN_NUM_RST
  // reset the display
  gpio_set_level(PIN_NUM_RST, 0);
  vTaskDelay(20 / portTICK_RATE_MS);
  gpio_set_level(PIN_NUM_RST, 1);
  vTaskDelay(150 / portTICK_RATE_MS);
  #endif

  // get the display type
  uint8_t tft_disp_type = ESP32_TouchGUI1_Definition->display_config.tft_disp_type;



  // Send the initialization commands
  if (tft_disp_type == DISP_TYPE_ILI9341) {

	ESP32_SPI_write_cmd_list(disp_handle, ILI9341_init);
  }

  else if (tft_disp_type == DISP_TYPE_ILI9488) {

	ESP32_SPI_write_cmd_list(disp_handle, ILI9488_init);
  }

  else if (tft_disp_type == DISP_TYPE_ST7789V) {

	ESP32_SPI_write_cmd_list(disp_handle, ST7789V_init);
  }

  else if (tft_disp_type == DISP_TYPE_ST7735) {

	ESP32_SPI_write_cmd_list(disp_handle, STP7735_init);
  }

  else if (tft_disp_type == DISP_TYPE_ST7735R) {

	ESP32_SPI_write_cmd_list(disp_handle, STP7735R_init);
	ESP32_SPI_write_cmd_list(disp_handle, Rcmd2green);
	ESP32_SPI_write_cmd_list(disp_handle, Rcmd3);
  }

  else if (tft_disp_type == DISP_TYPE_ST7735B) {

	ESP32_SPI_write_cmd_list(disp_handle, STP7735R_init);
	ESP32_SPI_write_cmd_list(disp_handle, Rcmd2red);
	ESP32_SPI_write_cmd_list(disp_handle, Rcmd3);

	uint8_t dt = 0xC0;

	ESP32_SPI_polling_transmit_cmd_and_data(disp_handle,
		TFT_MADCTL,
		&dt,
		1);
  }

  else assert(0);

  // set rotation, clear screen

  _tft_setRotation(ESP32_TouchGUI1_Definition, PORTRAIT);

  TFT_pushColorRep(ESP32_TouchGUI1_Definition,
	0,
	0,
	ESP32_TouchGUI1_Definition->_width - 1,
	ESP32_TouchGUI1_Definition->_height - 1,
	(color_t){0,0,0},
	(uint32_t)(ESP32_TouchGUI1_Definition->_height * ESP32_TouchGUI1_Definition->_width) );

  // enable backlight
  #if PIN_NUM_BCKL
  gpio_set_level(PIN_NUM_BCKL, PIN_BCKL_ON);
  #endif

  return retMsg;
}





















































































































































//  ################# functions to move ################## 











// verschieben zu ESP32_SPI_Module PIN_NUM_DC?
// Send command with attached data to spi device, device must be selected !
/** eigentlich ins ESP32_SPI_Module ? über WriteFn?
 * --------------------------------------------------------------------------------------------------
 *  FName: Polling transmit commands and data
 *  Desc: Sends an command, followed by len bytes of data form *addr to the spi device
 *  Info: 
 *  Para: ESP32_SPI_Module_spi_device_handle_t spi_device_handle, -> the destination spi device
 *	  const uint8_t* data -> the data to send
 *        uint32_t len -> the length to send
 *  Rets: -/-
 * --------------------------------------------------------------------------------------------------
 */
void
ESP32_SPI_polling_transmit_cmd_and_data(ESP32_SPI_device_handle_t spi_device_handle,
	int8_t cmd,
	const uint8_t* data,
	uint32_t len)
{
  esp_err_t ret;

  ESP32_SPI_transaction_t t;

  // first the cmd
  memset(&t, 0, sizeof(t));	// zero struct
  t.length = 1 * 8;		// len is in bytes, transaction length is in bits
  t.tx_buffer = &cmd;		// the data is the cmd itself
  t.user = (void*) 0;		// D/C needs to be set to 0 for TX command

  ret = ESP32_SPI_device_polling_transmit(spi_device_handle, &t);

  assert(ret==ESP_OK);

  // then the data
  if ( len == 0 ) return; 	// no data ?

  memset(&t, 0, sizeof(t));	// zero struct
  t.length = len * 8;		// len is in bytes, transaction length is in bits
  t.tx_buffer = data;		// the data is the cmd itself
  t.user = (void*) 1;		// D/C needs to be set to 1 for TX data

  ret = ESP32_SPI_device_polling_transmit(spi_device_handle, &t);

  assert(ret==ESP_OK);
}



/** eigentlich ins ESP32_SPI_Module ? über WriteFn?
 * --------------------------------------------------------------------------------------------------
 *  FName: Write Command List (Write an Command List)
 *  Desc: Reads and sends (polling!) a series of SPI commands/data stored in byte array, incl. delays.
 *  Info: 
 *  Para: ESP32_SPI_Module_spi_device_handle_t spi_device_handle, -> the destination spi device
 *	  const uint8_t *addr -> the Command List Table, including delays
 *  Rets: -/-
 * --------------------------------------------------------------------------------------------------
 */
void 
ESP32_SPI_write_cmd_list(ESP32_SPI_device_handle_t spi_device_handle,
	const uint8_t* addr)
{
  uint8_t numCommands, numArgs, cmd;
  uint16_t ms;

  // read number of commands to follow
  numCommands = *addr++;

  // for each command...
  while ( numCommands-- ) {

	// read command
	cmd = *addr++;

	// read number of args to follow
	numArgs  = *addr++;

	// If high bit set in numArgs, delay time (ms) follows the args
	ms = numArgs & TFT_CMD_DELAY;

	// mask out the delay-info-bit, to get the real number of args
	numArgs &= ~TFT_CMD_DELAY;

	// transfer to spi
	ESP32_SPI_polling_transmit_cmd_and_data(spi_device_handle,
		cmd,
		(uint8_t *)addr,
		numArgs);

	addr += numArgs;


	// delay requested ?
	if (ms) {

		// Read post-command data (-> delay time in ms )
		ms = *addr++;

		// 255 -> override / special
		if (ms == 255) ms = 500;    // If 255, delay for 500 ms

		// now the delay
		vTaskDelay(ms / portTICK_RATE_MS);
	}
  }
}









